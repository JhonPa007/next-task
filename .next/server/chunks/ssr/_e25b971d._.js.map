{"version":3,"sources":["../../../../node_modules/next/src/server/app-render/manifests-singleton.ts","../../../../node_modules/next/src/server/app-render/encryption-utils.ts","../../../../node_modules/next/src/server/app-render/encryption.ts","../../../../src/components/routines/RoutinesManager.tsx/__nextjs-internal-proxy.mjs","../../../../src/app/my-tasks/page.tsx","../../../../src/app/actions/routines.ts"],"sourcesContent":["import type { ActionManifest } from '../../build/webpack/plugins/flight-client-entry-plugin'\nimport type { ClientReferenceManifest } from '../../build/webpack/plugins/flight-manifest-plugin'\nimport type { DeepReadonly } from '../../shared/lib/deep-readonly'\nimport { InvariantError } from '../../shared/lib/invariant-error'\nimport { normalizeAppPath } from '../../shared/lib/router/utils/app-paths'\nimport { pathHasPrefix } from '../../shared/lib/router/utils/path-has-prefix'\nimport { removePathPrefix } from '../../shared/lib/router/utils/remove-path-prefix'\nimport { workAsyncStorage } from './work-async-storage.external'\n\nexport interface ServerModuleMap {\n  readonly [name: string]: {\n    readonly id: string | number\n    readonly name: string\n    readonly chunks: Readonly<Array<string>> // currently not used\n    readonly async?: boolean\n  }\n}\n\n// This is a global singleton that is, among other things, also used to\n// encode/decode bound args of server function closures. This can't be using a\n// AsyncLocalStorage as it might happen at the module level.\nconst MANIFESTS_SINGLETON = Symbol.for('next.server.manifests')\n\ninterface ManifestsSingleton {\n  readonly clientReferenceManifestsPerRoute: Map<\n    string,\n    DeepReadonly<ClientReferenceManifest>\n  >\n  readonly proxiedClientReferenceManifest: DeepReadonly<ClientReferenceManifest>\n  serverActionsManifest: DeepReadonly<ActionManifest>\n  serverModuleMap: ServerModuleMap\n}\n\ntype GlobalThisWithManifests = typeof globalThis & {\n  [MANIFESTS_SINGLETON]?: ManifestsSingleton\n}\n\ntype ClientReferenceManifestMappingProp =\n  | 'clientModules'\n  | 'rscModuleMapping'\n  | 'edgeRscModuleMapping'\n  | 'ssrModuleMapping'\n  | 'edgeSSRModuleMapping'\n\nconst globalThisWithManifests = globalThis as GlobalThisWithManifests\n\nfunction createProxiedClientReferenceManifest(\n  clientReferenceManifestsPerRoute: Map<\n    string,\n    DeepReadonly<ClientReferenceManifest>\n  >\n): DeepReadonly<ClientReferenceManifest> {\n  const createMappingProxy = (prop: ClientReferenceManifestMappingProp) => {\n    return new Proxy(\n      {},\n      {\n        get(_, id: string) {\n          const workStore = workAsyncStorage.getStore()\n\n          if (workStore) {\n            const currentManifest = clientReferenceManifestsPerRoute.get(\n              workStore.route\n            )\n\n            if (currentManifest?.[prop][id]) {\n              return currentManifest[prop][id]\n            }\n\n            // In development, we also check all other manifests to see if the\n            // module exists there. This is to support a scenario where React's\n            // I/O tracking (dev-only) creates a connection from one page to\n            // another through an emitted async I/O node that references client\n            // components from the other page, e.g. in owner props.\n            // TODO: Maybe we need to add a `debugBundlerConfig` option to React\n            // to avoid this workaround. The current workaround has the\n            // disadvantage that one might accidentally or intentionally share\n            // client references across pages (e.g. by storing them in a global\n            // variable), which would then only be caught in production.\n            if (process.env.NODE_ENV !== 'production') {\n              for (const [\n                route,\n                manifest,\n              ] of clientReferenceManifestsPerRoute) {\n                if (route === workStore.route) {\n                  continue\n                }\n\n                const entry = manifest[prop][id]\n\n                if (entry !== undefined) {\n                  return entry\n                }\n              }\n            }\n          } else {\n            // If there's no work store defined, we can assume that a client\n            // reference manifest is needed during module evaluation, e.g. to\n            // create a server function using a higher-order function. This\n            // might also use client components which need to be serialized by\n            // Flight, and therefore client references need to be resolvable. In\n            // that case we search all page manifests to find the module.\n            for (const manifest of clientReferenceManifestsPerRoute.values()) {\n              const entry = manifest[prop][id]\n\n              if (entry !== undefined) {\n                return entry\n              }\n            }\n          }\n\n          return undefined\n        },\n      }\n    )\n  }\n\n  const mappingProxies = new Map<\n    ClientReferenceManifestMappingProp,\n    ReturnType<typeof createMappingProxy>\n  >()\n\n  return new Proxy(\n    {},\n    {\n      get(_, prop) {\n        const workStore = workAsyncStorage.getStore()\n\n        switch (prop) {\n          case 'moduleLoading':\n          case 'entryCSSFiles':\n          case 'entryJSFiles': {\n            if (!workStore) {\n              throw new InvariantError(\n                `Cannot access \"${prop}\" without a work store.`\n              )\n            }\n\n            const currentManifest = clientReferenceManifestsPerRoute.get(\n              workStore.route\n            )\n\n            if (!currentManifest) {\n              throw new InvariantError(\n                `The client reference manifest for route \"${workStore.route}\" does not exist.`\n              )\n            }\n\n            return currentManifest[prop]\n          }\n          case 'clientModules':\n          case 'rscModuleMapping':\n          case 'edgeRscModuleMapping':\n          case 'ssrModuleMapping':\n          case 'edgeSSRModuleMapping': {\n            let proxy = mappingProxies.get(prop)\n\n            if (!proxy) {\n              proxy = createMappingProxy(prop)\n              mappingProxies.set(prop, proxy)\n            }\n\n            return proxy\n          }\n          default: {\n            throw new InvariantError(\n              `This is a proxied client reference manifest. The property \"${String(prop)}\" is not handled.`\n            )\n          }\n        }\n      },\n    }\n  ) as DeepReadonly<ClientReferenceManifest>\n}\n\n/**\n * This function creates a Flight-acceptable server module map proxy from our\n * Server Reference Manifest similar to our client module map. This is because\n * our manifest contains a lot of internal Next.js data that are relevant to the\n * runtime, workers, etc. that React doesn't need to know.\n */\nfunction createServerModuleMap(): ServerModuleMap {\n  return new Proxy(\n    {},\n    {\n      get: (_, id: string) => {\n        const workers =\n          getServerActionsManifest()[\n            process.env.NEXT_RUNTIME === 'edge' ? 'edge' : 'node'\n          ]?.[id]?.workers\n\n        if (!workers) {\n          return undefined\n        }\n\n        const workStore = workAsyncStorage.getStore()\n\n        let workerEntry:\n          | { moduleId: string | number; async: boolean }\n          | undefined\n\n        if (workStore) {\n          workerEntry = workers[normalizeWorkerPageName(workStore.page)]\n        } else {\n          // If there's no work store defined, we can assume that a server\n          // module map is needed during module evaluation, e.g. to create a\n          // server action using a higher-order function. Therefore it should be\n          // safe to return any entry from the manifest that matches the action\n          // ID. They all refer to the same module ID, which must also exist in\n          // the current page bundle. TODO: This is currently not guaranteed in\n          // Turbopack, and needs to be fixed.\n          workerEntry = Object.values(workers).at(0)\n        }\n\n        if (!workerEntry) {\n          return undefined\n        }\n\n        const { moduleId, async } = workerEntry\n\n        return { id: moduleId, name: id, chunks: [], async }\n      },\n    }\n  )\n}\n\n/**\n * The flight entry loader keys actions by bundlePath. bundlePath corresponds\n * with the relative path (including 'app') to the page entrypoint.\n */\nfunction normalizeWorkerPageName(pageName: string) {\n  if (pathHasPrefix(pageName, 'app')) {\n    return pageName\n  }\n\n  return 'app' + pageName\n}\n\n/**\n * Converts a bundlePath (relative path to the entrypoint) to a routable page\n * name.\n */\nfunction denormalizeWorkerPageName(bundlePath: string) {\n  return normalizeAppPath(removePathPrefix(bundlePath, 'app'))\n}\n\n/**\n * Checks if the requested action has a worker for the current page.\n * If not, it returns the first worker that has a handler for the action.\n */\nexport function selectWorkerForForwarding(\n  actionId: string,\n  pageName: string\n): string | undefined {\n  const serverActionsManifest = getServerActionsManifest()\n  const workers =\n    serverActionsManifest[\n      process.env.NEXT_RUNTIME === 'edge' ? 'edge' : 'node'\n    ][actionId]?.workers\n\n  // There are no workers to handle this action, nothing to forward to.\n  if (!workers) {\n    return\n  }\n\n  // If there is an entry for the current page, we don't need to forward.\n  if (workers[normalizeWorkerPageName(pageName)]) {\n    return\n  }\n\n  // Otherwise, grab the first worker that has a handler for this action id.\n  return denormalizeWorkerPageName(Object.keys(workers)[0])\n}\n\nexport function setManifestsSingleton({\n  page,\n  clientReferenceManifest,\n  serverActionsManifest,\n}: {\n  page: string\n  clientReferenceManifest: DeepReadonly<ClientReferenceManifest>\n  serverActionsManifest: DeepReadonly<ActionManifest>\n}) {\n  const existingSingleton = globalThisWithManifests[MANIFESTS_SINGLETON]\n\n  if (existingSingleton) {\n    existingSingleton.clientReferenceManifestsPerRoute.set(\n      normalizeAppPath(page),\n      clientReferenceManifest\n    )\n\n    existingSingleton.serverActionsManifest = serverActionsManifest\n  } else {\n    const clientReferenceManifestsPerRoute = new Map<\n      string,\n      DeepReadonly<ClientReferenceManifest>\n    >([[normalizeAppPath(page), clientReferenceManifest]])\n\n    const proxiedClientReferenceManifest = createProxiedClientReferenceManifest(\n      clientReferenceManifestsPerRoute\n    )\n\n    globalThisWithManifests[MANIFESTS_SINGLETON] = {\n      clientReferenceManifestsPerRoute,\n      proxiedClientReferenceManifest,\n      serverActionsManifest,\n      serverModuleMap: createServerModuleMap(),\n    }\n  }\n}\n\nfunction getManifestsSingleton(): ManifestsSingleton {\n  const manifestSingleton = globalThisWithManifests[MANIFESTS_SINGLETON]\n\n  if (!manifestSingleton) {\n    throw new InvariantError('The manifests singleton was not initialized.')\n  }\n\n  return manifestSingleton\n}\n\nexport function getClientReferenceManifest(): DeepReadonly<ClientReferenceManifest> {\n  return getManifestsSingleton().proxiedClientReferenceManifest\n}\n\nexport function getServerActionsManifest(): DeepReadonly<ActionManifest> {\n  return getManifestsSingleton().serverActionsManifest\n}\n\nexport function getServerModuleMap() {\n  return getManifestsSingleton().serverModuleMap\n}\n","import { InvariantError } from '../../shared/lib/invariant-error'\nimport { getServerActionsManifest } from './manifests-singleton'\n\nlet __next_loaded_action_key: CryptoKey\n\nexport function arrayBufferToString(\n  buffer: ArrayBuffer | Uint8Array<ArrayBufferLike>\n) {\n  const bytes = new Uint8Array(buffer)\n  const len = bytes.byteLength\n\n  // @anonrig: V8 has a limit of 65535 arguments in a function.\n  // For len < 65535, this is faster.\n  // https://github.com/vercel/next.js/pull/56377#pullrequestreview-1656181623\n  if (len < 65535) {\n    return String.fromCharCode.apply(null, bytes as unknown as number[])\n  }\n\n  let binary = ''\n  for (let i = 0; i < len; i++) {\n    binary += String.fromCharCode(bytes[i])\n  }\n  return binary\n}\n\nexport function stringToUint8Array(binary: string) {\n  const len = binary.length\n  const arr = new Uint8Array(len)\n\n  for (let i = 0; i < len; i++) {\n    arr[i] = binary.charCodeAt(i)\n  }\n\n  return arr\n}\n\nexport function encrypt(\n  key: CryptoKey,\n  iv: Uint8Array<ArrayBuffer>,\n  data: Uint8Array<ArrayBuffer>\n) {\n  return crypto.subtle.encrypt(\n    {\n      name: 'AES-GCM',\n      iv,\n    },\n    key,\n    data\n  )\n}\n\nexport function decrypt(\n  key: CryptoKey,\n  iv: Uint8Array<ArrayBuffer>,\n  data: Uint8Array<ArrayBuffer>\n) {\n  return crypto.subtle.decrypt(\n    {\n      name: 'AES-GCM',\n      iv,\n    },\n    key,\n    data\n  )\n}\n\nexport async function getActionEncryptionKey() {\n  if (__next_loaded_action_key) {\n    return __next_loaded_action_key\n  }\n\n  const serverActionsManifest = getServerActionsManifest()\n\n  const rawKey =\n    process.env.NEXT_SERVER_ACTIONS_ENCRYPTION_KEY ||\n    serverActionsManifest.encryptionKey\n\n  if (rawKey === undefined) {\n    throw new InvariantError('Missing encryption key for Server Actions')\n  }\n\n  __next_loaded_action_key = await crypto.subtle.importKey(\n    'raw',\n    stringToUint8Array(atob(rawKey)),\n    'AES-GCM',\n    true,\n    ['encrypt', 'decrypt']\n  )\n\n  return __next_loaded_action_key\n}\n","/* eslint-disable import/no-extraneous-dependencies */\nimport 'server-only'\n\n/* eslint-disable import/no-extraneous-dependencies */\nimport { renderToReadableStream } from 'react-server-dom-webpack/server'\n/* eslint-disable import/no-extraneous-dependencies */\nimport { createFromReadableStream } from 'react-server-dom-webpack/client'\n\nimport { streamToString } from '../stream-utils/node-web-streams-helper'\nimport {\n  arrayBufferToString,\n  decrypt,\n  encrypt,\n  getActionEncryptionKey,\n  stringToUint8Array,\n} from './encryption-utils'\nimport {\n  getClientReferenceManifest,\n  getServerModuleMap,\n} from './manifests-singleton'\nimport {\n  getCacheSignal,\n  getPrerenderResumeDataCache,\n  getRenderResumeDataCache,\n  workUnitAsyncStorage,\n} from './work-unit-async-storage.external'\nimport { createHangingInputAbortSignal } from './dynamic-rendering'\nimport React from 'react'\n\nconst isEdgeRuntime = process.env.NEXT_RUNTIME === 'edge'\n\nconst textEncoder = new TextEncoder()\nconst textDecoder = new TextDecoder()\n\nconst filterStackFrame =\n  process.env.NODE_ENV !== 'production'\n    ? (require('../lib/source-maps') as typeof import('../lib/source-maps'))\n        .filterStackFrameDEV\n    : undefined\nconst findSourceMapURL =\n  process.env.NODE_ENV !== 'production'\n    ? (require('../lib/source-maps') as typeof import('../lib/source-maps'))\n        .findSourceMapURLDEV\n    : undefined\n\n/**\n * Decrypt the serialized string with the action id as the salt.\n */\nasync function decodeActionBoundArg(actionId: string, arg: string) {\n  const key = await getActionEncryptionKey()\n  if (typeof key === 'undefined') {\n    throw new Error(\n      `Missing encryption key for Server Action. This is a bug in Next.js`\n    )\n  }\n\n  // Get the iv (16 bytes) and the payload from the arg.\n  const originalPayload = atob(arg)\n  const ivValue = originalPayload.slice(0, 16)\n  const payload = originalPayload.slice(16)\n\n  const decrypted = textDecoder.decode(\n    await decrypt(key, stringToUint8Array(ivValue), stringToUint8Array(payload))\n  )\n\n  if (!decrypted.startsWith(actionId)) {\n    throw new Error('Invalid Server Action payload: failed to decrypt.')\n  }\n\n  return decrypted.slice(actionId.length)\n}\n\n/**\n * Encrypt the serialized string with the action id as the salt. Add a prefix to\n * later ensure that the payload is correctly decrypted, similar to a checksum.\n */\nasync function encodeActionBoundArg(actionId: string, arg: string) {\n  const key = await getActionEncryptionKey()\n  if (key === undefined) {\n    throw new Error(\n      `Missing encryption key for Server Action. This is a bug in Next.js`\n    )\n  }\n\n  // Get 16 random bytes as iv.\n  const randomBytes = new Uint8Array(16)\n  workUnitAsyncStorage.exit(() => crypto.getRandomValues(randomBytes))\n  const ivValue = arrayBufferToString(randomBytes.buffer)\n\n  const encrypted = await encrypt(\n    key,\n    randomBytes,\n    textEncoder.encode(actionId + arg)\n  )\n\n  return btoa(ivValue + arrayBufferToString(encrypted))\n}\n\nenum ReadStatus {\n  Ready,\n  Pending,\n  Complete,\n}\n\n// Encrypts the action's bound args into a string. For the same combination of\n// actionId and args the same cached promise is returned. This ensures reference\n// equality for returned objects from \"use cache\" functions when they're invoked\n// multiple times within one render pass using the same bound args.\nexport const encryptActionBoundArgs = React.cache(\n  async function encryptActionBoundArgs(actionId: string, ...args: any[]) {\n    const workUnitStore = workUnitAsyncStorage.getStore()\n    const cacheSignal = workUnitStore\n      ? getCacheSignal(workUnitStore)\n      : undefined\n\n    const { clientModules } = getClientReferenceManifest()\n\n    // Create an error before any asynchronous calls, to capture the original\n    // call stack in case we need it when the serialization errors.\n    const error = new Error()\n    Error.captureStackTrace(error, encryptActionBoundArgs)\n\n    let didCatchError = false\n\n    const hangingInputAbortSignal = workUnitStore\n      ? createHangingInputAbortSignal(workUnitStore)\n      : undefined\n\n    let readStatus = ReadStatus.Ready\n    function startReadOnce() {\n      if (readStatus === ReadStatus.Ready) {\n        readStatus = ReadStatus.Pending\n        cacheSignal?.beginRead()\n      }\n    }\n\n    function endReadIfStarted() {\n      if (readStatus === ReadStatus.Pending) {\n        cacheSignal?.endRead()\n      }\n      readStatus = ReadStatus.Complete\n    }\n\n    // streamToString might take longer than a microtask to resolve and then other things\n    // waiting on the cache signal might not realize there is another cache to fill so if\n    // we are no longer waiting on the bound args serialization via the hangingInputAbortSignal\n    // we should eagerly start the cache read to prevent other readers of the cache signal from\n    // missing this cache fill. We use a idempotent function to only start reading once because\n    // it's also possible that streamToString finishes before the hangingInputAbortSignal aborts.\n    if (hangingInputAbortSignal && cacheSignal) {\n      hangingInputAbortSignal.addEventListener('abort', startReadOnce, {\n        once: true,\n      })\n    }\n\n    // Using Flight to serialize the args into a string.\n    const serialized = await streamToString(\n      renderToReadableStream(args, clientModules, {\n        filterStackFrame,\n        signal: hangingInputAbortSignal,\n        onError(err) {\n          if (hangingInputAbortSignal?.aborted) {\n            return\n          }\n\n          // We're only reporting one error at a time, starting with the first.\n          if (didCatchError) {\n            return\n          }\n\n          didCatchError = true\n\n          // Use the original error message together with the previously created\n          // stack, because err.stack is a useless Flight Server call stack.\n          error.message = err instanceof Error ? err.message : String(err)\n        },\n      }),\n      // We pass the abort signal to `streamToString` so that no chunks are\n      // included that are emitted after the signal was already aborted. This\n      // ensures that we can encode hanging promises.\n      hangingInputAbortSignal\n    )\n\n    if (didCatchError) {\n      if (process.env.NODE_ENV === 'development') {\n        // Logging the error is needed for server functions that are passed to the\n        // client where the decryption is not done during rendering. Console\n        // replaying allows us to still show the error dev overlay in this case.\n        console.error(error)\n      }\n\n      endReadIfStarted()\n      throw error\n    }\n\n    if (!workUnitStore) {\n      // We don't need to call cacheSignal.endRead here because we can't have a cacheSignal\n      // if we do not have a workUnitStore.\n      return encodeActionBoundArg(actionId, serialized)\n    }\n\n    startReadOnce()\n\n    const prerenderResumeDataCache = getPrerenderResumeDataCache(workUnitStore)\n    const renderResumeDataCache = getRenderResumeDataCache(workUnitStore)\n    const cacheKey = actionId + serialized\n\n    const cachedEncrypted =\n      prerenderResumeDataCache?.encryptedBoundArgs.get(cacheKey) ??\n      renderResumeDataCache?.encryptedBoundArgs.get(cacheKey)\n\n    if (cachedEncrypted) {\n      return cachedEncrypted\n    }\n\n    const encrypted = await encodeActionBoundArg(actionId, serialized)\n\n    endReadIfStarted()\n    prerenderResumeDataCache?.encryptedBoundArgs.set(cacheKey, encrypted)\n\n    return encrypted\n  }\n)\n\n// Decrypts the action's bound args from the encrypted string.\nexport async function decryptActionBoundArgs(\n  actionId: string,\n  encryptedPromise: Promise<string>\n) {\n  const encrypted = await encryptedPromise\n  const workUnitStore = workUnitAsyncStorage.getStore()\n\n  let decrypted: string | undefined\n\n  if (workUnitStore) {\n    const cacheSignal = getCacheSignal(workUnitStore)\n    const prerenderResumeDataCache = getPrerenderResumeDataCache(workUnitStore)\n    const renderResumeDataCache = getRenderResumeDataCache(workUnitStore)\n\n    decrypted =\n      prerenderResumeDataCache?.decryptedBoundArgs.get(encrypted) ??\n      renderResumeDataCache?.decryptedBoundArgs.get(encrypted)\n\n    if (!decrypted) {\n      cacheSignal?.beginRead()\n      decrypted = await decodeActionBoundArg(actionId, encrypted)\n      cacheSignal?.endRead()\n      prerenderResumeDataCache?.decryptedBoundArgs.set(encrypted, decrypted)\n    }\n  } else {\n    decrypted = await decodeActionBoundArg(actionId, encrypted)\n  }\n\n  const { edgeRscModuleMapping, rscModuleMapping } =\n    getClientReferenceManifest()\n\n  // Using Flight to deserialize the args from the string.\n  const deserialized = await createFromReadableStream(\n    new ReadableStream({\n      start(controller) {\n        controller.enqueue(textEncoder.encode(decrypted))\n\n        switch (workUnitStore?.type) {\n          case 'prerender':\n          case 'prerender-runtime':\n            // Explicitly don't close the stream here (until prerendering is\n            // complete) so that hanging promises are not rejected.\n            if (workUnitStore.renderSignal.aborted) {\n              controller.close()\n            } else {\n              workUnitStore.renderSignal.addEventListener(\n                'abort',\n                () => controller.close(),\n                { once: true }\n              )\n            }\n            break\n          case 'prerender-client':\n          case 'prerender-ppr':\n          case 'prerender-legacy':\n          case 'request':\n          case 'cache':\n          case 'private-cache':\n          case 'unstable-cache':\n          case undefined:\n            return controller.close()\n          default:\n            workUnitStore satisfies never\n        }\n      },\n    }),\n    {\n      findSourceMapURL,\n      serverConsumerManifest: {\n        // moduleLoading must be null because we don't want to trigger preloads of ClientReferences\n        // to be added to the current execution. Instead, we'll wait for any ClientReference\n        // to be emitted which themselves will handle the preloading.\n        moduleLoading: null,\n        moduleMap: isEdgeRuntime ? edgeRscModuleMapping : rscModuleMapping,\n        serverModuleMap: getServerModuleMap(),\n      },\n    }\n  )\n\n  return deserialized\n}\n","// This file is generated by next-core EcmascriptClientReferenceModule.\nimport { registerClientReference } from \"react-server-dom-turbopack/server\";\nexport default registerClientReference(\n    function() { throw new Error(\"Attempted to call the default export of [project]/src/components/routines/RoutinesManager.tsx from the server, but it's on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component.\"); },\n    \"[project]/src/components/routines/RoutinesManager.tsx\",\n    \"default\",\n);\n","import React from 'react';\r\nimport Header from '@/components/layout/Header';\r\nimport TaskManager from '@/components/board/TaskManager';\r\nimport { getCurrentUser } from '@/app/actions/user';\r\nimport { getPersonalTasks, createPersonalTask, updatePersonalTask, deletePersonalTask } from '@/app/actions/tasks';\r\nimport { getUserRoutines } from '@/app/actions/routines';\r\nimport { redirect } from 'next/navigation';\r\nimport RoutinesManager from '@/components/routines/RoutinesManager';\r\n\r\nexport default async function MyTasksPage() {\r\n    // 1. Obtener identidad actual\r\n    const currentUser = await getCurrentUser();\r\n\r\n    if (!currentUser) {\r\n        // Fallback en caso de que la BD o la creación del usuario Mock de error crítico\r\n        return <div style={{ padding: '2rem' }}>Error de Autenticación. Por favor revisa la base de datos.</div>;\r\n    }\r\n\r\n    // 2. Fetch de datos personales y alarmas\r\n    const personalTasks = await getPersonalTasks(currentUser.id);\r\n    const routinesRes = await getUserRoutines();\r\n\r\n    // Fallback empty array if routines fetch fails\r\n    const routines = routinesRes.success && routinesRes.data ? routinesRes.data : [];\r\n\r\n    // 3. Crear el array de `members` que el TaskManager necesita para el select de \"Responsable\"\r\n    // En la vista personal, solo tú existes en este contexto cerrado a menos que queramos invitar a otros\r\n    const singleMemberArray = [currentUser];\r\n\r\n    // 4. Wrappers de las server actions inyectando el userId\r\n    const handleCreateTask = async (title: string, priority: string) => {\r\n        'use server';\r\n        return await createPersonalTask(currentUser.id, { title, priority });\r\n    };\r\n\r\n    const handleUpdateTask = async (taskId: string, data: any) => {\r\n        'use server';\r\n        return await updatePersonalTask(taskId, data);\r\n    };\r\n\r\n    const handleDeleteTask = async (taskId: string) => {\r\n        'use server';\r\n        return await deletePersonalTask(taskId);\r\n    };\r\n\r\n    return (\r\n        <main style={{ display: 'flex', flexDirection: 'column', flex: 1, backgroundColor: 'var(--background)' }}>\r\n            <Header title=\"Mis Tareas\" />\r\n\r\n            <div style={{ padding: '2rem', flex: 1 }}>\r\n                <p style={{ color: 'var(--text-muted)', marginBottom: '1.5rem' }}>\r\n                    Bienvenido, <strong>{currentUser.name || currentUser.email}</strong>. Estas son tus responsabilidades globales, incluyendo tareas vinculadas a proyectos y tareas sueltas.\r\n                </p>\r\n                <RoutinesManager initialRoutines={routines as any} />\r\n\r\n                <TaskManager\r\n                    initialTasks={personalTasks}\r\n                    members={singleMemberArray}\r\n                    customCreateTask={handleCreateTask}\r\n                    customUpdateTask={handleUpdateTask}\r\n                    customDeleteTask={handleDeleteTask}\r\n                />\r\n            </div>\r\n        </main>\r\n    );\r\n}\r\n","'use server';\r\n\r\nimport { prisma } from '@/lib/prisma';\r\nimport { getCurrentUser } from '@/app/actions/user';\r\nimport { revalidatePath } from 'next/cache';\r\n\r\n/**\r\n * Creates a new persistent alarm (Routine) for the logged-in user.\r\n */\r\nexport async function createRoutine(title: string, intervalMinutes: number, startTime?: Date) {\r\n    try {\r\n        const user = await getCurrentUser();\r\n        if (!user) return { success: false, error: 'Unauthorized' };\r\n\r\n        // Default: Start nagging immediately if no start time is provided\r\n        const nextPingAt = startTime || new Date();\r\n\r\n        const routine = await prisma.routine.create({\r\n            data: {\r\n                title,\r\n                intervalMinutes,\r\n                nextPingAt,\r\n                userId: user.id\r\n            }\r\n        });\r\n\r\n        revalidatePath('/my-tasks');\r\n        return { success: true, data: routine };\r\n    } catch (error: any) {\r\n        console.error('Error in createRoutine:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\n/**\r\n * Fetches all active and completed routines for the logged-in user.\r\n */\r\nexport async function getUserRoutines() {\r\n    try {\r\n        const user = await getCurrentUser();\r\n        if (!user) return { success: false, error: 'Unauthorized' };\r\n\r\n        const routines = await prisma.routine.findMany({\r\n            where: {\r\n                userId: user.id\r\n            },\r\n            orderBy: [\r\n                { isCompleted: 'asc' }, // Pending first\r\n                { nextPingAt: 'asc' }   // Soonest first\r\n            ]\r\n        });\r\n\r\n        return { success: true, data: routines };\r\n    } catch (error: any) {\r\n        console.error('Error in getUserRoutines:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\n/**\r\n * Resolves a nagging task by providing mandatory evidence.\r\n */\r\nexport async function resolveRoutineWithEvidence(routineId: string, evidence: string) {\r\n    try {\r\n        const user = await getCurrentUser();\r\n        if (!user) return { success: false, error: 'Unauthorized' };\r\n\r\n        if (!evidence || evidence.trim() === '') {\r\n            return { success: false, error: 'Evidence is mandatory to resolve this routine.' };\r\n        }\r\n\r\n        const routine = await prisma.routine.findUnique({ where: { id: routineId } });\r\n        if (!routine) return { success: false, error: 'Routine not found' };\r\n\r\n        if (routine.userId !== user.id) return { success: false, error: 'Forbidden' };\r\n\r\n        const updated = await prisma.routine.update({\r\n            where: { id: routineId },\r\n            data: {\r\n                isCompleted: true,\r\n                evidence\r\n            }\r\n        });\r\n\r\n        revalidatePath('/my-tasks');\r\n        return { success: true, data: updated };\r\n    } catch (error: any) {\r\n        console.error('Error in resolveRoutine:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n\r\n/**\r\n * Deletes a routine permanently.\r\n */\r\nexport async function deleteRoutine(routineId: string) {\r\n    try {\r\n        const user = await getCurrentUser();\r\n        if (!user) return { success: false, error: 'Unauthorized' };\r\n\r\n        const routine = await prisma.routine.findUnique({ where: { id: routineId } });\r\n        if (!routine) return { success: false, error: 'Routine not found' };\r\n        if (routine.userId !== user.id) return { success: false, error: 'Forbidden' };\r\n\r\n        await prisma.routine.delete({ where: { id: routineId } });\r\n\r\n        revalidatePath('/my-tasks');\r\n        return { success: true };\r\n    } catch (error: any) {\r\n        console.error('Error in deleteRoutine:', error);\r\n        return { success: false, error: error.message };\r\n    }\r\n}\r\n"],"names":["getClientReferenceManifest","getServerActionsManifest","getServerModuleMap","selectWorkerForForwarding","setManifestsSingleton","MANIFESTS_SINGLETON","Symbol","for","globalThisWithManifests","globalThis","createProxiedClientReferenceManifest","clientReferenceManifestsPerRoute","createMappingProxy","prop","Proxy","get","_","id","workStore","workAsyncStorage","getStore","currentManifest","route","process","env","NODE_ENV","manifest","entry","undefined","values","mappingProxies","Map","InvariantError","proxy","set","String","createServerModuleMap","workers","NEXT_RUNTIME","workerEntry","normalizeWorkerPageName","page","Object","at","moduleId","async","name","chunks","pageName","pathHasPrefix","denormalizeWorkerPageName","bundlePath","normalizeAppPath","removePathPrefix","actionId","serverActionsManifest","keys","clientReferenceManifest","existingSingleton","proxiedClientReferenceManifest","serverModuleMap","getManifestsSingleton","manifestSingleton","arrayBufferToString","decrypt","encrypt","getActionEncryptionKey","stringToUint8Array","__next_loaded_action_key","buffer","bytes","Uint8Array","len","byteLength","fromCharCode","apply","binary","i","length","arr","charCodeAt","key","iv","data","crypto","subtle","rawKey","NEXT_SERVER_ACTIONS_ENCRYPTION_KEY","encryptionKey","importKey","atob","decryptActionBoundArgs","encryptActionBoundArgs","isEdgeRuntime","textEncoder","TextEncoder","textDecoder","TextDecoder","filterStackFrame","require","filterStackFrameDEV","findSourceMapURL","findSourceMapURLDEV","decodeActionBoundArg","arg","Error","originalPayload","ivValue","slice","payload","decrypted","decode","startsWith","encodeActionBoundArg","randomBytes","workUnitAsyncStorage","exit","getRandomValues","encrypted","encode","btoa","ReadStatus","React","cache","args","workUnitStore","cacheSignal","getCacheSignal","clientModules","error","captureStackTrace","didCatchError","hangingInputAbortSignal","createHangingInputAbortSignal","readStatus","startReadOnce","beginRead","endReadIfStarted","endRead","addEventListener","once","serialized","streamToString","renderToReadableStream","signal","onError","err","aborted","message","console","prerenderResumeDataCache","getPrerenderResumeDataCache","renderResumeDataCache","getRenderResumeDataCache","cacheKey","cachedEncrypted","encryptedBoundArgs","encryptedPromise","decryptedBoundArgs","edgeRscModuleMapping","rscModuleMapping","deserialized","createFromReadableStream","ReadableStream","start","controller","enqueue","type","renderSignal","close","serverConsumerManifest","moduleLoading","moduleMap"],"mappings":"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","ignoreList":[0,1,2,3]}