"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/http_ece";
exports.ids = ["vendor-chunks/http_ece"];
exports.modules = {

/***/ "(action-browser)/./node_modules/http_ece/ece.js":
/*!**************************************!*\
  !*** ./node_modules/http_ece/ece.js ***!
  \**************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n/*\n * Encrypted content coding\n *\n * === Note about versions ===\n *\n * This code supports multiple versions of the draft.  This is selected using\n * the |version| parameter.\n *\n * aes128gcm: The most recent version, the salt, record size and key identifier\n *    are included in a header that is part of the encrypted content coding.\n *\n * aesgcm: The version that is widely deployed with WebPush (as of 2016-11).\n *    This version is selected by default, unless you specify a |padSize| of 1.\n */\n\nvar crypto = __webpack_require__(/*! crypto */ \"crypto\");\n\nvar AES_GCM = 'aes-128-gcm';\nvar PAD_SIZE = { 'aes128gcm': 1, 'aesgcm': 2 };\nvar TAG_LENGTH = 16;\nvar KEY_LENGTH = 16;\nvar NONCE_LENGTH = 12;\nvar SHA_256_LENGTH = 32;\nvar MODE_ENCRYPT = 'encrypt';\nvar MODE_DECRYPT = 'decrypt';\n\nvar keylog;\nif (process.env.ECE_KEYLOG === '1') {\n  keylog = function(m, k) {\n    console.warn(m + ' [' + k.length + ']: ' + k.toString('base64url'));\n    return k;\n  };\n} else {\n  keylog = function(m, k) { return k; };\n}\n\n/* Optionally base64 decode something. */\nfunction decode(b) {\n  if (typeof b === 'string') {\n    return Buffer.from(b, 'base64url');\n  }\n  return b;\n}\n\nfunction HMAC_hash(key, input) {\n  var hmac = crypto.createHmac('sha256', key);\n  hmac.update(input);\n  return hmac.digest();\n}\n\n/* HKDF as defined in RFC5869, using SHA-256 */\nfunction HKDF_extract(salt, ikm) {\n  keylog('salt', salt);\n  keylog('ikm', ikm);\n  return keylog('extract', HMAC_hash(salt, ikm));\n}\n\nfunction HKDF_expand(prk, info, l) {\n  keylog('prk', prk);\n  keylog('info', info);\n  var output = Buffer.alloc(0);\n  var T = Buffer.alloc(0);\n  info = Buffer.from(info, 'ascii');\n  var counter = 0;\n  var cbuf = Buffer.alloc(1);\n  while (output.length < l) {\n    cbuf.writeUIntBE(++counter, 0, 1);\n    T = HMAC_hash(prk, Buffer.concat([T, info, cbuf]));\n    output = Buffer.concat([output, T]);\n  }\n\n  return keylog('expand', output.slice(0, l));\n}\n\nfunction HKDF(salt, ikm, info, len) {\n  return HKDF_expand(HKDF_extract(salt, ikm), info, len);\n}\n\nfunction info(base, context) {\n  var result = Buffer.concat([\n    Buffer.from('Content-Encoding: ' + base + '\\0', 'ascii'),\n    context\n  ]);\n  keylog('info ' + base, result);\n  return result;\n}\n\nfunction lengthPrefix(buffer) {\n  var b = Buffer.concat([Buffer.alloc(2), buffer]);\n  b.writeUIntBE(buffer.length, 0, 2);\n  return b;\n}\n\nfunction extractDH(header, mode) {\n  var key = header.privateKey;\n  var senderPubKey, receiverPubKey;\n  if (mode === MODE_ENCRYPT) {\n    senderPubKey = key.getPublicKey();\n    receiverPubKey = header.dh;\n  } else if (mode === MODE_DECRYPT) {\n    senderPubKey = header.dh;\n    receiverPubKey = key.getPublicKey();\n  } else {\n    throw new Error('Unknown mode only ' + MODE_ENCRYPT +\n                    ' and ' + MODE_DECRYPT + ' supported');\n  }\n  return {\n    secret: key.computeSecret(header.dh),\n    context: Buffer.concat([\n      Buffer.from(header.keylabel, 'ascii'),\n      Buffer.from([0]),\n      lengthPrefix(receiverPubKey), // user agent\n      lengthPrefix(senderPubKey)    // application server\n    ])\n  };\n}\n\nfunction extractSecretAndContext(header, mode) {\n  var result = { secret: null, context: Buffer.alloc(0) };\n  if (header.key) {\n    result.secret = header.key;\n    if (result.secret.length !== KEY_LENGTH) {\n      throw new Error('An explicit key must be ' + KEY_LENGTH + ' bytes');\n    }\n  } else if (header.dh) { // receiver/decrypt\n    result = extractDH(header, mode);\n  } else if (typeof header.keyid !== undefined) {\n    result.secret = header.keymap[header.keyid];\n  }\n  if (!result.secret) {\n    throw new Error('Unable to determine key');\n  }\n  keylog('secret', result.secret);\n  keylog('context', result.context);\n  if (header.authSecret) {\n    result.secret = HKDF(header.authSecret, result.secret,\n                         info('auth', Buffer.alloc(0)), SHA_256_LENGTH);\n    keylog('authsecret', result.secret);\n  }\n  return result;\n}\n\nfunction webpushSecret(header, mode) {\n  if (!header.authSecret) {\n    throw new Error('No authentication secret for webpush');\n  }\n  keylog('authsecret', header.authSecret);\n\n  var remotePubKey, senderPubKey, receiverPubKey;\n  if (mode === MODE_ENCRYPT) {\n    senderPubKey = header.privateKey.getPublicKey();\n    remotePubKey = receiverPubKey = header.dh;\n  } else if (mode === MODE_DECRYPT) {\n    remotePubKey = senderPubKey = header.keyid;\n    receiverPubKey = header.privateKey.getPublicKey();\n  } else {\n    throw new Error('Unknown mode only ' + MODE_ENCRYPT +\n                    ' and ' + MODE_DECRYPT + ' supported');\n  }\n  keylog('remote pubkey', remotePubKey);\n  keylog('sender pubkey', senderPubKey);\n  keylog('receiver pubkey', receiverPubKey);\n  return keylog('secret dh',\n                HKDF(header.authSecret,\n                     header.privateKey.computeSecret(remotePubKey),\n                     Buffer.concat([\n                       Buffer.from('WebPush: info\\0'),\n                       receiverPubKey,\n                       senderPubKey\n                     ]),\n                     SHA_256_LENGTH));\n}\n\nfunction extractSecret(header, mode, keyLookupCallback) {\n  if (keyLookupCallback) {\n    if (!isFunction(keyLookupCallback)) {\n      throw new Error('Callback is not a function')\n    }\n  }\n\n  if (header.key) {\n    if (header.key.length !== KEY_LENGTH) {\n      throw new Error('An explicit key must be ' + KEY_LENGTH + ' bytes');\n    }\n    return keylog('secret key', header.key);\n  }\n\n  if (!header.privateKey) {\n    // Lookup based on keyid\n    if (!keyLookupCallback) {\n      var key = header.keymap && header.keymap[header.keyid];\n    } else {\n      var key = keyLookupCallback(header.keyid)\n    }\n    if (!key) {\n      throw new Error('No saved key (keyid: \"' + header.keyid + '\")');\n    }\n    return key;\n  }\n\n  return webpushSecret(header, mode);\n}\n\nfunction deriveKeyAndNonce(header, mode, lookupKeyCallback) {\n  if (!header.salt) {\n    throw new Error('must include a salt parameter for ' + header.version);\n  }\n  var keyInfo;\n  var nonceInfo;\n  var secret;\n  if (header.version === 'aesgcm') {\n    // old\n    var s = extractSecretAndContext(header, mode, lookupKeyCallback);\n    keyInfo = info('aesgcm', s.context);\n    nonceInfo = info('nonce', s.context);\n    secret = s.secret;\n  } else if (header.version === 'aes128gcm') {\n    // latest\n    keyInfo = Buffer.from('Content-Encoding: aes128gcm\\0');\n    nonceInfo = Buffer.from('Content-Encoding: nonce\\0');\n    secret = extractSecret(header, mode, lookupKeyCallback);\n  } else {\n    throw new Error('Unable to set context for mode ' + header.version);\n  }\n  var prk = HKDF_extract(header.salt, secret);\n  var result = {\n    key: HKDF_expand(prk, keyInfo, KEY_LENGTH),\n    nonce: HKDF_expand(prk, nonceInfo, NONCE_LENGTH)\n  };\n  keylog('key', result.key);\n  keylog('nonce base', result.nonce);\n  return result;\n}\n\n/* Parse command-line arguments. */\nfunction parseParams(params) {\n  var header = {};\n\n  header.version = params.version || 'aes128gcm';\n  header.rs = parseInt(params.rs, 10);\n  if (isNaN(header.rs)) {\n    header.rs = 4096;\n  }\n  var overhead = PAD_SIZE[header.version];\n  if (header.version === 'aes128gcm') {\n    overhead += TAG_LENGTH;\n  }\n  if (header.rs <= overhead) {\n    throw new Error('The rs parameter has to be greater than ' + overhead);\n  }\n\n  if (params.salt) {\n    header.salt = decode(params.salt);\n    if (header.salt.length !== KEY_LENGTH) {\n      throw new Error('The salt parameter must be ' + KEY_LENGTH + ' bytes');\n    }\n  }\n  header.keyid = params.keyid;\n  if (params.key) {\n    header.key = decode(params.key);\n  } else {\n    header.privateKey = params.privateKey;\n    if (!header.privateKey) {\n      header.keymap = params.keymap;\n    }\n    if (header.version !== 'aes128gcm') {\n      header.keylabel = params.keylabel || 'P-256';\n    }\n    if (params.dh) {\n      header.dh = decode(params.dh);\n    }\n  }\n  if (params.authSecret) {\n    header.authSecret = decode(params.authSecret);\n  }\n  return header;\n}\n\nfunction generateNonce(base, counter) {\n  var nonce = Buffer.from(base);\n  var m = nonce.readUIntBE(nonce.length - 6, 6);\n  var x = ((m ^ counter) & 0xffffff) +\n      ((((m / 0x1000000) ^ (counter / 0x1000000)) & 0xffffff) * 0x1000000);\n  nonce.writeUIntBE(x, nonce.length - 6, 6);\n  keylog('nonce' + counter, nonce);\n  return nonce;\n}\n\n/* Used when decrypting aes128gcm to populate the header values. Modifies the\n * header values in place and returns the size of the header. */\nfunction readHeader(buffer, header) {\n  var idsz = buffer.readUIntBE(20, 1);\n  header.salt = buffer.slice(0, KEY_LENGTH);\n  header.rs = buffer.readUIntBE(KEY_LENGTH, 4);\n  header.keyid = buffer.slice(21, 21 + idsz);\n  return 21 + idsz;\n}\n\nfunction unpadLegacy(data, version) {\n  var padSize = PAD_SIZE[version];\n  var pad = data.readUIntBE(0, padSize);\n  if (pad + padSize > data.length) {\n    throw new Error('padding exceeds block size');\n  }\n  keylog('padding', data.slice(0, padSize + pad));\n  var padCheck = Buffer.alloc(pad);\n  padCheck.fill(0);\n  if (padCheck.compare(data.slice(padSize, padSize + pad)) !== 0) {\n    throw new Error('invalid padding');\n  }\n  return data.slice(padSize + pad);\n}\n\nfunction unpad(data, last) {\n  var i = data.length - 1;\n  while(i >= 0) {\n    if (data[i]) {\n      if (last) {\n        if (data[i] !== 2) {\n          throw new Error('last record needs to start padding with a 2');\n        }\n      } else {\n        if (data[i] !== 1) {\n          throw new Error('last record needs to start padding with a 2');\n        }\n      }\n      return data.slice(0, i);\n    }\n    --i;\n  }\n  throw new Error('all zero plaintext');\n}\n\nfunction decryptRecord(key, counter, buffer, header, last) {\n  keylog('decrypt', buffer);\n  var nonce = generateNonce(key.nonce, counter);\n  var gcm = crypto.createDecipheriv(AES_GCM, key.key, nonce);\n  gcm.setAuthTag(buffer.slice(buffer.length - TAG_LENGTH));\n  var data = gcm.update(buffer.slice(0, buffer.length - TAG_LENGTH));\n  data = Buffer.concat([data, gcm.final()]);\n  keylog('decrypted', data);\n  if (header.version !== 'aes128gcm') {\n    return unpadLegacy(data, header.version);\n  }\n  return unpad(data, last);\n}\n\n/**\n * Decrypt some bytes.  This uses the parameters to determine the key and block\n * size, which are described in the draft.  Binary values are base64url encoded.\n *\n * |params.version| contains the version of encoding to use: aes128gcm is the latest,\n * but aesgcm is also accepted (though the latter might\n * disappear in a future release).  If omitted, assume aes128gcm.\n *\n * If |params.key| is specified, that value is used as the key.\n *\n * If the version is aes128gcm, the keyid is extracted from the header and used\n * as the ECDH public key of the sender.  For version aesgcm ,\n * |params.dh| needs to be provided with the public key of the sender.\n *\n * The |params.privateKey| includes the private key of the receiver.\n */\nfunction decrypt(buffer, params, keyLookupCallback) {\n  var header = parseParams(params);\n  if (header.version === 'aes128gcm') {\n    var headerLength = readHeader(buffer, header);\n    buffer = buffer.slice(headerLength);\n  }\n  var key = deriveKeyAndNonce(header, MODE_DECRYPT, keyLookupCallback);\n  var start = 0;\n  var result = Buffer.alloc(0);\n\n  var chunkSize = header.rs;\n  if (header.version !== 'aes128gcm') {\n    chunkSize += TAG_LENGTH;\n  }\n\n  for (var i = 0; start < buffer.length; ++i) {\n    var end = start + chunkSize;\n    if (header.version !== 'aes128gcm' && end === buffer.length) {\n      throw new Error('Truncated payload');\n    }\n    end = Math.min(end, buffer.length);\n    if (end - start <= TAG_LENGTH) {\n      throw new Error('Invalid block: too small at ' + i);\n    }\n    var block = decryptRecord(key, i, buffer.slice(start, end),\n                              header, end >= buffer.length);\n    result = Buffer.concat([result, block]);\n    start = end;\n  }\n  return result;\n}\n\nfunction encryptRecord(key, counter, buffer, pad, header, last) {\n  keylog('encrypt', buffer);\n  pad = pad || 0;\n  var nonce = generateNonce(key.nonce, counter);\n  var gcm = crypto.createCipheriv(AES_GCM, key.key, nonce);\n\n  var ciphertext = [];\n  var padSize = PAD_SIZE[header.version];\n  var padding = Buffer.alloc(pad + padSize);\n  padding.fill(0);\n\n  if (header.version !== 'aes128gcm') {\n    padding.writeUIntBE(pad, 0, padSize);\n    keylog('padding', padding);\n    ciphertext.push(gcm.update(padding));\n    ciphertext.push(gcm.update(buffer));\n\n    if (!last && padding.length + buffer.length < header.rs) {\n      throw new Error('Unable to pad to record size');\n    }\n  } else {\n    ciphertext.push(gcm.update(buffer));\n    padding.writeUIntBE(last ? 2 : 1, 0, 1);\n    keylog('padding', padding);\n    ciphertext.push(gcm.update(padding));\n  }\n\n  gcm.final();\n  var tag = gcm.getAuthTag();\n  if (tag.length !== TAG_LENGTH) {\n    throw new Error('invalid tag generated');\n  }\n  ciphertext.push(tag);\n  return keylog('encrypted', Buffer.concat(ciphertext));\n}\n\nfunction writeHeader(header) {\n  var ints = Buffer.alloc(5);\n  var keyid = Buffer.from(header.keyid || []);\n  if (keyid.length > 255) {\n    throw new Error('keyid is too large');\n  }\n  ints.writeUIntBE(header.rs, 0, 4);\n  ints.writeUIntBE(keyid.length, 4, 1);\n  return Buffer.concat([header.salt, ints, keyid]);\n}\n\n/**\n * Encrypt some bytes.  This uses the parameters to determine the key and block\n * size, which are described in the draft.\n *\n * |params.version| contains the version of encoding to use: aes128gcm is the latest,\n * but aesgcm is also accepted (though the latter two might\n * disappear in a future release).  If omitted, assume aes128gcm.\n *\n * If |params.key| is specified, that value is used as the key.\n *\n * For Diffie-Hellman (WebPush), |params.dh| includes the public key of the\n * receiver.  |params.privateKey| is used to establish a shared secret.  Key\n * pairs can be created using |crypto.createECDH()|.\n */\nfunction encrypt(buffer, params, keyLookupCallback) {  \n  if (!Buffer.isBuffer(buffer)) {\n    throw new Error('buffer argument must be a Buffer');\n  }\n  var header = parseParams(params);\n  if (!header.salt) {\n    header.salt = crypto.randomBytes(KEY_LENGTH);\n  }\n\n  var result;\n  if (header.version === 'aes128gcm') {\n    // Save the DH public key in the header unless keyid is set.\n    if (header.privateKey && !header.keyid) {\n      header.keyid = header.privateKey.getPublicKey();\n    }\n    result = writeHeader(header);\n  } else {\n    // No header on other versions\n    result = Buffer.alloc(0);\n  }\n\n  var key = deriveKeyAndNonce(header, MODE_ENCRYPT, keyLookupCallback);\n  var start = 0;\n  var padSize = PAD_SIZE[header.version];\n  var overhead = padSize;\n  if (header.version === 'aes128gcm') {\n    overhead += TAG_LENGTH;\n  }\n  var pad = isNaN(parseInt(params.pad, 10)) ? 0 : parseInt(params.pad, 10);\n\n  var counter = 0;\n  var last = false;\n  while (!last) {\n    // Pad so that at least one data byte is in a block.\n    var recordPad = Math.min(header.rs - overhead - 1, pad);\n    if (header.version !== 'aes128gcm') {\n      recordPad = Math.min((1 << (padSize * 8)) - 1, recordPad);\n    }\n    if (pad > 0 && recordPad === 0) {\n      ++recordPad; // Deal with perverse case of rs=overhead+1 with padding.\n    }\n    pad -= recordPad;\n\n    var end = start + header.rs - overhead - recordPad;\n    if (header.version !== 'aes128gcm') {\n      // The > here ensures that we write out a padding-only block at the end\n      // of a buffer.\n      last = end > buffer.length;\n    } else {\n      last = end >= buffer.length;\n    }\n    last = last && pad <= 0;\n    var block = encryptRecord(key, counter, buffer.slice(start, end),\n                              recordPad, header, last);\n    result = Buffer.concat([result, block]);\n\n    start = end;\n    ++counter;\n  }\n  return result;\n}\n\n\nfunction isFunction(object) {\n  return typeof(object) === 'function';\n }\n\nmodule.exports = {\n  decrypt: decrypt,\n  encrypt: encrypt\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9odHRwX2VjZS9lY2UuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGFBQWEsbUJBQU8sQ0FBQyxzQkFBUTs7QUFFN0I7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRiw0QkFBNEI7QUFDNUI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLHNCQUFzQjtBQUMxQjtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxrQkFBa0IsdUJBQXVCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIkQ6XFxhcGxpY2FjaW9uZXMtaWFcXG5leHQtdGFza1xcbm9kZV9tb2R1bGVzXFxodHRwX2VjZVxcZWNlLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0Jztcbi8qXG4gKiBFbmNyeXB0ZWQgY29udGVudCBjb2RpbmdcbiAqXG4gKiA9PT0gTm90ZSBhYm91dCB2ZXJzaW9ucyA9PT1cbiAqXG4gKiBUaGlzIGNvZGUgc3VwcG9ydHMgbXVsdGlwbGUgdmVyc2lvbnMgb2YgdGhlIGRyYWZ0LiAgVGhpcyBpcyBzZWxlY3RlZCB1c2luZ1xuICogdGhlIHx2ZXJzaW9ufCBwYXJhbWV0ZXIuXG4gKlxuICogYWVzMTI4Z2NtOiBUaGUgbW9zdCByZWNlbnQgdmVyc2lvbiwgdGhlIHNhbHQsIHJlY29yZCBzaXplIGFuZCBrZXkgaWRlbnRpZmllclxuICogICAgYXJlIGluY2x1ZGVkIGluIGEgaGVhZGVyIHRoYXQgaXMgcGFydCBvZiB0aGUgZW5jcnlwdGVkIGNvbnRlbnQgY29kaW5nLlxuICpcbiAqIGFlc2djbTogVGhlIHZlcnNpb24gdGhhdCBpcyB3aWRlbHkgZGVwbG95ZWQgd2l0aCBXZWJQdXNoIChhcyBvZiAyMDE2LTExKS5cbiAqICAgIFRoaXMgdmVyc2lvbiBpcyBzZWxlY3RlZCBieSBkZWZhdWx0LCB1bmxlc3MgeW91IHNwZWNpZnkgYSB8cGFkU2l6ZXwgb2YgMS5cbiAqL1xuXG52YXIgY3J5cHRvID0gcmVxdWlyZSgnY3J5cHRvJyk7XG5cbnZhciBBRVNfR0NNID0gJ2Flcy0xMjgtZ2NtJztcbnZhciBQQURfU0laRSA9IHsgJ2FlczEyOGdjbSc6IDEsICdhZXNnY20nOiAyIH07XG52YXIgVEFHX0xFTkdUSCA9IDE2O1xudmFyIEtFWV9MRU5HVEggPSAxNjtcbnZhciBOT05DRV9MRU5HVEggPSAxMjtcbnZhciBTSEFfMjU2X0xFTkdUSCA9IDMyO1xudmFyIE1PREVfRU5DUllQVCA9ICdlbmNyeXB0JztcbnZhciBNT0RFX0RFQ1JZUFQgPSAnZGVjcnlwdCc7XG5cbnZhciBrZXlsb2c7XG5pZiAocHJvY2Vzcy5lbnYuRUNFX0tFWUxPRyA9PT0gJzEnKSB7XG4gIGtleWxvZyA9IGZ1bmN0aW9uKG0sIGspIHtcbiAgICBjb25zb2xlLndhcm4obSArICcgWycgKyBrLmxlbmd0aCArICddOiAnICsgay50b1N0cmluZygnYmFzZTY0dXJsJykpO1xuICAgIHJldHVybiBrO1xuICB9O1xufSBlbHNlIHtcbiAga2V5bG9nID0gZnVuY3Rpb24obSwgaykgeyByZXR1cm4gazsgfTtcbn1cblxuLyogT3B0aW9uYWxseSBiYXNlNjQgZGVjb2RlIHNvbWV0aGluZy4gKi9cbmZ1bmN0aW9uIGRlY29kZShiKSB7XG4gIGlmICh0eXBlb2YgYiA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gQnVmZmVyLmZyb20oYiwgJ2Jhc2U2NHVybCcpO1xuICB9XG4gIHJldHVybiBiO1xufVxuXG5mdW5jdGlvbiBITUFDX2hhc2goa2V5LCBpbnB1dCkge1xuICB2YXIgaG1hYyA9IGNyeXB0by5jcmVhdGVIbWFjKCdzaGEyNTYnLCBrZXkpO1xuICBobWFjLnVwZGF0ZShpbnB1dCk7XG4gIHJldHVybiBobWFjLmRpZ2VzdCgpO1xufVxuXG4vKiBIS0RGIGFzIGRlZmluZWQgaW4gUkZDNTg2OSwgdXNpbmcgU0hBLTI1NiAqL1xuZnVuY3Rpb24gSEtERl9leHRyYWN0KHNhbHQsIGlrbSkge1xuICBrZXlsb2coJ3NhbHQnLCBzYWx0KTtcbiAga2V5bG9nKCdpa20nLCBpa20pO1xuICByZXR1cm4ga2V5bG9nKCdleHRyYWN0JywgSE1BQ19oYXNoKHNhbHQsIGlrbSkpO1xufVxuXG5mdW5jdGlvbiBIS0RGX2V4cGFuZChwcmssIGluZm8sIGwpIHtcbiAga2V5bG9nKCdwcmsnLCBwcmspO1xuICBrZXlsb2coJ2luZm8nLCBpbmZvKTtcbiAgdmFyIG91dHB1dCA9IEJ1ZmZlci5hbGxvYygwKTtcbiAgdmFyIFQgPSBCdWZmZXIuYWxsb2MoMCk7XG4gIGluZm8gPSBCdWZmZXIuZnJvbShpbmZvLCAnYXNjaWknKTtcbiAgdmFyIGNvdW50ZXIgPSAwO1xuICB2YXIgY2J1ZiA9IEJ1ZmZlci5hbGxvYygxKTtcbiAgd2hpbGUgKG91dHB1dC5sZW5ndGggPCBsKSB7XG4gICAgY2J1Zi53cml0ZVVJbnRCRSgrK2NvdW50ZXIsIDAsIDEpO1xuICAgIFQgPSBITUFDX2hhc2gocHJrLCBCdWZmZXIuY29uY2F0KFtULCBpbmZvLCBjYnVmXSkpO1xuICAgIG91dHB1dCA9IEJ1ZmZlci5jb25jYXQoW291dHB1dCwgVF0pO1xuICB9XG5cbiAgcmV0dXJuIGtleWxvZygnZXhwYW5kJywgb3V0cHV0LnNsaWNlKDAsIGwpKTtcbn1cblxuZnVuY3Rpb24gSEtERihzYWx0LCBpa20sIGluZm8sIGxlbikge1xuICByZXR1cm4gSEtERl9leHBhbmQoSEtERl9leHRyYWN0KHNhbHQsIGlrbSksIGluZm8sIGxlbik7XG59XG5cbmZ1bmN0aW9uIGluZm8oYmFzZSwgY29udGV4dCkge1xuICB2YXIgcmVzdWx0ID0gQnVmZmVyLmNvbmNhdChbXG4gICAgQnVmZmVyLmZyb20oJ0NvbnRlbnQtRW5jb2Rpbmc6ICcgKyBiYXNlICsgJ1xcMCcsICdhc2NpaScpLFxuICAgIGNvbnRleHRcbiAgXSk7XG4gIGtleWxvZygnaW5mbyAnICsgYmFzZSwgcmVzdWx0KTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZnVuY3Rpb24gbGVuZ3RoUHJlZml4KGJ1ZmZlcikge1xuICB2YXIgYiA9IEJ1ZmZlci5jb25jYXQoW0J1ZmZlci5hbGxvYygyKSwgYnVmZmVyXSk7XG4gIGIud3JpdGVVSW50QkUoYnVmZmVyLmxlbmd0aCwgMCwgMik7XG4gIHJldHVybiBiO1xufVxuXG5mdW5jdGlvbiBleHRyYWN0REgoaGVhZGVyLCBtb2RlKSB7XG4gIHZhciBrZXkgPSBoZWFkZXIucHJpdmF0ZUtleTtcbiAgdmFyIHNlbmRlclB1YktleSwgcmVjZWl2ZXJQdWJLZXk7XG4gIGlmIChtb2RlID09PSBNT0RFX0VOQ1JZUFQpIHtcbiAgICBzZW5kZXJQdWJLZXkgPSBrZXkuZ2V0UHVibGljS2V5KCk7XG4gICAgcmVjZWl2ZXJQdWJLZXkgPSBoZWFkZXIuZGg7XG4gIH0gZWxzZSBpZiAobW9kZSA9PT0gTU9ERV9ERUNSWVBUKSB7XG4gICAgc2VuZGVyUHViS2V5ID0gaGVhZGVyLmRoO1xuICAgIHJlY2VpdmVyUHViS2V5ID0ga2V5LmdldFB1YmxpY0tleSgpO1xuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBFcnJvcignVW5rbm93biBtb2RlIG9ubHkgJyArIE1PREVfRU5DUllQVCArXG4gICAgICAgICAgICAgICAgICAgICcgYW5kICcgKyBNT0RFX0RFQ1JZUFQgKyAnIHN1cHBvcnRlZCcpO1xuICB9XG4gIHJldHVybiB7XG4gICAgc2VjcmV0OiBrZXkuY29tcHV0ZVNlY3JldChoZWFkZXIuZGgpLFxuICAgIGNvbnRleHQ6IEJ1ZmZlci5jb25jYXQoW1xuICAgICAgQnVmZmVyLmZyb20oaGVhZGVyLmtleWxhYmVsLCAnYXNjaWknKSxcbiAgICAgIEJ1ZmZlci5mcm9tKFswXSksXG4gICAgICBsZW5ndGhQcmVmaXgocmVjZWl2ZXJQdWJLZXkpLCAvLyB1c2VyIGFnZW50XG4gICAgICBsZW5ndGhQcmVmaXgoc2VuZGVyUHViS2V5KSAgICAvLyBhcHBsaWNhdGlvbiBzZXJ2ZXJcbiAgICBdKVxuICB9O1xufVxuXG5mdW5jdGlvbiBleHRyYWN0U2VjcmV0QW5kQ29udGV4dChoZWFkZXIsIG1vZGUpIHtcbiAgdmFyIHJlc3VsdCA9IHsgc2VjcmV0OiBudWxsLCBjb250ZXh0OiBCdWZmZXIuYWxsb2MoMCkgfTtcbiAgaWYgKGhlYWRlci5rZXkpIHtcbiAgICByZXN1bHQuc2VjcmV0ID0gaGVhZGVyLmtleTtcbiAgICBpZiAocmVzdWx0LnNlY3JldC5sZW5ndGggIT09IEtFWV9MRU5HVEgpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignQW4gZXhwbGljaXQga2V5IG11c3QgYmUgJyArIEtFWV9MRU5HVEggKyAnIGJ5dGVzJyk7XG4gICAgfVxuICB9IGVsc2UgaWYgKGhlYWRlci5kaCkgeyAvLyByZWNlaXZlci9kZWNyeXB0XG4gICAgcmVzdWx0ID0gZXh0cmFjdERIKGhlYWRlciwgbW9kZSk7XG4gIH0gZWxzZSBpZiAodHlwZW9mIGhlYWRlci5rZXlpZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgcmVzdWx0LnNlY3JldCA9IGhlYWRlci5rZXltYXBbaGVhZGVyLmtleWlkXTtcbiAgfVxuICBpZiAoIXJlc3VsdC5zZWNyZXQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1VuYWJsZSB0byBkZXRlcm1pbmUga2V5Jyk7XG4gIH1cbiAga2V5bG9nKCdzZWNyZXQnLCByZXN1bHQuc2VjcmV0KTtcbiAga2V5bG9nKCdjb250ZXh0JywgcmVzdWx0LmNvbnRleHQpO1xuICBpZiAoaGVhZGVyLmF1dGhTZWNyZXQpIHtcbiAgICByZXN1bHQuc2VjcmV0ID0gSEtERihoZWFkZXIuYXV0aFNlY3JldCwgcmVzdWx0LnNlY3JldCxcbiAgICAgICAgICAgICAgICAgICAgICAgICBpbmZvKCdhdXRoJywgQnVmZmVyLmFsbG9jKDApKSwgU0hBXzI1Nl9MRU5HVEgpO1xuICAgIGtleWxvZygnYXV0aHNlY3JldCcsIHJlc3VsdC5zZWNyZXQpO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbmZ1bmN0aW9uIHdlYnB1c2hTZWNyZXQoaGVhZGVyLCBtb2RlKSB7XG4gIGlmICghaGVhZGVyLmF1dGhTZWNyZXQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ05vIGF1dGhlbnRpY2F0aW9uIHNlY3JldCBmb3Igd2VicHVzaCcpO1xuICB9XG4gIGtleWxvZygnYXV0aHNlY3JldCcsIGhlYWRlci5hdXRoU2VjcmV0KTtcblxuICB2YXIgcmVtb3RlUHViS2V5LCBzZW5kZXJQdWJLZXksIHJlY2VpdmVyUHViS2V5O1xuICBpZiAobW9kZSA9PT0gTU9ERV9FTkNSWVBUKSB7XG4gICAgc2VuZGVyUHViS2V5ID0gaGVhZGVyLnByaXZhdGVLZXkuZ2V0UHVibGljS2V5KCk7XG4gICAgcmVtb3RlUHViS2V5ID0gcmVjZWl2ZXJQdWJLZXkgPSBoZWFkZXIuZGg7XG4gIH0gZWxzZSBpZiAobW9kZSA9PT0gTU9ERV9ERUNSWVBUKSB7XG4gICAgcmVtb3RlUHViS2V5ID0gc2VuZGVyUHViS2V5ID0gaGVhZGVyLmtleWlkO1xuICAgIHJlY2VpdmVyUHViS2V5ID0gaGVhZGVyLnByaXZhdGVLZXkuZ2V0UHVibGljS2V5KCk7XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdVbmtub3duIG1vZGUgb25seSAnICsgTU9ERV9FTkNSWVBUICtcbiAgICAgICAgICAgICAgICAgICAgJyBhbmQgJyArIE1PREVfREVDUllQVCArICcgc3VwcG9ydGVkJyk7XG4gIH1cbiAga2V5bG9nKCdyZW1vdGUgcHVia2V5JywgcmVtb3RlUHViS2V5KTtcbiAga2V5bG9nKCdzZW5kZXIgcHVia2V5Jywgc2VuZGVyUHViS2V5KTtcbiAga2V5bG9nKCdyZWNlaXZlciBwdWJrZXknLCByZWNlaXZlclB1YktleSk7XG4gIHJldHVybiBrZXlsb2coJ3NlY3JldCBkaCcsXG4gICAgICAgICAgICAgICAgSEtERihoZWFkZXIuYXV0aFNlY3JldCxcbiAgICAgICAgICAgICAgICAgICAgIGhlYWRlci5wcml2YXRlS2V5LmNvbXB1dGVTZWNyZXQocmVtb3RlUHViS2V5KSxcbiAgICAgICAgICAgICAgICAgICAgIEJ1ZmZlci5jb25jYXQoW1xuICAgICAgICAgICAgICAgICAgICAgICBCdWZmZXIuZnJvbSgnV2ViUHVzaDogaW5mb1xcMCcpLFxuICAgICAgICAgICAgICAgICAgICAgICByZWNlaXZlclB1YktleSxcbiAgICAgICAgICAgICAgICAgICAgICAgc2VuZGVyUHViS2V5XG4gICAgICAgICAgICAgICAgICAgICBdKSxcbiAgICAgICAgICAgICAgICAgICAgIFNIQV8yNTZfTEVOR1RIKSk7XG59XG5cbmZ1bmN0aW9uIGV4dHJhY3RTZWNyZXQoaGVhZGVyLCBtb2RlLCBrZXlMb29rdXBDYWxsYmFjaykge1xuICBpZiAoa2V5TG9va3VwQ2FsbGJhY2spIHtcbiAgICBpZiAoIWlzRnVuY3Rpb24oa2V5TG9va3VwQ2FsbGJhY2spKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NhbGxiYWNrIGlzIG5vdCBhIGZ1bmN0aW9uJylcbiAgICB9XG4gIH1cblxuICBpZiAoaGVhZGVyLmtleSkge1xuICAgIGlmIChoZWFkZXIua2V5Lmxlbmd0aCAhPT0gS0VZX0xFTkdUSCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdBbiBleHBsaWNpdCBrZXkgbXVzdCBiZSAnICsgS0VZX0xFTkdUSCArICcgYnl0ZXMnKTtcbiAgICB9XG4gICAgcmV0dXJuIGtleWxvZygnc2VjcmV0IGtleScsIGhlYWRlci5rZXkpO1xuICB9XG5cbiAgaWYgKCFoZWFkZXIucHJpdmF0ZUtleSkge1xuICAgIC8vIExvb2t1cCBiYXNlZCBvbiBrZXlpZFxuICAgIGlmICgha2V5TG9va3VwQ2FsbGJhY2spIHtcbiAgICAgIHZhciBrZXkgPSBoZWFkZXIua2V5bWFwICYmIGhlYWRlci5rZXltYXBbaGVhZGVyLmtleWlkXTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGtleSA9IGtleUxvb2t1cENhbGxiYWNrKGhlYWRlci5rZXlpZClcbiAgICB9XG4gICAgaWYgKCFrZXkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignTm8gc2F2ZWQga2V5IChrZXlpZDogXCInICsgaGVhZGVyLmtleWlkICsgJ1wiKScpO1xuICAgIH1cbiAgICByZXR1cm4ga2V5O1xuICB9XG5cbiAgcmV0dXJuIHdlYnB1c2hTZWNyZXQoaGVhZGVyLCBtb2RlKTtcbn1cblxuZnVuY3Rpb24gZGVyaXZlS2V5QW5kTm9uY2UoaGVhZGVyLCBtb2RlLCBsb29rdXBLZXlDYWxsYmFjaykge1xuICBpZiAoIWhlYWRlci5zYWx0KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdtdXN0IGluY2x1ZGUgYSBzYWx0IHBhcmFtZXRlciBmb3IgJyArIGhlYWRlci52ZXJzaW9uKTtcbiAgfVxuICB2YXIga2V5SW5mbztcbiAgdmFyIG5vbmNlSW5mbztcbiAgdmFyIHNlY3JldDtcbiAgaWYgKGhlYWRlci52ZXJzaW9uID09PSAnYWVzZ2NtJykge1xuICAgIC8vIG9sZFxuICAgIHZhciBzID0gZXh0cmFjdFNlY3JldEFuZENvbnRleHQoaGVhZGVyLCBtb2RlLCBsb29rdXBLZXlDYWxsYmFjayk7XG4gICAga2V5SW5mbyA9IGluZm8oJ2Flc2djbScsIHMuY29udGV4dCk7XG4gICAgbm9uY2VJbmZvID0gaW5mbygnbm9uY2UnLCBzLmNvbnRleHQpO1xuICAgIHNlY3JldCA9IHMuc2VjcmV0O1xuICB9IGVsc2UgaWYgKGhlYWRlci52ZXJzaW9uID09PSAnYWVzMTI4Z2NtJykge1xuICAgIC8vIGxhdGVzdFxuICAgIGtleUluZm8gPSBCdWZmZXIuZnJvbSgnQ29udGVudC1FbmNvZGluZzogYWVzMTI4Z2NtXFwwJyk7XG4gICAgbm9uY2VJbmZvID0gQnVmZmVyLmZyb20oJ0NvbnRlbnQtRW5jb2Rpbmc6IG5vbmNlXFwwJyk7XG4gICAgc2VjcmV0ID0gZXh0cmFjdFNlY3JldChoZWFkZXIsIG1vZGUsIGxvb2t1cEtleUNhbGxiYWNrKTtcbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1VuYWJsZSB0byBzZXQgY29udGV4dCBmb3IgbW9kZSAnICsgaGVhZGVyLnZlcnNpb24pO1xuICB9XG4gIHZhciBwcmsgPSBIS0RGX2V4dHJhY3QoaGVhZGVyLnNhbHQsIHNlY3JldCk7XG4gIHZhciByZXN1bHQgPSB7XG4gICAga2V5OiBIS0RGX2V4cGFuZChwcmssIGtleUluZm8sIEtFWV9MRU5HVEgpLFxuICAgIG5vbmNlOiBIS0RGX2V4cGFuZChwcmssIG5vbmNlSW5mbywgTk9OQ0VfTEVOR1RIKVxuICB9O1xuICBrZXlsb2coJ2tleScsIHJlc3VsdC5rZXkpO1xuICBrZXlsb2coJ25vbmNlIGJhc2UnLCByZXN1bHQubm9uY2UpO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vKiBQYXJzZSBjb21tYW5kLWxpbmUgYXJndW1lbnRzLiAqL1xuZnVuY3Rpb24gcGFyc2VQYXJhbXMocGFyYW1zKSB7XG4gIHZhciBoZWFkZXIgPSB7fTtcblxuICBoZWFkZXIudmVyc2lvbiA9IHBhcmFtcy52ZXJzaW9uIHx8ICdhZXMxMjhnY20nO1xuICBoZWFkZXIucnMgPSBwYXJzZUludChwYXJhbXMucnMsIDEwKTtcbiAgaWYgKGlzTmFOKGhlYWRlci5ycykpIHtcbiAgICBoZWFkZXIucnMgPSA0MDk2O1xuICB9XG4gIHZhciBvdmVyaGVhZCA9IFBBRF9TSVpFW2hlYWRlci52ZXJzaW9uXTtcbiAgaWYgKGhlYWRlci52ZXJzaW9uID09PSAnYWVzMTI4Z2NtJykge1xuICAgIG92ZXJoZWFkICs9IFRBR19MRU5HVEg7XG4gIH1cbiAgaWYgKGhlYWRlci5ycyA8PSBvdmVyaGVhZCkge1xuICAgIHRocm93IG5ldyBFcnJvcignVGhlIHJzIHBhcmFtZXRlciBoYXMgdG8gYmUgZ3JlYXRlciB0aGFuICcgKyBvdmVyaGVhZCk7XG4gIH1cblxuICBpZiAocGFyYW1zLnNhbHQpIHtcbiAgICBoZWFkZXIuc2FsdCA9IGRlY29kZShwYXJhbXMuc2FsdCk7XG4gICAgaWYgKGhlYWRlci5zYWx0Lmxlbmd0aCAhPT0gS0VZX0xFTkdUSCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdUaGUgc2FsdCBwYXJhbWV0ZXIgbXVzdCBiZSAnICsgS0VZX0xFTkdUSCArICcgYnl0ZXMnKTtcbiAgICB9XG4gIH1cbiAgaGVhZGVyLmtleWlkID0gcGFyYW1zLmtleWlkO1xuICBpZiAocGFyYW1zLmtleSkge1xuICAgIGhlYWRlci5rZXkgPSBkZWNvZGUocGFyYW1zLmtleSk7XG4gIH0gZWxzZSB7XG4gICAgaGVhZGVyLnByaXZhdGVLZXkgPSBwYXJhbXMucHJpdmF0ZUtleTtcbiAgICBpZiAoIWhlYWRlci5wcml2YXRlS2V5KSB7XG4gICAgICBoZWFkZXIua2V5bWFwID0gcGFyYW1zLmtleW1hcDtcbiAgICB9XG4gICAgaWYgKGhlYWRlci52ZXJzaW9uICE9PSAnYWVzMTI4Z2NtJykge1xuICAgICAgaGVhZGVyLmtleWxhYmVsID0gcGFyYW1zLmtleWxhYmVsIHx8ICdQLTI1Nic7XG4gICAgfVxuICAgIGlmIChwYXJhbXMuZGgpIHtcbiAgICAgIGhlYWRlci5kaCA9IGRlY29kZShwYXJhbXMuZGgpO1xuICAgIH1cbiAgfVxuICBpZiAocGFyYW1zLmF1dGhTZWNyZXQpIHtcbiAgICBoZWFkZXIuYXV0aFNlY3JldCA9IGRlY29kZShwYXJhbXMuYXV0aFNlY3JldCk7XG4gIH1cbiAgcmV0dXJuIGhlYWRlcjtcbn1cblxuZnVuY3Rpb24gZ2VuZXJhdGVOb25jZShiYXNlLCBjb3VudGVyKSB7XG4gIHZhciBub25jZSA9IEJ1ZmZlci5mcm9tKGJhc2UpO1xuICB2YXIgbSA9IG5vbmNlLnJlYWRVSW50QkUobm9uY2UubGVuZ3RoIC0gNiwgNik7XG4gIHZhciB4ID0gKChtIF4gY291bnRlcikgJiAweGZmZmZmZikgK1xuICAgICAgKCgoKG0gLyAweDEwMDAwMDApIF4gKGNvdW50ZXIgLyAweDEwMDAwMDApKSAmIDB4ZmZmZmZmKSAqIDB4MTAwMDAwMCk7XG4gIG5vbmNlLndyaXRlVUludEJFKHgsIG5vbmNlLmxlbmd0aCAtIDYsIDYpO1xuICBrZXlsb2coJ25vbmNlJyArIGNvdW50ZXIsIG5vbmNlKTtcbiAgcmV0dXJuIG5vbmNlO1xufVxuXG4vKiBVc2VkIHdoZW4gZGVjcnlwdGluZyBhZXMxMjhnY20gdG8gcG9wdWxhdGUgdGhlIGhlYWRlciB2YWx1ZXMuIE1vZGlmaWVzIHRoZVxuICogaGVhZGVyIHZhbHVlcyBpbiBwbGFjZSBhbmQgcmV0dXJucyB0aGUgc2l6ZSBvZiB0aGUgaGVhZGVyLiAqL1xuZnVuY3Rpb24gcmVhZEhlYWRlcihidWZmZXIsIGhlYWRlcikge1xuICB2YXIgaWRzeiA9IGJ1ZmZlci5yZWFkVUludEJFKDIwLCAxKTtcbiAgaGVhZGVyLnNhbHQgPSBidWZmZXIuc2xpY2UoMCwgS0VZX0xFTkdUSCk7XG4gIGhlYWRlci5ycyA9IGJ1ZmZlci5yZWFkVUludEJFKEtFWV9MRU5HVEgsIDQpO1xuICBoZWFkZXIua2V5aWQgPSBidWZmZXIuc2xpY2UoMjEsIDIxICsgaWRzeik7XG4gIHJldHVybiAyMSArIGlkc3o7XG59XG5cbmZ1bmN0aW9uIHVucGFkTGVnYWN5KGRhdGEsIHZlcnNpb24pIHtcbiAgdmFyIHBhZFNpemUgPSBQQURfU0laRVt2ZXJzaW9uXTtcbiAgdmFyIHBhZCA9IGRhdGEucmVhZFVJbnRCRSgwLCBwYWRTaXplKTtcbiAgaWYgKHBhZCArIHBhZFNpemUgPiBkYXRhLmxlbmd0aCkge1xuICAgIHRocm93IG5ldyBFcnJvcigncGFkZGluZyBleGNlZWRzIGJsb2NrIHNpemUnKTtcbiAgfVxuICBrZXlsb2coJ3BhZGRpbmcnLCBkYXRhLnNsaWNlKDAsIHBhZFNpemUgKyBwYWQpKTtcbiAgdmFyIHBhZENoZWNrID0gQnVmZmVyLmFsbG9jKHBhZCk7XG4gIHBhZENoZWNrLmZpbGwoMCk7XG4gIGlmIChwYWRDaGVjay5jb21wYXJlKGRhdGEuc2xpY2UocGFkU2l6ZSwgcGFkU2l6ZSArIHBhZCkpICE9PSAwKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIHBhZGRpbmcnKTtcbiAgfVxuICByZXR1cm4gZGF0YS5zbGljZShwYWRTaXplICsgcGFkKTtcbn1cblxuZnVuY3Rpb24gdW5wYWQoZGF0YSwgbGFzdCkge1xuICB2YXIgaSA9IGRhdGEubGVuZ3RoIC0gMTtcbiAgd2hpbGUoaSA+PSAwKSB7XG4gICAgaWYgKGRhdGFbaV0pIHtcbiAgICAgIGlmIChsYXN0KSB7XG4gICAgICAgIGlmIChkYXRhW2ldICE9PSAyKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdsYXN0IHJlY29yZCBuZWVkcyB0byBzdGFydCBwYWRkaW5nIHdpdGggYSAyJyk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChkYXRhW2ldICE9PSAxKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdsYXN0IHJlY29yZCBuZWVkcyB0byBzdGFydCBwYWRkaW5nIHdpdGggYSAyJyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBkYXRhLnNsaWNlKDAsIGkpO1xuICAgIH1cbiAgICAtLWk7XG4gIH1cbiAgdGhyb3cgbmV3IEVycm9yKCdhbGwgemVybyBwbGFpbnRleHQnKTtcbn1cblxuZnVuY3Rpb24gZGVjcnlwdFJlY29yZChrZXksIGNvdW50ZXIsIGJ1ZmZlciwgaGVhZGVyLCBsYXN0KSB7XG4gIGtleWxvZygnZGVjcnlwdCcsIGJ1ZmZlcik7XG4gIHZhciBub25jZSA9IGdlbmVyYXRlTm9uY2Uoa2V5Lm5vbmNlLCBjb3VudGVyKTtcbiAgdmFyIGdjbSA9IGNyeXB0by5jcmVhdGVEZWNpcGhlcml2KEFFU19HQ00sIGtleS5rZXksIG5vbmNlKTtcbiAgZ2NtLnNldEF1dGhUYWcoYnVmZmVyLnNsaWNlKGJ1ZmZlci5sZW5ndGggLSBUQUdfTEVOR1RIKSk7XG4gIHZhciBkYXRhID0gZ2NtLnVwZGF0ZShidWZmZXIuc2xpY2UoMCwgYnVmZmVyLmxlbmd0aCAtIFRBR19MRU5HVEgpKTtcbiAgZGF0YSA9IEJ1ZmZlci5jb25jYXQoW2RhdGEsIGdjbS5maW5hbCgpXSk7XG4gIGtleWxvZygnZGVjcnlwdGVkJywgZGF0YSk7XG4gIGlmIChoZWFkZXIudmVyc2lvbiAhPT0gJ2FlczEyOGdjbScpIHtcbiAgICByZXR1cm4gdW5wYWRMZWdhY3koZGF0YSwgaGVhZGVyLnZlcnNpb24pO1xuICB9XG4gIHJldHVybiB1bnBhZChkYXRhLCBsYXN0KTtcbn1cblxuLyoqXG4gKiBEZWNyeXB0IHNvbWUgYnl0ZXMuICBUaGlzIHVzZXMgdGhlIHBhcmFtZXRlcnMgdG8gZGV0ZXJtaW5lIHRoZSBrZXkgYW5kIGJsb2NrXG4gKiBzaXplLCB3aGljaCBhcmUgZGVzY3JpYmVkIGluIHRoZSBkcmFmdC4gIEJpbmFyeSB2YWx1ZXMgYXJlIGJhc2U2NHVybCBlbmNvZGVkLlxuICpcbiAqIHxwYXJhbXMudmVyc2lvbnwgY29udGFpbnMgdGhlIHZlcnNpb24gb2YgZW5jb2RpbmcgdG8gdXNlOiBhZXMxMjhnY20gaXMgdGhlIGxhdGVzdCxcbiAqIGJ1dCBhZXNnY20gaXMgYWxzbyBhY2NlcHRlZCAodGhvdWdoIHRoZSBsYXR0ZXIgbWlnaHRcbiAqIGRpc2FwcGVhciBpbiBhIGZ1dHVyZSByZWxlYXNlKS4gIElmIG9taXR0ZWQsIGFzc3VtZSBhZXMxMjhnY20uXG4gKlxuICogSWYgfHBhcmFtcy5rZXl8IGlzIHNwZWNpZmllZCwgdGhhdCB2YWx1ZSBpcyB1c2VkIGFzIHRoZSBrZXkuXG4gKlxuICogSWYgdGhlIHZlcnNpb24gaXMgYWVzMTI4Z2NtLCB0aGUga2V5aWQgaXMgZXh0cmFjdGVkIGZyb20gdGhlIGhlYWRlciBhbmQgdXNlZFxuICogYXMgdGhlIEVDREggcHVibGljIGtleSBvZiB0aGUgc2VuZGVyLiAgRm9yIHZlcnNpb24gYWVzZ2NtICxcbiAqIHxwYXJhbXMuZGh8IG5lZWRzIHRvIGJlIHByb3ZpZGVkIHdpdGggdGhlIHB1YmxpYyBrZXkgb2YgdGhlIHNlbmRlci5cbiAqXG4gKiBUaGUgfHBhcmFtcy5wcml2YXRlS2V5fCBpbmNsdWRlcyB0aGUgcHJpdmF0ZSBrZXkgb2YgdGhlIHJlY2VpdmVyLlxuICovXG5mdW5jdGlvbiBkZWNyeXB0KGJ1ZmZlciwgcGFyYW1zLCBrZXlMb29rdXBDYWxsYmFjaykge1xuICB2YXIgaGVhZGVyID0gcGFyc2VQYXJhbXMocGFyYW1zKTtcbiAgaWYgKGhlYWRlci52ZXJzaW9uID09PSAnYWVzMTI4Z2NtJykge1xuICAgIHZhciBoZWFkZXJMZW5ndGggPSByZWFkSGVhZGVyKGJ1ZmZlciwgaGVhZGVyKTtcbiAgICBidWZmZXIgPSBidWZmZXIuc2xpY2UoaGVhZGVyTGVuZ3RoKTtcbiAgfVxuICB2YXIga2V5ID0gZGVyaXZlS2V5QW5kTm9uY2UoaGVhZGVyLCBNT0RFX0RFQ1JZUFQsIGtleUxvb2t1cENhbGxiYWNrKTtcbiAgdmFyIHN0YXJ0ID0gMDtcbiAgdmFyIHJlc3VsdCA9IEJ1ZmZlci5hbGxvYygwKTtcblxuICB2YXIgY2h1bmtTaXplID0gaGVhZGVyLnJzO1xuICBpZiAoaGVhZGVyLnZlcnNpb24gIT09ICdhZXMxMjhnY20nKSB7XG4gICAgY2h1bmtTaXplICs9IFRBR19MRU5HVEg7XG4gIH1cblxuICBmb3IgKHZhciBpID0gMDsgc3RhcnQgPCBidWZmZXIubGVuZ3RoOyArK2kpIHtcbiAgICB2YXIgZW5kID0gc3RhcnQgKyBjaHVua1NpemU7XG4gICAgaWYgKGhlYWRlci52ZXJzaW9uICE9PSAnYWVzMTI4Z2NtJyAmJiBlbmQgPT09IGJ1ZmZlci5sZW5ndGgpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignVHJ1bmNhdGVkIHBheWxvYWQnKTtcbiAgICB9XG4gICAgZW5kID0gTWF0aC5taW4oZW5kLCBidWZmZXIubGVuZ3RoKTtcbiAgICBpZiAoZW5kIC0gc3RhcnQgPD0gVEFHX0xFTkdUSCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGJsb2NrOiB0b28gc21hbGwgYXQgJyArIGkpO1xuICAgIH1cbiAgICB2YXIgYmxvY2sgPSBkZWNyeXB0UmVjb3JkKGtleSwgaSwgYnVmZmVyLnNsaWNlKHN0YXJ0LCBlbmQpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaGVhZGVyLCBlbmQgPj0gYnVmZmVyLmxlbmd0aCk7XG4gICAgcmVzdWx0ID0gQnVmZmVyLmNvbmNhdChbcmVzdWx0LCBibG9ja10pO1xuICAgIHN0YXJ0ID0gZW5kO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbmZ1bmN0aW9uIGVuY3J5cHRSZWNvcmQoa2V5LCBjb3VudGVyLCBidWZmZXIsIHBhZCwgaGVhZGVyLCBsYXN0KSB7XG4gIGtleWxvZygnZW5jcnlwdCcsIGJ1ZmZlcik7XG4gIHBhZCA9IHBhZCB8fCAwO1xuICB2YXIgbm9uY2UgPSBnZW5lcmF0ZU5vbmNlKGtleS5ub25jZSwgY291bnRlcik7XG4gIHZhciBnY20gPSBjcnlwdG8uY3JlYXRlQ2lwaGVyaXYoQUVTX0dDTSwga2V5LmtleSwgbm9uY2UpO1xuXG4gIHZhciBjaXBoZXJ0ZXh0ID0gW107XG4gIHZhciBwYWRTaXplID0gUEFEX1NJWkVbaGVhZGVyLnZlcnNpb25dO1xuICB2YXIgcGFkZGluZyA9IEJ1ZmZlci5hbGxvYyhwYWQgKyBwYWRTaXplKTtcbiAgcGFkZGluZy5maWxsKDApO1xuXG4gIGlmIChoZWFkZXIudmVyc2lvbiAhPT0gJ2FlczEyOGdjbScpIHtcbiAgICBwYWRkaW5nLndyaXRlVUludEJFKHBhZCwgMCwgcGFkU2l6ZSk7XG4gICAga2V5bG9nKCdwYWRkaW5nJywgcGFkZGluZyk7XG4gICAgY2lwaGVydGV4dC5wdXNoKGdjbS51cGRhdGUocGFkZGluZykpO1xuICAgIGNpcGhlcnRleHQucHVzaChnY20udXBkYXRlKGJ1ZmZlcikpO1xuXG4gICAgaWYgKCFsYXN0ICYmIHBhZGRpbmcubGVuZ3RoICsgYnVmZmVyLmxlbmd0aCA8IGhlYWRlci5ycykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbmFibGUgdG8gcGFkIHRvIHJlY29yZCBzaXplJyk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGNpcGhlcnRleHQucHVzaChnY20udXBkYXRlKGJ1ZmZlcikpO1xuICAgIHBhZGRpbmcud3JpdGVVSW50QkUobGFzdCA/IDIgOiAxLCAwLCAxKTtcbiAgICBrZXlsb2coJ3BhZGRpbmcnLCBwYWRkaW5nKTtcbiAgICBjaXBoZXJ0ZXh0LnB1c2goZ2NtLnVwZGF0ZShwYWRkaW5nKSk7XG4gIH1cblxuICBnY20uZmluYWwoKTtcbiAgdmFyIHRhZyA9IGdjbS5nZXRBdXRoVGFnKCk7XG4gIGlmICh0YWcubGVuZ3RoICE9PSBUQUdfTEVOR1RIKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIHRhZyBnZW5lcmF0ZWQnKTtcbiAgfVxuICBjaXBoZXJ0ZXh0LnB1c2godGFnKTtcbiAgcmV0dXJuIGtleWxvZygnZW5jcnlwdGVkJywgQnVmZmVyLmNvbmNhdChjaXBoZXJ0ZXh0KSk7XG59XG5cbmZ1bmN0aW9uIHdyaXRlSGVhZGVyKGhlYWRlcikge1xuICB2YXIgaW50cyA9IEJ1ZmZlci5hbGxvYyg1KTtcbiAgdmFyIGtleWlkID0gQnVmZmVyLmZyb20oaGVhZGVyLmtleWlkIHx8IFtdKTtcbiAgaWYgKGtleWlkLmxlbmd0aCA+IDI1NSkge1xuICAgIHRocm93IG5ldyBFcnJvcigna2V5aWQgaXMgdG9vIGxhcmdlJyk7XG4gIH1cbiAgaW50cy53cml0ZVVJbnRCRShoZWFkZXIucnMsIDAsIDQpO1xuICBpbnRzLndyaXRlVUludEJFKGtleWlkLmxlbmd0aCwgNCwgMSk7XG4gIHJldHVybiBCdWZmZXIuY29uY2F0KFtoZWFkZXIuc2FsdCwgaW50cywga2V5aWRdKTtcbn1cblxuLyoqXG4gKiBFbmNyeXB0IHNvbWUgYnl0ZXMuICBUaGlzIHVzZXMgdGhlIHBhcmFtZXRlcnMgdG8gZGV0ZXJtaW5lIHRoZSBrZXkgYW5kIGJsb2NrXG4gKiBzaXplLCB3aGljaCBhcmUgZGVzY3JpYmVkIGluIHRoZSBkcmFmdC5cbiAqXG4gKiB8cGFyYW1zLnZlcnNpb258IGNvbnRhaW5zIHRoZSB2ZXJzaW9uIG9mIGVuY29kaW5nIHRvIHVzZTogYWVzMTI4Z2NtIGlzIHRoZSBsYXRlc3QsXG4gKiBidXQgYWVzZ2NtIGlzIGFsc28gYWNjZXB0ZWQgKHRob3VnaCB0aGUgbGF0dGVyIHR3byBtaWdodFxuICogZGlzYXBwZWFyIGluIGEgZnV0dXJlIHJlbGVhc2UpLiAgSWYgb21pdHRlZCwgYXNzdW1lIGFlczEyOGdjbS5cbiAqXG4gKiBJZiB8cGFyYW1zLmtleXwgaXMgc3BlY2lmaWVkLCB0aGF0IHZhbHVlIGlzIHVzZWQgYXMgdGhlIGtleS5cbiAqXG4gKiBGb3IgRGlmZmllLUhlbGxtYW4gKFdlYlB1c2gpLCB8cGFyYW1zLmRofCBpbmNsdWRlcyB0aGUgcHVibGljIGtleSBvZiB0aGVcbiAqIHJlY2VpdmVyLiAgfHBhcmFtcy5wcml2YXRlS2V5fCBpcyB1c2VkIHRvIGVzdGFibGlzaCBhIHNoYXJlZCBzZWNyZXQuICBLZXlcbiAqIHBhaXJzIGNhbiBiZSBjcmVhdGVkIHVzaW5nIHxjcnlwdG8uY3JlYXRlRUNESCgpfC5cbiAqL1xuZnVuY3Rpb24gZW5jcnlwdChidWZmZXIsIHBhcmFtcywga2V5TG9va3VwQ2FsbGJhY2spIHsgIFxuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihidWZmZXIpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdidWZmZXIgYXJndW1lbnQgbXVzdCBiZSBhIEJ1ZmZlcicpO1xuICB9XG4gIHZhciBoZWFkZXIgPSBwYXJzZVBhcmFtcyhwYXJhbXMpO1xuICBpZiAoIWhlYWRlci5zYWx0KSB7XG4gICAgaGVhZGVyLnNhbHQgPSBjcnlwdG8ucmFuZG9tQnl0ZXMoS0VZX0xFTkdUSCk7XG4gIH1cblxuICB2YXIgcmVzdWx0O1xuICBpZiAoaGVhZGVyLnZlcnNpb24gPT09ICdhZXMxMjhnY20nKSB7XG4gICAgLy8gU2F2ZSB0aGUgREggcHVibGljIGtleSBpbiB0aGUgaGVhZGVyIHVubGVzcyBrZXlpZCBpcyBzZXQuXG4gICAgaWYgKGhlYWRlci5wcml2YXRlS2V5ICYmICFoZWFkZXIua2V5aWQpIHtcbiAgICAgIGhlYWRlci5rZXlpZCA9IGhlYWRlci5wcml2YXRlS2V5LmdldFB1YmxpY0tleSgpO1xuICAgIH1cbiAgICByZXN1bHQgPSB3cml0ZUhlYWRlcihoZWFkZXIpO1xuICB9IGVsc2Uge1xuICAgIC8vIE5vIGhlYWRlciBvbiBvdGhlciB2ZXJzaW9uc1xuICAgIHJlc3VsdCA9IEJ1ZmZlci5hbGxvYygwKTtcbiAgfVxuXG4gIHZhciBrZXkgPSBkZXJpdmVLZXlBbmROb25jZShoZWFkZXIsIE1PREVfRU5DUllQVCwga2V5TG9va3VwQ2FsbGJhY2spO1xuICB2YXIgc3RhcnQgPSAwO1xuICB2YXIgcGFkU2l6ZSA9IFBBRF9TSVpFW2hlYWRlci52ZXJzaW9uXTtcbiAgdmFyIG92ZXJoZWFkID0gcGFkU2l6ZTtcbiAgaWYgKGhlYWRlci52ZXJzaW9uID09PSAnYWVzMTI4Z2NtJykge1xuICAgIG92ZXJoZWFkICs9IFRBR19MRU5HVEg7XG4gIH1cbiAgdmFyIHBhZCA9IGlzTmFOKHBhcnNlSW50KHBhcmFtcy5wYWQsIDEwKSkgPyAwIDogcGFyc2VJbnQocGFyYW1zLnBhZCwgMTApO1xuXG4gIHZhciBjb3VudGVyID0gMDtcbiAgdmFyIGxhc3QgPSBmYWxzZTtcbiAgd2hpbGUgKCFsYXN0KSB7XG4gICAgLy8gUGFkIHNvIHRoYXQgYXQgbGVhc3Qgb25lIGRhdGEgYnl0ZSBpcyBpbiBhIGJsb2NrLlxuICAgIHZhciByZWNvcmRQYWQgPSBNYXRoLm1pbihoZWFkZXIucnMgLSBvdmVyaGVhZCAtIDEsIHBhZCk7XG4gICAgaWYgKGhlYWRlci52ZXJzaW9uICE9PSAnYWVzMTI4Z2NtJykge1xuICAgICAgcmVjb3JkUGFkID0gTWF0aC5taW4oKDEgPDwgKHBhZFNpemUgKiA4KSkgLSAxLCByZWNvcmRQYWQpO1xuICAgIH1cbiAgICBpZiAocGFkID4gMCAmJiByZWNvcmRQYWQgPT09IDApIHtcbiAgICAgICsrcmVjb3JkUGFkOyAvLyBEZWFsIHdpdGggcGVydmVyc2UgY2FzZSBvZiBycz1vdmVyaGVhZCsxIHdpdGggcGFkZGluZy5cbiAgICB9XG4gICAgcGFkIC09IHJlY29yZFBhZDtcblxuICAgIHZhciBlbmQgPSBzdGFydCArIGhlYWRlci5ycyAtIG92ZXJoZWFkIC0gcmVjb3JkUGFkO1xuICAgIGlmIChoZWFkZXIudmVyc2lvbiAhPT0gJ2FlczEyOGdjbScpIHtcbiAgICAgIC8vIFRoZSA+IGhlcmUgZW5zdXJlcyB0aGF0IHdlIHdyaXRlIG91dCBhIHBhZGRpbmctb25seSBibG9jayBhdCB0aGUgZW5kXG4gICAgICAvLyBvZiBhIGJ1ZmZlci5cbiAgICAgIGxhc3QgPSBlbmQgPiBidWZmZXIubGVuZ3RoO1xuICAgIH0gZWxzZSB7XG4gICAgICBsYXN0ID0gZW5kID49IGJ1ZmZlci5sZW5ndGg7XG4gICAgfVxuICAgIGxhc3QgPSBsYXN0ICYmIHBhZCA8PSAwO1xuICAgIHZhciBibG9jayA9IGVuY3J5cHRSZWNvcmQoa2V5LCBjb3VudGVyLCBidWZmZXIuc2xpY2Uoc3RhcnQsIGVuZCksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWNvcmRQYWQsIGhlYWRlciwgbGFzdCk7XG4gICAgcmVzdWx0ID0gQnVmZmVyLmNvbmNhdChbcmVzdWx0LCBibG9ja10pO1xuXG4gICAgc3RhcnQgPSBlbmQ7XG4gICAgKytjb3VudGVyO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cblxuZnVuY3Rpb24gaXNGdW5jdGlvbihvYmplY3QpIHtcbiAgcmV0dXJuIHR5cGVvZihvYmplY3QpID09PSAnZnVuY3Rpb24nO1xuIH1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGRlY3J5cHQ6IGRlY3J5cHQsXG4gIGVuY3J5cHQ6IGVuY3J5cHRcbn07XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/http_ece/ece.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/http_ece/ece.js":
/*!**************************************!*\
  !*** ./node_modules/http_ece/ece.js ***!
  \**************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n/*\n * Encrypted content coding\n *\n * === Note about versions ===\n *\n * This code supports multiple versions of the draft.  This is selected using\n * the |version| parameter.\n *\n * aes128gcm: The most recent version, the salt, record size and key identifier\n *    are included in a header that is part of the encrypted content coding.\n *\n * aesgcm: The version that is widely deployed with WebPush (as of 2016-11).\n *    This version is selected by default, unless you specify a |padSize| of 1.\n */\n\nvar crypto = __webpack_require__(/*! crypto */ \"crypto\");\n\nvar AES_GCM = 'aes-128-gcm';\nvar PAD_SIZE = { 'aes128gcm': 1, 'aesgcm': 2 };\nvar TAG_LENGTH = 16;\nvar KEY_LENGTH = 16;\nvar NONCE_LENGTH = 12;\nvar SHA_256_LENGTH = 32;\nvar MODE_ENCRYPT = 'encrypt';\nvar MODE_DECRYPT = 'decrypt';\n\nvar keylog;\nif (process.env.ECE_KEYLOG === '1') {\n  keylog = function(m, k) {\n    console.warn(m + ' [' + k.length + ']: ' + k.toString('base64url'));\n    return k;\n  };\n} else {\n  keylog = function(m, k) { return k; };\n}\n\n/* Optionally base64 decode something. */\nfunction decode(b) {\n  if (typeof b === 'string') {\n    return Buffer.from(b, 'base64url');\n  }\n  return b;\n}\n\nfunction HMAC_hash(key, input) {\n  var hmac = crypto.createHmac('sha256', key);\n  hmac.update(input);\n  return hmac.digest();\n}\n\n/* HKDF as defined in RFC5869, using SHA-256 */\nfunction HKDF_extract(salt, ikm) {\n  keylog('salt', salt);\n  keylog('ikm', ikm);\n  return keylog('extract', HMAC_hash(salt, ikm));\n}\n\nfunction HKDF_expand(prk, info, l) {\n  keylog('prk', prk);\n  keylog('info', info);\n  var output = Buffer.alloc(0);\n  var T = Buffer.alloc(0);\n  info = Buffer.from(info, 'ascii');\n  var counter = 0;\n  var cbuf = Buffer.alloc(1);\n  while (output.length < l) {\n    cbuf.writeUIntBE(++counter, 0, 1);\n    T = HMAC_hash(prk, Buffer.concat([T, info, cbuf]));\n    output = Buffer.concat([output, T]);\n  }\n\n  return keylog('expand', output.slice(0, l));\n}\n\nfunction HKDF(salt, ikm, info, len) {\n  return HKDF_expand(HKDF_extract(salt, ikm), info, len);\n}\n\nfunction info(base, context) {\n  var result = Buffer.concat([\n    Buffer.from('Content-Encoding: ' + base + '\\0', 'ascii'),\n    context\n  ]);\n  keylog('info ' + base, result);\n  return result;\n}\n\nfunction lengthPrefix(buffer) {\n  var b = Buffer.concat([Buffer.alloc(2), buffer]);\n  b.writeUIntBE(buffer.length, 0, 2);\n  return b;\n}\n\nfunction extractDH(header, mode) {\n  var key = header.privateKey;\n  var senderPubKey, receiverPubKey;\n  if (mode === MODE_ENCRYPT) {\n    senderPubKey = key.getPublicKey();\n    receiverPubKey = header.dh;\n  } else if (mode === MODE_DECRYPT) {\n    senderPubKey = header.dh;\n    receiverPubKey = key.getPublicKey();\n  } else {\n    throw new Error('Unknown mode only ' + MODE_ENCRYPT +\n                    ' and ' + MODE_DECRYPT + ' supported');\n  }\n  return {\n    secret: key.computeSecret(header.dh),\n    context: Buffer.concat([\n      Buffer.from(header.keylabel, 'ascii'),\n      Buffer.from([0]),\n      lengthPrefix(receiverPubKey), // user agent\n      lengthPrefix(senderPubKey)    // application server\n    ])\n  };\n}\n\nfunction extractSecretAndContext(header, mode) {\n  var result = { secret: null, context: Buffer.alloc(0) };\n  if (header.key) {\n    result.secret = header.key;\n    if (result.secret.length !== KEY_LENGTH) {\n      throw new Error('An explicit key must be ' + KEY_LENGTH + ' bytes');\n    }\n  } else if (header.dh) { // receiver/decrypt\n    result = extractDH(header, mode);\n  } else if (typeof header.keyid !== undefined) {\n    result.secret = header.keymap[header.keyid];\n  }\n  if (!result.secret) {\n    throw new Error('Unable to determine key');\n  }\n  keylog('secret', result.secret);\n  keylog('context', result.context);\n  if (header.authSecret) {\n    result.secret = HKDF(header.authSecret, result.secret,\n                         info('auth', Buffer.alloc(0)), SHA_256_LENGTH);\n    keylog('authsecret', result.secret);\n  }\n  return result;\n}\n\nfunction webpushSecret(header, mode) {\n  if (!header.authSecret) {\n    throw new Error('No authentication secret for webpush');\n  }\n  keylog('authsecret', header.authSecret);\n\n  var remotePubKey, senderPubKey, receiverPubKey;\n  if (mode === MODE_ENCRYPT) {\n    senderPubKey = header.privateKey.getPublicKey();\n    remotePubKey = receiverPubKey = header.dh;\n  } else if (mode === MODE_DECRYPT) {\n    remotePubKey = senderPubKey = header.keyid;\n    receiverPubKey = header.privateKey.getPublicKey();\n  } else {\n    throw new Error('Unknown mode only ' + MODE_ENCRYPT +\n                    ' and ' + MODE_DECRYPT + ' supported');\n  }\n  keylog('remote pubkey', remotePubKey);\n  keylog('sender pubkey', senderPubKey);\n  keylog('receiver pubkey', receiverPubKey);\n  return keylog('secret dh',\n                HKDF(header.authSecret,\n                     header.privateKey.computeSecret(remotePubKey),\n                     Buffer.concat([\n                       Buffer.from('WebPush: info\\0'),\n                       receiverPubKey,\n                       senderPubKey\n                     ]),\n                     SHA_256_LENGTH));\n}\n\nfunction extractSecret(header, mode, keyLookupCallback) {\n  if (keyLookupCallback) {\n    if (!isFunction(keyLookupCallback)) {\n      throw new Error('Callback is not a function')\n    }\n  }\n\n  if (header.key) {\n    if (header.key.length !== KEY_LENGTH) {\n      throw new Error('An explicit key must be ' + KEY_LENGTH + ' bytes');\n    }\n    return keylog('secret key', header.key);\n  }\n\n  if (!header.privateKey) {\n    // Lookup based on keyid\n    if (!keyLookupCallback) {\n      var key = header.keymap && header.keymap[header.keyid];\n    } else {\n      var key = keyLookupCallback(header.keyid)\n    }\n    if (!key) {\n      throw new Error('No saved key (keyid: \"' + header.keyid + '\")');\n    }\n    return key;\n  }\n\n  return webpushSecret(header, mode);\n}\n\nfunction deriveKeyAndNonce(header, mode, lookupKeyCallback) {\n  if (!header.salt) {\n    throw new Error('must include a salt parameter for ' + header.version);\n  }\n  var keyInfo;\n  var nonceInfo;\n  var secret;\n  if (header.version === 'aesgcm') {\n    // old\n    var s = extractSecretAndContext(header, mode, lookupKeyCallback);\n    keyInfo = info('aesgcm', s.context);\n    nonceInfo = info('nonce', s.context);\n    secret = s.secret;\n  } else if (header.version === 'aes128gcm') {\n    // latest\n    keyInfo = Buffer.from('Content-Encoding: aes128gcm\\0');\n    nonceInfo = Buffer.from('Content-Encoding: nonce\\0');\n    secret = extractSecret(header, mode, lookupKeyCallback);\n  } else {\n    throw new Error('Unable to set context for mode ' + header.version);\n  }\n  var prk = HKDF_extract(header.salt, secret);\n  var result = {\n    key: HKDF_expand(prk, keyInfo, KEY_LENGTH),\n    nonce: HKDF_expand(prk, nonceInfo, NONCE_LENGTH)\n  };\n  keylog('key', result.key);\n  keylog('nonce base', result.nonce);\n  return result;\n}\n\n/* Parse command-line arguments. */\nfunction parseParams(params) {\n  var header = {};\n\n  header.version = params.version || 'aes128gcm';\n  header.rs = parseInt(params.rs, 10);\n  if (isNaN(header.rs)) {\n    header.rs = 4096;\n  }\n  var overhead = PAD_SIZE[header.version];\n  if (header.version === 'aes128gcm') {\n    overhead += TAG_LENGTH;\n  }\n  if (header.rs <= overhead) {\n    throw new Error('The rs parameter has to be greater than ' + overhead);\n  }\n\n  if (params.salt) {\n    header.salt = decode(params.salt);\n    if (header.salt.length !== KEY_LENGTH) {\n      throw new Error('The salt parameter must be ' + KEY_LENGTH + ' bytes');\n    }\n  }\n  header.keyid = params.keyid;\n  if (params.key) {\n    header.key = decode(params.key);\n  } else {\n    header.privateKey = params.privateKey;\n    if (!header.privateKey) {\n      header.keymap = params.keymap;\n    }\n    if (header.version !== 'aes128gcm') {\n      header.keylabel = params.keylabel || 'P-256';\n    }\n    if (params.dh) {\n      header.dh = decode(params.dh);\n    }\n  }\n  if (params.authSecret) {\n    header.authSecret = decode(params.authSecret);\n  }\n  return header;\n}\n\nfunction generateNonce(base, counter) {\n  var nonce = Buffer.from(base);\n  var m = nonce.readUIntBE(nonce.length - 6, 6);\n  var x = ((m ^ counter) & 0xffffff) +\n      ((((m / 0x1000000) ^ (counter / 0x1000000)) & 0xffffff) * 0x1000000);\n  nonce.writeUIntBE(x, nonce.length - 6, 6);\n  keylog('nonce' + counter, nonce);\n  return nonce;\n}\n\n/* Used when decrypting aes128gcm to populate the header values. Modifies the\n * header values in place and returns the size of the header. */\nfunction readHeader(buffer, header) {\n  var idsz = buffer.readUIntBE(20, 1);\n  header.salt = buffer.slice(0, KEY_LENGTH);\n  header.rs = buffer.readUIntBE(KEY_LENGTH, 4);\n  header.keyid = buffer.slice(21, 21 + idsz);\n  return 21 + idsz;\n}\n\nfunction unpadLegacy(data, version) {\n  var padSize = PAD_SIZE[version];\n  var pad = data.readUIntBE(0, padSize);\n  if (pad + padSize > data.length) {\n    throw new Error('padding exceeds block size');\n  }\n  keylog('padding', data.slice(0, padSize + pad));\n  var padCheck = Buffer.alloc(pad);\n  padCheck.fill(0);\n  if (padCheck.compare(data.slice(padSize, padSize + pad)) !== 0) {\n    throw new Error('invalid padding');\n  }\n  return data.slice(padSize + pad);\n}\n\nfunction unpad(data, last) {\n  var i = data.length - 1;\n  while(i >= 0) {\n    if (data[i]) {\n      if (last) {\n        if (data[i] !== 2) {\n          throw new Error('last record needs to start padding with a 2');\n        }\n      } else {\n        if (data[i] !== 1) {\n          throw new Error('last record needs to start padding with a 2');\n        }\n      }\n      return data.slice(0, i);\n    }\n    --i;\n  }\n  throw new Error('all zero plaintext');\n}\n\nfunction decryptRecord(key, counter, buffer, header, last) {\n  keylog('decrypt', buffer);\n  var nonce = generateNonce(key.nonce, counter);\n  var gcm = crypto.createDecipheriv(AES_GCM, key.key, nonce);\n  gcm.setAuthTag(buffer.slice(buffer.length - TAG_LENGTH));\n  var data = gcm.update(buffer.slice(0, buffer.length - TAG_LENGTH));\n  data = Buffer.concat([data, gcm.final()]);\n  keylog('decrypted', data);\n  if (header.version !== 'aes128gcm') {\n    return unpadLegacy(data, header.version);\n  }\n  return unpad(data, last);\n}\n\n/**\n * Decrypt some bytes.  This uses the parameters to determine the key and block\n * size, which are described in the draft.  Binary values are base64url encoded.\n *\n * |params.version| contains the version of encoding to use: aes128gcm is the latest,\n * but aesgcm is also accepted (though the latter might\n * disappear in a future release).  If omitted, assume aes128gcm.\n *\n * If |params.key| is specified, that value is used as the key.\n *\n * If the version is aes128gcm, the keyid is extracted from the header and used\n * as the ECDH public key of the sender.  For version aesgcm ,\n * |params.dh| needs to be provided with the public key of the sender.\n *\n * The |params.privateKey| includes the private key of the receiver.\n */\nfunction decrypt(buffer, params, keyLookupCallback) {\n  var header = parseParams(params);\n  if (header.version === 'aes128gcm') {\n    var headerLength = readHeader(buffer, header);\n    buffer = buffer.slice(headerLength);\n  }\n  var key = deriveKeyAndNonce(header, MODE_DECRYPT, keyLookupCallback);\n  var start = 0;\n  var result = Buffer.alloc(0);\n\n  var chunkSize = header.rs;\n  if (header.version !== 'aes128gcm') {\n    chunkSize += TAG_LENGTH;\n  }\n\n  for (var i = 0; start < buffer.length; ++i) {\n    var end = start + chunkSize;\n    if (header.version !== 'aes128gcm' && end === buffer.length) {\n      throw new Error('Truncated payload');\n    }\n    end = Math.min(end, buffer.length);\n    if (end - start <= TAG_LENGTH) {\n      throw new Error('Invalid block: too small at ' + i);\n    }\n    var block = decryptRecord(key, i, buffer.slice(start, end),\n                              header, end >= buffer.length);\n    result = Buffer.concat([result, block]);\n    start = end;\n  }\n  return result;\n}\n\nfunction encryptRecord(key, counter, buffer, pad, header, last) {\n  keylog('encrypt', buffer);\n  pad = pad || 0;\n  var nonce = generateNonce(key.nonce, counter);\n  var gcm = crypto.createCipheriv(AES_GCM, key.key, nonce);\n\n  var ciphertext = [];\n  var padSize = PAD_SIZE[header.version];\n  var padding = Buffer.alloc(pad + padSize);\n  padding.fill(0);\n\n  if (header.version !== 'aes128gcm') {\n    padding.writeUIntBE(pad, 0, padSize);\n    keylog('padding', padding);\n    ciphertext.push(gcm.update(padding));\n    ciphertext.push(gcm.update(buffer));\n\n    if (!last && padding.length + buffer.length < header.rs) {\n      throw new Error('Unable to pad to record size');\n    }\n  } else {\n    ciphertext.push(gcm.update(buffer));\n    padding.writeUIntBE(last ? 2 : 1, 0, 1);\n    keylog('padding', padding);\n    ciphertext.push(gcm.update(padding));\n  }\n\n  gcm.final();\n  var tag = gcm.getAuthTag();\n  if (tag.length !== TAG_LENGTH) {\n    throw new Error('invalid tag generated');\n  }\n  ciphertext.push(tag);\n  return keylog('encrypted', Buffer.concat(ciphertext));\n}\n\nfunction writeHeader(header) {\n  var ints = Buffer.alloc(5);\n  var keyid = Buffer.from(header.keyid || []);\n  if (keyid.length > 255) {\n    throw new Error('keyid is too large');\n  }\n  ints.writeUIntBE(header.rs, 0, 4);\n  ints.writeUIntBE(keyid.length, 4, 1);\n  return Buffer.concat([header.salt, ints, keyid]);\n}\n\n/**\n * Encrypt some bytes.  This uses the parameters to determine the key and block\n * size, which are described in the draft.\n *\n * |params.version| contains the version of encoding to use: aes128gcm is the latest,\n * but aesgcm is also accepted (though the latter two might\n * disappear in a future release).  If omitted, assume aes128gcm.\n *\n * If |params.key| is specified, that value is used as the key.\n *\n * For Diffie-Hellman (WebPush), |params.dh| includes the public key of the\n * receiver.  |params.privateKey| is used to establish a shared secret.  Key\n * pairs can be created using |crypto.createECDH()|.\n */\nfunction encrypt(buffer, params, keyLookupCallback) {  \n  if (!Buffer.isBuffer(buffer)) {\n    throw new Error('buffer argument must be a Buffer');\n  }\n  var header = parseParams(params);\n  if (!header.salt) {\n    header.salt = crypto.randomBytes(KEY_LENGTH);\n  }\n\n  var result;\n  if (header.version === 'aes128gcm') {\n    // Save the DH public key in the header unless keyid is set.\n    if (header.privateKey && !header.keyid) {\n      header.keyid = header.privateKey.getPublicKey();\n    }\n    result = writeHeader(header);\n  } else {\n    // No header on other versions\n    result = Buffer.alloc(0);\n  }\n\n  var key = deriveKeyAndNonce(header, MODE_ENCRYPT, keyLookupCallback);\n  var start = 0;\n  var padSize = PAD_SIZE[header.version];\n  var overhead = padSize;\n  if (header.version === 'aes128gcm') {\n    overhead += TAG_LENGTH;\n  }\n  var pad = isNaN(parseInt(params.pad, 10)) ? 0 : parseInt(params.pad, 10);\n\n  var counter = 0;\n  var last = false;\n  while (!last) {\n    // Pad so that at least one data byte is in a block.\n    var recordPad = Math.min(header.rs - overhead - 1, pad);\n    if (header.version !== 'aes128gcm') {\n      recordPad = Math.min((1 << (padSize * 8)) - 1, recordPad);\n    }\n    if (pad > 0 && recordPad === 0) {\n      ++recordPad; // Deal with perverse case of rs=overhead+1 with padding.\n    }\n    pad -= recordPad;\n\n    var end = start + header.rs - overhead - recordPad;\n    if (header.version !== 'aes128gcm') {\n      // The > here ensures that we write out a padding-only block at the end\n      // of a buffer.\n      last = end > buffer.length;\n    } else {\n      last = end >= buffer.length;\n    }\n    last = last && pad <= 0;\n    var block = encryptRecord(key, counter, buffer.slice(start, end),\n                              recordPad, header, last);\n    result = Buffer.concat([result, block]);\n\n    start = end;\n    ++counter;\n  }\n  return result;\n}\n\n\nfunction isFunction(object) {\n  return typeof(object) === 'function';\n }\n\nmodule.exports = {\n  decrypt: decrypt,\n  encrypt: encrypt\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvaHR0cF9lY2UvZWNlLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxhQUFhLG1CQUFPLENBQUMsc0JBQVE7O0FBRTdCO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0YsNEJBQTRCO0FBQzVCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSxzQkFBc0I7QUFDMUI7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsa0JBQWtCLHVCQUF1QjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJEOlxcYXBsaWNhY2lvbmVzLWlhXFxuZXh0LXRhc2tcXG5vZGVfbW9kdWxlc1xcaHR0cF9lY2VcXGVjZS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG4vKlxuICogRW5jcnlwdGVkIGNvbnRlbnQgY29kaW5nXG4gKlxuICogPT09IE5vdGUgYWJvdXQgdmVyc2lvbnMgPT09XG4gKlxuICogVGhpcyBjb2RlIHN1cHBvcnRzIG11bHRpcGxlIHZlcnNpb25zIG9mIHRoZSBkcmFmdC4gIFRoaXMgaXMgc2VsZWN0ZWQgdXNpbmdcbiAqIHRoZSB8dmVyc2lvbnwgcGFyYW1ldGVyLlxuICpcbiAqIGFlczEyOGdjbTogVGhlIG1vc3QgcmVjZW50IHZlcnNpb24sIHRoZSBzYWx0LCByZWNvcmQgc2l6ZSBhbmQga2V5IGlkZW50aWZpZXJcbiAqICAgIGFyZSBpbmNsdWRlZCBpbiBhIGhlYWRlciB0aGF0IGlzIHBhcnQgb2YgdGhlIGVuY3J5cHRlZCBjb250ZW50IGNvZGluZy5cbiAqXG4gKiBhZXNnY206IFRoZSB2ZXJzaW9uIHRoYXQgaXMgd2lkZWx5IGRlcGxveWVkIHdpdGggV2ViUHVzaCAoYXMgb2YgMjAxNi0xMSkuXG4gKiAgICBUaGlzIHZlcnNpb24gaXMgc2VsZWN0ZWQgYnkgZGVmYXVsdCwgdW5sZXNzIHlvdSBzcGVjaWZ5IGEgfHBhZFNpemV8IG9mIDEuXG4gKi9cblxudmFyIGNyeXB0byA9IHJlcXVpcmUoJ2NyeXB0bycpO1xuXG52YXIgQUVTX0dDTSA9ICdhZXMtMTI4LWdjbSc7XG52YXIgUEFEX1NJWkUgPSB7ICdhZXMxMjhnY20nOiAxLCAnYWVzZ2NtJzogMiB9O1xudmFyIFRBR19MRU5HVEggPSAxNjtcbnZhciBLRVlfTEVOR1RIID0gMTY7XG52YXIgTk9OQ0VfTEVOR1RIID0gMTI7XG52YXIgU0hBXzI1Nl9MRU5HVEggPSAzMjtcbnZhciBNT0RFX0VOQ1JZUFQgPSAnZW5jcnlwdCc7XG52YXIgTU9ERV9ERUNSWVBUID0gJ2RlY3J5cHQnO1xuXG52YXIga2V5bG9nO1xuaWYgKHByb2Nlc3MuZW52LkVDRV9LRVlMT0cgPT09ICcxJykge1xuICBrZXlsb2cgPSBmdW5jdGlvbihtLCBrKSB7XG4gICAgY29uc29sZS53YXJuKG0gKyAnIFsnICsgay5sZW5ndGggKyAnXTogJyArIGsudG9TdHJpbmcoJ2Jhc2U2NHVybCcpKTtcbiAgICByZXR1cm4gaztcbiAgfTtcbn0gZWxzZSB7XG4gIGtleWxvZyA9IGZ1bmN0aW9uKG0sIGspIHsgcmV0dXJuIGs7IH07XG59XG5cbi8qIE9wdGlvbmFsbHkgYmFzZTY0IGRlY29kZSBzb21ldGhpbmcuICovXG5mdW5jdGlvbiBkZWNvZGUoYikge1xuICBpZiAodHlwZW9mIGIgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIEJ1ZmZlci5mcm9tKGIsICdiYXNlNjR1cmwnKTtcbiAgfVxuICByZXR1cm4gYjtcbn1cblxuZnVuY3Rpb24gSE1BQ19oYXNoKGtleSwgaW5wdXQpIHtcbiAgdmFyIGhtYWMgPSBjcnlwdG8uY3JlYXRlSG1hYygnc2hhMjU2Jywga2V5KTtcbiAgaG1hYy51cGRhdGUoaW5wdXQpO1xuICByZXR1cm4gaG1hYy5kaWdlc3QoKTtcbn1cblxuLyogSEtERiBhcyBkZWZpbmVkIGluIFJGQzU4NjksIHVzaW5nIFNIQS0yNTYgKi9cbmZ1bmN0aW9uIEhLREZfZXh0cmFjdChzYWx0LCBpa20pIHtcbiAga2V5bG9nKCdzYWx0Jywgc2FsdCk7XG4gIGtleWxvZygnaWttJywgaWttKTtcbiAgcmV0dXJuIGtleWxvZygnZXh0cmFjdCcsIEhNQUNfaGFzaChzYWx0LCBpa20pKTtcbn1cblxuZnVuY3Rpb24gSEtERl9leHBhbmQocHJrLCBpbmZvLCBsKSB7XG4gIGtleWxvZygncHJrJywgcHJrKTtcbiAga2V5bG9nKCdpbmZvJywgaW5mbyk7XG4gIHZhciBvdXRwdXQgPSBCdWZmZXIuYWxsb2MoMCk7XG4gIHZhciBUID0gQnVmZmVyLmFsbG9jKDApO1xuICBpbmZvID0gQnVmZmVyLmZyb20oaW5mbywgJ2FzY2lpJyk7XG4gIHZhciBjb3VudGVyID0gMDtcbiAgdmFyIGNidWYgPSBCdWZmZXIuYWxsb2MoMSk7XG4gIHdoaWxlIChvdXRwdXQubGVuZ3RoIDwgbCkge1xuICAgIGNidWYud3JpdGVVSW50QkUoKytjb3VudGVyLCAwLCAxKTtcbiAgICBUID0gSE1BQ19oYXNoKHByaywgQnVmZmVyLmNvbmNhdChbVCwgaW5mbywgY2J1Zl0pKTtcbiAgICBvdXRwdXQgPSBCdWZmZXIuY29uY2F0KFtvdXRwdXQsIFRdKTtcbiAgfVxuXG4gIHJldHVybiBrZXlsb2coJ2V4cGFuZCcsIG91dHB1dC5zbGljZSgwLCBsKSk7XG59XG5cbmZ1bmN0aW9uIEhLREYoc2FsdCwgaWttLCBpbmZvLCBsZW4pIHtcbiAgcmV0dXJuIEhLREZfZXhwYW5kKEhLREZfZXh0cmFjdChzYWx0LCBpa20pLCBpbmZvLCBsZW4pO1xufVxuXG5mdW5jdGlvbiBpbmZvKGJhc2UsIGNvbnRleHQpIHtcbiAgdmFyIHJlc3VsdCA9IEJ1ZmZlci5jb25jYXQoW1xuICAgIEJ1ZmZlci5mcm9tKCdDb250ZW50LUVuY29kaW5nOiAnICsgYmFzZSArICdcXDAnLCAnYXNjaWknKSxcbiAgICBjb250ZXh0XG4gIF0pO1xuICBrZXlsb2coJ2luZm8gJyArIGJhc2UsIHJlc3VsdCk7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbmZ1bmN0aW9uIGxlbmd0aFByZWZpeChidWZmZXIpIHtcbiAgdmFyIGIgPSBCdWZmZXIuY29uY2F0KFtCdWZmZXIuYWxsb2MoMiksIGJ1ZmZlcl0pO1xuICBiLndyaXRlVUludEJFKGJ1ZmZlci5sZW5ndGgsIDAsIDIpO1xuICByZXR1cm4gYjtcbn1cblxuZnVuY3Rpb24gZXh0cmFjdERIKGhlYWRlciwgbW9kZSkge1xuICB2YXIga2V5ID0gaGVhZGVyLnByaXZhdGVLZXk7XG4gIHZhciBzZW5kZXJQdWJLZXksIHJlY2VpdmVyUHViS2V5O1xuICBpZiAobW9kZSA9PT0gTU9ERV9FTkNSWVBUKSB7XG4gICAgc2VuZGVyUHViS2V5ID0ga2V5LmdldFB1YmxpY0tleSgpO1xuICAgIHJlY2VpdmVyUHViS2V5ID0gaGVhZGVyLmRoO1xuICB9IGVsc2UgaWYgKG1vZGUgPT09IE1PREVfREVDUllQVCkge1xuICAgIHNlbmRlclB1YktleSA9IGhlYWRlci5kaDtcbiAgICByZWNlaXZlclB1YktleSA9IGtleS5nZXRQdWJsaWNLZXkoKTtcbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vua25vd24gbW9kZSBvbmx5ICcgKyBNT0RFX0VOQ1JZUFQgK1xuICAgICAgICAgICAgICAgICAgICAnIGFuZCAnICsgTU9ERV9ERUNSWVBUICsgJyBzdXBwb3J0ZWQnKTtcbiAgfVxuICByZXR1cm4ge1xuICAgIHNlY3JldDoga2V5LmNvbXB1dGVTZWNyZXQoaGVhZGVyLmRoKSxcbiAgICBjb250ZXh0OiBCdWZmZXIuY29uY2F0KFtcbiAgICAgIEJ1ZmZlci5mcm9tKGhlYWRlci5rZXlsYWJlbCwgJ2FzY2lpJyksXG4gICAgICBCdWZmZXIuZnJvbShbMF0pLFxuICAgICAgbGVuZ3RoUHJlZml4KHJlY2VpdmVyUHViS2V5KSwgLy8gdXNlciBhZ2VudFxuICAgICAgbGVuZ3RoUHJlZml4KHNlbmRlclB1YktleSkgICAgLy8gYXBwbGljYXRpb24gc2VydmVyXG4gICAgXSlcbiAgfTtcbn1cblxuZnVuY3Rpb24gZXh0cmFjdFNlY3JldEFuZENvbnRleHQoaGVhZGVyLCBtb2RlKSB7XG4gIHZhciByZXN1bHQgPSB7IHNlY3JldDogbnVsbCwgY29udGV4dDogQnVmZmVyLmFsbG9jKDApIH07XG4gIGlmIChoZWFkZXIua2V5KSB7XG4gICAgcmVzdWx0LnNlY3JldCA9IGhlYWRlci5rZXk7XG4gICAgaWYgKHJlc3VsdC5zZWNyZXQubGVuZ3RoICE9PSBLRVlfTEVOR1RIKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0FuIGV4cGxpY2l0IGtleSBtdXN0IGJlICcgKyBLRVlfTEVOR1RIICsgJyBieXRlcycpO1xuICAgIH1cbiAgfSBlbHNlIGlmIChoZWFkZXIuZGgpIHsgLy8gcmVjZWl2ZXIvZGVjcnlwdFxuICAgIHJlc3VsdCA9IGV4dHJhY3RESChoZWFkZXIsIG1vZGUpO1xuICB9IGVsc2UgaWYgKHR5cGVvZiBoZWFkZXIua2V5aWQgIT09IHVuZGVmaW5lZCkge1xuICAgIHJlc3VsdC5zZWNyZXQgPSBoZWFkZXIua2V5bWFwW2hlYWRlci5rZXlpZF07XG4gIH1cbiAgaWYgKCFyZXN1bHQuc2VjcmV0KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdVbmFibGUgdG8gZGV0ZXJtaW5lIGtleScpO1xuICB9XG4gIGtleWxvZygnc2VjcmV0JywgcmVzdWx0LnNlY3JldCk7XG4gIGtleWxvZygnY29udGV4dCcsIHJlc3VsdC5jb250ZXh0KTtcbiAgaWYgKGhlYWRlci5hdXRoU2VjcmV0KSB7XG4gICAgcmVzdWx0LnNlY3JldCA9IEhLREYoaGVhZGVyLmF1dGhTZWNyZXQsIHJlc3VsdC5zZWNyZXQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgaW5mbygnYXV0aCcsIEJ1ZmZlci5hbGxvYygwKSksIFNIQV8yNTZfTEVOR1RIKTtcbiAgICBrZXlsb2coJ2F1dGhzZWNyZXQnLCByZXN1bHQuc2VjcmV0KTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5mdW5jdGlvbiB3ZWJwdXNoU2VjcmV0KGhlYWRlciwgbW9kZSkge1xuICBpZiAoIWhlYWRlci5hdXRoU2VjcmV0KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdObyBhdXRoZW50aWNhdGlvbiBzZWNyZXQgZm9yIHdlYnB1c2gnKTtcbiAgfVxuICBrZXlsb2coJ2F1dGhzZWNyZXQnLCBoZWFkZXIuYXV0aFNlY3JldCk7XG5cbiAgdmFyIHJlbW90ZVB1YktleSwgc2VuZGVyUHViS2V5LCByZWNlaXZlclB1YktleTtcbiAgaWYgKG1vZGUgPT09IE1PREVfRU5DUllQVCkge1xuICAgIHNlbmRlclB1YktleSA9IGhlYWRlci5wcml2YXRlS2V5LmdldFB1YmxpY0tleSgpO1xuICAgIHJlbW90ZVB1YktleSA9IHJlY2VpdmVyUHViS2V5ID0gaGVhZGVyLmRoO1xuICB9IGVsc2UgaWYgKG1vZGUgPT09IE1PREVfREVDUllQVCkge1xuICAgIHJlbW90ZVB1YktleSA9IHNlbmRlclB1YktleSA9IGhlYWRlci5rZXlpZDtcbiAgICByZWNlaXZlclB1YktleSA9IGhlYWRlci5wcml2YXRlS2V5LmdldFB1YmxpY0tleSgpO1xuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBFcnJvcignVW5rbm93biBtb2RlIG9ubHkgJyArIE1PREVfRU5DUllQVCArXG4gICAgICAgICAgICAgICAgICAgICcgYW5kICcgKyBNT0RFX0RFQ1JZUFQgKyAnIHN1cHBvcnRlZCcpO1xuICB9XG4gIGtleWxvZygncmVtb3RlIHB1YmtleScsIHJlbW90ZVB1YktleSk7XG4gIGtleWxvZygnc2VuZGVyIHB1YmtleScsIHNlbmRlclB1YktleSk7XG4gIGtleWxvZygncmVjZWl2ZXIgcHVia2V5JywgcmVjZWl2ZXJQdWJLZXkpO1xuICByZXR1cm4ga2V5bG9nKCdzZWNyZXQgZGgnLFxuICAgICAgICAgICAgICAgIEhLREYoaGVhZGVyLmF1dGhTZWNyZXQsXG4gICAgICAgICAgICAgICAgICAgICBoZWFkZXIucHJpdmF0ZUtleS5jb21wdXRlU2VjcmV0KHJlbW90ZVB1YktleSksXG4gICAgICAgICAgICAgICAgICAgICBCdWZmZXIuY29uY2F0KFtcbiAgICAgICAgICAgICAgICAgICAgICAgQnVmZmVyLmZyb20oJ1dlYlB1c2g6IGluZm9cXDAnKSxcbiAgICAgICAgICAgICAgICAgICAgICAgcmVjZWl2ZXJQdWJLZXksXG4gICAgICAgICAgICAgICAgICAgICAgIHNlbmRlclB1YktleVxuICAgICAgICAgICAgICAgICAgICAgXSksXG4gICAgICAgICAgICAgICAgICAgICBTSEFfMjU2X0xFTkdUSCkpO1xufVxuXG5mdW5jdGlvbiBleHRyYWN0U2VjcmV0KGhlYWRlciwgbW9kZSwga2V5TG9va3VwQ2FsbGJhY2spIHtcbiAgaWYgKGtleUxvb2t1cENhbGxiYWNrKSB7XG4gICAgaWYgKCFpc0Z1bmN0aW9uKGtleUxvb2t1cENhbGxiYWNrKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYWxsYmFjayBpcyBub3QgYSBmdW5jdGlvbicpXG4gICAgfVxuICB9XG5cbiAgaWYgKGhlYWRlci5rZXkpIHtcbiAgICBpZiAoaGVhZGVyLmtleS5sZW5ndGggIT09IEtFWV9MRU5HVEgpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignQW4gZXhwbGljaXQga2V5IG11c3QgYmUgJyArIEtFWV9MRU5HVEggKyAnIGJ5dGVzJyk7XG4gICAgfVxuICAgIHJldHVybiBrZXlsb2coJ3NlY3JldCBrZXknLCBoZWFkZXIua2V5KTtcbiAgfVxuXG4gIGlmICghaGVhZGVyLnByaXZhdGVLZXkpIHtcbiAgICAvLyBMb29rdXAgYmFzZWQgb24ga2V5aWRcbiAgICBpZiAoIWtleUxvb2t1cENhbGxiYWNrKSB7XG4gICAgICB2YXIga2V5ID0gaGVhZGVyLmtleW1hcCAmJiBoZWFkZXIua2V5bWFwW2hlYWRlci5rZXlpZF07XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBrZXkgPSBrZXlMb29rdXBDYWxsYmFjayhoZWFkZXIua2V5aWQpXG4gICAgfVxuICAgIGlmICgha2V5KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vIHNhdmVkIGtleSAoa2V5aWQ6IFwiJyArIGhlYWRlci5rZXlpZCArICdcIiknKTtcbiAgICB9XG4gICAgcmV0dXJuIGtleTtcbiAgfVxuXG4gIHJldHVybiB3ZWJwdXNoU2VjcmV0KGhlYWRlciwgbW9kZSk7XG59XG5cbmZ1bmN0aW9uIGRlcml2ZUtleUFuZE5vbmNlKGhlYWRlciwgbW9kZSwgbG9va3VwS2V5Q2FsbGJhY2spIHtcbiAgaWYgKCFoZWFkZXIuc2FsdCkge1xuICAgIHRocm93IG5ldyBFcnJvcignbXVzdCBpbmNsdWRlIGEgc2FsdCBwYXJhbWV0ZXIgZm9yICcgKyBoZWFkZXIudmVyc2lvbik7XG4gIH1cbiAgdmFyIGtleUluZm87XG4gIHZhciBub25jZUluZm87XG4gIHZhciBzZWNyZXQ7XG4gIGlmIChoZWFkZXIudmVyc2lvbiA9PT0gJ2Flc2djbScpIHtcbiAgICAvLyBvbGRcbiAgICB2YXIgcyA9IGV4dHJhY3RTZWNyZXRBbmRDb250ZXh0KGhlYWRlciwgbW9kZSwgbG9va3VwS2V5Q2FsbGJhY2spO1xuICAgIGtleUluZm8gPSBpbmZvKCdhZXNnY20nLCBzLmNvbnRleHQpO1xuICAgIG5vbmNlSW5mbyA9IGluZm8oJ25vbmNlJywgcy5jb250ZXh0KTtcbiAgICBzZWNyZXQgPSBzLnNlY3JldDtcbiAgfSBlbHNlIGlmIChoZWFkZXIudmVyc2lvbiA9PT0gJ2FlczEyOGdjbScpIHtcbiAgICAvLyBsYXRlc3RcbiAgICBrZXlJbmZvID0gQnVmZmVyLmZyb20oJ0NvbnRlbnQtRW5jb2Rpbmc6IGFlczEyOGdjbVxcMCcpO1xuICAgIG5vbmNlSW5mbyA9IEJ1ZmZlci5mcm9tKCdDb250ZW50LUVuY29kaW5nOiBub25jZVxcMCcpO1xuICAgIHNlY3JldCA9IGV4dHJhY3RTZWNyZXQoaGVhZGVyLCBtb2RlLCBsb29rdXBLZXlDYWxsYmFjayk7XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdVbmFibGUgdG8gc2V0IGNvbnRleHQgZm9yIG1vZGUgJyArIGhlYWRlci52ZXJzaW9uKTtcbiAgfVxuICB2YXIgcHJrID0gSEtERl9leHRyYWN0KGhlYWRlci5zYWx0LCBzZWNyZXQpO1xuICB2YXIgcmVzdWx0ID0ge1xuICAgIGtleTogSEtERl9leHBhbmQocHJrLCBrZXlJbmZvLCBLRVlfTEVOR1RIKSxcbiAgICBub25jZTogSEtERl9leHBhbmQocHJrLCBub25jZUluZm8sIE5PTkNFX0xFTkdUSClcbiAgfTtcbiAga2V5bG9nKCdrZXknLCByZXN1bHQua2V5KTtcbiAga2V5bG9nKCdub25jZSBiYXNlJywgcmVzdWx0Lm5vbmNlKTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLyogUGFyc2UgY29tbWFuZC1saW5lIGFyZ3VtZW50cy4gKi9cbmZ1bmN0aW9uIHBhcnNlUGFyYW1zKHBhcmFtcykge1xuICB2YXIgaGVhZGVyID0ge307XG5cbiAgaGVhZGVyLnZlcnNpb24gPSBwYXJhbXMudmVyc2lvbiB8fCAnYWVzMTI4Z2NtJztcbiAgaGVhZGVyLnJzID0gcGFyc2VJbnQocGFyYW1zLnJzLCAxMCk7XG4gIGlmIChpc05hTihoZWFkZXIucnMpKSB7XG4gICAgaGVhZGVyLnJzID0gNDA5NjtcbiAgfVxuICB2YXIgb3ZlcmhlYWQgPSBQQURfU0laRVtoZWFkZXIudmVyc2lvbl07XG4gIGlmIChoZWFkZXIudmVyc2lvbiA9PT0gJ2FlczEyOGdjbScpIHtcbiAgICBvdmVyaGVhZCArPSBUQUdfTEVOR1RIO1xuICB9XG4gIGlmIChoZWFkZXIucnMgPD0gb3ZlcmhlYWQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoZSBycyBwYXJhbWV0ZXIgaGFzIHRvIGJlIGdyZWF0ZXIgdGhhbiAnICsgb3ZlcmhlYWQpO1xuICB9XG5cbiAgaWYgKHBhcmFtcy5zYWx0KSB7XG4gICAgaGVhZGVyLnNhbHQgPSBkZWNvZGUocGFyYW1zLnNhbHQpO1xuICAgIGlmIChoZWFkZXIuc2FsdC5sZW5ndGggIT09IEtFWV9MRU5HVEgpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignVGhlIHNhbHQgcGFyYW1ldGVyIG11c3QgYmUgJyArIEtFWV9MRU5HVEggKyAnIGJ5dGVzJyk7XG4gICAgfVxuICB9XG4gIGhlYWRlci5rZXlpZCA9IHBhcmFtcy5rZXlpZDtcbiAgaWYgKHBhcmFtcy5rZXkpIHtcbiAgICBoZWFkZXIua2V5ID0gZGVjb2RlKHBhcmFtcy5rZXkpO1xuICB9IGVsc2Uge1xuICAgIGhlYWRlci5wcml2YXRlS2V5ID0gcGFyYW1zLnByaXZhdGVLZXk7XG4gICAgaWYgKCFoZWFkZXIucHJpdmF0ZUtleSkge1xuICAgICAgaGVhZGVyLmtleW1hcCA9IHBhcmFtcy5rZXltYXA7XG4gICAgfVxuICAgIGlmIChoZWFkZXIudmVyc2lvbiAhPT0gJ2FlczEyOGdjbScpIHtcbiAgICAgIGhlYWRlci5rZXlsYWJlbCA9IHBhcmFtcy5rZXlsYWJlbCB8fCAnUC0yNTYnO1xuICAgIH1cbiAgICBpZiAocGFyYW1zLmRoKSB7XG4gICAgICBoZWFkZXIuZGggPSBkZWNvZGUocGFyYW1zLmRoKTtcbiAgICB9XG4gIH1cbiAgaWYgKHBhcmFtcy5hdXRoU2VjcmV0KSB7XG4gICAgaGVhZGVyLmF1dGhTZWNyZXQgPSBkZWNvZGUocGFyYW1zLmF1dGhTZWNyZXQpO1xuICB9XG4gIHJldHVybiBoZWFkZXI7XG59XG5cbmZ1bmN0aW9uIGdlbmVyYXRlTm9uY2UoYmFzZSwgY291bnRlcikge1xuICB2YXIgbm9uY2UgPSBCdWZmZXIuZnJvbShiYXNlKTtcbiAgdmFyIG0gPSBub25jZS5yZWFkVUludEJFKG5vbmNlLmxlbmd0aCAtIDYsIDYpO1xuICB2YXIgeCA9ICgobSBeIGNvdW50ZXIpICYgMHhmZmZmZmYpICtcbiAgICAgICgoKChtIC8gMHgxMDAwMDAwKSBeIChjb3VudGVyIC8gMHgxMDAwMDAwKSkgJiAweGZmZmZmZikgKiAweDEwMDAwMDApO1xuICBub25jZS53cml0ZVVJbnRCRSh4LCBub25jZS5sZW5ndGggLSA2LCA2KTtcbiAga2V5bG9nKCdub25jZScgKyBjb3VudGVyLCBub25jZSk7XG4gIHJldHVybiBub25jZTtcbn1cblxuLyogVXNlZCB3aGVuIGRlY3J5cHRpbmcgYWVzMTI4Z2NtIHRvIHBvcHVsYXRlIHRoZSBoZWFkZXIgdmFsdWVzLiBNb2RpZmllcyB0aGVcbiAqIGhlYWRlciB2YWx1ZXMgaW4gcGxhY2UgYW5kIHJldHVybnMgdGhlIHNpemUgb2YgdGhlIGhlYWRlci4gKi9cbmZ1bmN0aW9uIHJlYWRIZWFkZXIoYnVmZmVyLCBoZWFkZXIpIHtcbiAgdmFyIGlkc3ogPSBidWZmZXIucmVhZFVJbnRCRSgyMCwgMSk7XG4gIGhlYWRlci5zYWx0ID0gYnVmZmVyLnNsaWNlKDAsIEtFWV9MRU5HVEgpO1xuICBoZWFkZXIucnMgPSBidWZmZXIucmVhZFVJbnRCRShLRVlfTEVOR1RILCA0KTtcbiAgaGVhZGVyLmtleWlkID0gYnVmZmVyLnNsaWNlKDIxLCAyMSArIGlkc3opO1xuICByZXR1cm4gMjEgKyBpZHN6O1xufVxuXG5mdW5jdGlvbiB1bnBhZExlZ2FjeShkYXRhLCB2ZXJzaW9uKSB7XG4gIHZhciBwYWRTaXplID0gUEFEX1NJWkVbdmVyc2lvbl07XG4gIHZhciBwYWQgPSBkYXRhLnJlYWRVSW50QkUoMCwgcGFkU2l6ZSk7XG4gIGlmIChwYWQgKyBwYWRTaXplID4gZGF0YS5sZW5ndGgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3BhZGRpbmcgZXhjZWVkcyBibG9jayBzaXplJyk7XG4gIH1cbiAga2V5bG9nKCdwYWRkaW5nJywgZGF0YS5zbGljZSgwLCBwYWRTaXplICsgcGFkKSk7XG4gIHZhciBwYWRDaGVjayA9IEJ1ZmZlci5hbGxvYyhwYWQpO1xuICBwYWRDaGVjay5maWxsKDApO1xuICBpZiAocGFkQ2hlY2suY29tcGFyZShkYXRhLnNsaWNlKHBhZFNpemUsIHBhZFNpemUgKyBwYWQpKSAhPT0gMCkge1xuICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBwYWRkaW5nJyk7XG4gIH1cbiAgcmV0dXJuIGRhdGEuc2xpY2UocGFkU2l6ZSArIHBhZCk7XG59XG5cbmZ1bmN0aW9uIHVucGFkKGRhdGEsIGxhc3QpIHtcbiAgdmFyIGkgPSBkYXRhLmxlbmd0aCAtIDE7XG4gIHdoaWxlKGkgPj0gMCkge1xuICAgIGlmIChkYXRhW2ldKSB7XG4gICAgICBpZiAobGFzdCkge1xuICAgICAgICBpZiAoZGF0YVtpXSAhPT0gMikge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignbGFzdCByZWNvcmQgbmVlZHMgdG8gc3RhcnQgcGFkZGluZyB3aXRoIGEgMicpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoZGF0YVtpXSAhPT0gMSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignbGFzdCByZWNvcmQgbmVlZHMgdG8gc3RhcnQgcGFkZGluZyB3aXRoIGEgMicpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gZGF0YS5zbGljZSgwLCBpKTtcbiAgICB9XG4gICAgLS1pO1xuICB9XG4gIHRocm93IG5ldyBFcnJvcignYWxsIHplcm8gcGxhaW50ZXh0Jyk7XG59XG5cbmZ1bmN0aW9uIGRlY3J5cHRSZWNvcmQoa2V5LCBjb3VudGVyLCBidWZmZXIsIGhlYWRlciwgbGFzdCkge1xuICBrZXlsb2coJ2RlY3J5cHQnLCBidWZmZXIpO1xuICB2YXIgbm9uY2UgPSBnZW5lcmF0ZU5vbmNlKGtleS5ub25jZSwgY291bnRlcik7XG4gIHZhciBnY20gPSBjcnlwdG8uY3JlYXRlRGVjaXBoZXJpdihBRVNfR0NNLCBrZXkua2V5LCBub25jZSk7XG4gIGdjbS5zZXRBdXRoVGFnKGJ1ZmZlci5zbGljZShidWZmZXIubGVuZ3RoIC0gVEFHX0xFTkdUSCkpO1xuICB2YXIgZGF0YSA9IGdjbS51cGRhdGUoYnVmZmVyLnNsaWNlKDAsIGJ1ZmZlci5sZW5ndGggLSBUQUdfTEVOR1RIKSk7XG4gIGRhdGEgPSBCdWZmZXIuY29uY2F0KFtkYXRhLCBnY20uZmluYWwoKV0pO1xuICBrZXlsb2coJ2RlY3J5cHRlZCcsIGRhdGEpO1xuICBpZiAoaGVhZGVyLnZlcnNpb24gIT09ICdhZXMxMjhnY20nKSB7XG4gICAgcmV0dXJuIHVucGFkTGVnYWN5KGRhdGEsIGhlYWRlci52ZXJzaW9uKTtcbiAgfVxuICByZXR1cm4gdW5wYWQoZGF0YSwgbGFzdCk7XG59XG5cbi8qKlxuICogRGVjcnlwdCBzb21lIGJ5dGVzLiAgVGhpcyB1c2VzIHRoZSBwYXJhbWV0ZXJzIHRvIGRldGVybWluZSB0aGUga2V5IGFuZCBibG9ja1xuICogc2l6ZSwgd2hpY2ggYXJlIGRlc2NyaWJlZCBpbiB0aGUgZHJhZnQuICBCaW5hcnkgdmFsdWVzIGFyZSBiYXNlNjR1cmwgZW5jb2RlZC5cbiAqXG4gKiB8cGFyYW1zLnZlcnNpb258IGNvbnRhaW5zIHRoZSB2ZXJzaW9uIG9mIGVuY29kaW5nIHRvIHVzZTogYWVzMTI4Z2NtIGlzIHRoZSBsYXRlc3QsXG4gKiBidXQgYWVzZ2NtIGlzIGFsc28gYWNjZXB0ZWQgKHRob3VnaCB0aGUgbGF0dGVyIG1pZ2h0XG4gKiBkaXNhcHBlYXIgaW4gYSBmdXR1cmUgcmVsZWFzZSkuICBJZiBvbWl0dGVkLCBhc3N1bWUgYWVzMTI4Z2NtLlxuICpcbiAqIElmIHxwYXJhbXMua2V5fCBpcyBzcGVjaWZpZWQsIHRoYXQgdmFsdWUgaXMgdXNlZCBhcyB0aGUga2V5LlxuICpcbiAqIElmIHRoZSB2ZXJzaW9uIGlzIGFlczEyOGdjbSwgdGhlIGtleWlkIGlzIGV4dHJhY3RlZCBmcm9tIHRoZSBoZWFkZXIgYW5kIHVzZWRcbiAqIGFzIHRoZSBFQ0RIIHB1YmxpYyBrZXkgb2YgdGhlIHNlbmRlci4gIEZvciB2ZXJzaW9uIGFlc2djbSAsXG4gKiB8cGFyYW1zLmRofCBuZWVkcyB0byBiZSBwcm92aWRlZCB3aXRoIHRoZSBwdWJsaWMga2V5IG9mIHRoZSBzZW5kZXIuXG4gKlxuICogVGhlIHxwYXJhbXMucHJpdmF0ZUtleXwgaW5jbHVkZXMgdGhlIHByaXZhdGUga2V5IG9mIHRoZSByZWNlaXZlci5cbiAqL1xuZnVuY3Rpb24gZGVjcnlwdChidWZmZXIsIHBhcmFtcywga2V5TG9va3VwQ2FsbGJhY2spIHtcbiAgdmFyIGhlYWRlciA9IHBhcnNlUGFyYW1zKHBhcmFtcyk7XG4gIGlmIChoZWFkZXIudmVyc2lvbiA9PT0gJ2FlczEyOGdjbScpIHtcbiAgICB2YXIgaGVhZGVyTGVuZ3RoID0gcmVhZEhlYWRlcihidWZmZXIsIGhlYWRlcik7XG4gICAgYnVmZmVyID0gYnVmZmVyLnNsaWNlKGhlYWRlckxlbmd0aCk7XG4gIH1cbiAgdmFyIGtleSA9IGRlcml2ZUtleUFuZE5vbmNlKGhlYWRlciwgTU9ERV9ERUNSWVBULCBrZXlMb29rdXBDYWxsYmFjayk7XG4gIHZhciBzdGFydCA9IDA7XG4gIHZhciByZXN1bHQgPSBCdWZmZXIuYWxsb2MoMCk7XG5cbiAgdmFyIGNodW5rU2l6ZSA9IGhlYWRlci5ycztcbiAgaWYgKGhlYWRlci52ZXJzaW9uICE9PSAnYWVzMTI4Z2NtJykge1xuICAgIGNodW5rU2l6ZSArPSBUQUdfTEVOR1RIO1xuICB9XG5cbiAgZm9yICh2YXIgaSA9IDA7IHN0YXJ0IDwgYnVmZmVyLmxlbmd0aDsgKytpKSB7XG4gICAgdmFyIGVuZCA9IHN0YXJ0ICsgY2h1bmtTaXplO1xuICAgIGlmIChoZWFkZXIudmVyc2lvbiAhPT0gJ2FlczEyOGdjbScgJiYgZW5kID09PSBidWZmZXIubGVuZ3RoKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RydW5jYXRlZCBwYXlsb2FkJyk7XG4gICAgfVxuICAgIGVuZCA9IE1hdGgubWluKGVuZCwgYnVmZmVyLmxlbmd0aCk7XG4gICAgaWYgKGVuZCAtIHN0YXJ0IDw9IFRBR19MRU5HVEgpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBibG9jazogdG9vIHNtYWxsIGF0ICcgKyBpKTtcbiAgICB9XG4gICAgdmFyIGJsb2NrID0gZGVjcnlwdFJlY29yZChrZXksIGksIGJ1ZmZlci5zbGljZShzdGFydCwgZW5kKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhlYWRlciwgZW5kID49IGJ1ZmZlci5sZW5ndGgpO1xuICAgIHJlc3VsdCA9IEJ1ZmZlci5jb25jYXQoW3Jlc3VsdCwgYmxvY2tdKTtcbiAgICBzdGFydCA9IGVuZDtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5mdW5jdGlvbiBlbmNyeXB0UmVjb3JkKGtleSwgY291bnRlciwgYnVmZmVyLCBwYWQsIGhlYWRlciwgbGFzdCkge1xuICBrZXlsb2coJ2VuY3J5cHQnLCBidWZmZXIpO1xuICBwYWQgPSBwYWQgfHwgMDtcbiAgdmFyIG5vbmNlID0gZ2VuZXJhdGVOb25jZShrZXkubm9uY2UsIGNvdW50ZXIpO1xuICB2YXIgZ2NtID0gY3J5cHRvLmNyZWF0ZUNpcGhlcml2KEFFU19HQ00sIGtleS5rZXksIG5vbmNlKTtcblxuICB2YXIgY2lwaGVydGV4dCA9IFtdO1xuICB2YXIgcGFkU2l6ZSA9IFBBRF9TSVpFW2hlYWRlci52ZXJzaW9uXTtcbiAgdmFyIHBhZGRpbmcgPSBCdWZmZXIuYWxsb2MocGFkICsgcGFkU2l6ZSk7XG4gIHBhZGRpbmcuZmlsbCgwKTtcblxuICBpZiAoaGVhZGVyLnZlcnNpb24gIT09ICdhZXMxMjhnY20nKSB7XG4gICAgcGFkZGluZy53cml0ZVVJbnRCRShwYWQsIDAsIHBhZFNpemUpO1xuICAgIGtleWxvZygncGFkZGluZycsIHBhZGRpbmcpO1xuICAgIGNpcGhlcnRleHQucHVzaChnY20udXBkYXRlKHBhZGRpbmcpKTtcbiAgICBjaXBoZXJ0ZXh0LnB1c2goZ2NtLnVwZGF0ZShidWZmZXIpKTtcblxuICAgIGlmICghbGFzdCAmJiBwYWRkaW5nLmxlbmd0aCArIGJ1ZmZlci5sZW5ndGggPCBoZWFkZXIucnMpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignVW5hYmxlIHRvIHBhZCB0byByZWNvcmQgc2l6ZScpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBjaXBoZXJ0ZXh0LnB1c2goZ2NtLnVwZGF0ZShidWZmZXIpKTtcbiAgICBwYWRkaW5nLndyaXRlVUludEJFKGxhc3QgPyAyIDogMSwgMCwgMSk7XG4gICAga2V5bG9nKCdwYWRkaW5nJywgcGFkZGluZyk7XG4gICAgY2lwaGVydGV4dC5wdXNoKGdjbS51cGRhdGUocGFkZGluZykpO1xuICB9XG5cbiAgZ2NtLmZpbmFsKCk7XG4gIHZhciB0YWcgPSBnY20uZ2V0QXV0aFRhZygpO1xuICBpZiAodGFnLmxlbmd0aCAhPT0gVEFHX0xFTkdUSCkge1xuICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCB0YWcgZ2VuZXJhdGVkJyk7XG4gIH1cbiAgY2lwaGVydGV4dC5wdXNoKHRhZyk7XG4gIHJldHVybiBrZXlsb2coJ2VuY3J5cHRlZCcsIEJ1ZmZlci5jb25jYXQoY2lwaGVydGV4dCkpO1xufVxuXG5mdW5jdGlvbiB3cml0ZUhlYWRlcihoZWFkZXIpIHtcbiAgdmFyIGludHMgPSBCdWZmZXIuYWxsb2MoNSk7XG4gIHZhciBrZXlpZCA9IEJ1ZmZlci5mcm9tKGhlYWRlci5rZXlpZCB8fCBbXSk7XG4gIGlmIChrZXlpZC5sZW5ndGggPiAyNTUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2tleWlkIGlzIHRvbyBsYXJnZScpO1xuICB9XG4gIGludHMud3JpdGVVSW50QkUoaGVhZGVyLnJzLCAwLCA0KTtcbiAgaW50cy53cml0ZVVJbnRCRShrZXlpZC5sZW5ndGgsIDQsIDEpO1xuICByZXR1cm4gQnVmZmVyLmNvbmNhdChbaGVhZGVyLnNhbHQsIGludHMsIGtleWlkXSk7XG59XG5cbi8qKlxuICogRW5jcnlwdCBzb21lIGJ5dGVzLiAgVGhpcyB1c2VzIHRoZSBwYXJhbWV0ZXJzIHRvIGRldGVybWluZSB0aGUga2V5IGFuZCBibG9ja1xuICogc2l6ZSwgd2hpY2ggYXJlIGRlc2NyaWJlZCBpbiB0aGUgZHJhZnQuXG4gKlxuICogfHBhcmFtcy52ZXJzaW9ufCBjb250YWlucyB0aGUgdmVyc2lvbiBvZiBlbmNvZGluZyB0byB1c2U6IGFlczEyOGdjbSBpcyB0aGUgbGF0ZXN0LFxuICogYnV0IGFlc2djbSBpcyBhbHNvIGFjY2VwdGVkICh0aG91Z2ggdGhlIGxhdHRlciB0d28gbWlnaHRcbiAqIGRpc2FwcGVhciBpbiBhIGZ1dHVyZSByZWxlYXNlKS4gIElmIG9taXR0ZWQsIGFzc3VtZSBhZXMxMjhnY20uXG4gKlxuICogSWYgfHBhcmFtcy5rZXl8IGlzIHNwZWNpZmllZCwgdGhhdCB2YWx1ZSBpcyB1c2VkIGFzIHRoZSBrZXkuXG4gKlxuICogRm9yIERpZmZpZS1IZWxsbWFuIChXZWJQdXNoKSwgfHBhcmFtcy5kaHwgaW5jbHVkZXMgdGhlIHB1YmxpYyBrZXkgb2YgdGhlXG4gKiByZWNlaXZlci4gIHxwYXJhbXMucHJpdmF0ZUtleXwgaXMgdXNlZCB0byBlc3RhYmxpc2ggYSBzaGFyZWQgc2VjcmV0LiAgS2V5XG4gKiBwYWlycyBjYW4gYmUgY3JlYXRlZCB1c2luZyB8Y3J5cHRvLmNyZWF0ZUVDREgoKXwuXG4gKi9cbmZ1bmN0aW9uIGVuY3J5cHQoYnVmZmVyLCBwYXJhbXMsIGtleUxvb2t1cENhbGxiYWNrKSB7ICBcbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoYnVmZmVyKSkge1xuICAgIHRocm93IG5ldyBFcnJvcignYnVmZmVyIGFyZ3VtZW50IG11c3QgYmUgYSBCdWZmZXInKTtcbiAgfVxuICB2YXIgaGVhZGVyID0gcGFyc2VQYXJhbXMocGFyYW1zKTtcbiAgaWYgKCFoZWFkZXIuc2FsdCkge1xuICAgIGhlYWRlci5zYWx0ID0gY3J5cHRvLnJhbmRvbUJ5dGVzKEtFWV9MRU5HVEgpO1xuICB9XG5cbiAgdmFyIHJlc3VsdDtcbiAgaWYgKGhlYWRlci52ZXJzaW9uID09PSAnYWVzMTI4Z2NtJykge1xuICAgIC8vIFNhdmUgdGhlIERIIHB1YmxpYyBrZXkgaW4gdGhlIGhlYWRlciB1bmxlc3Mga2V5aWQgaXMgc2V0LlxuICAgIGlmIChoZWFkZXIucHJpdmF0ZUtleSAmJiAhaGVhZGVyLmtleWlkKSB7XG4gICAgICBoZWFkZXIua2V5aWQgPSBoZWFkZXIucHJpdmF0ZUtleS5nZXRQdWJsaWNLZXkoKTtcbiAgICB9XG4gICAgcmVzdWx0ID0gd3JpdGVIZWFkZXIoaGVhZGVyKTtcbiAgfSBlbHNlIHtcbiAgICAvLyBObyBoZWFkZXIgb24gb3RoZXIgdmVyc2lvbnNcbiAgICByZXN1bHQgPSBCdWZmZXIuYWxsb2MoMCk7XG4gIH1cblxuICB2YXIga2V5ID0gZGVyaXZlS2V5QW5kTm9uY2UoaGVhZGVyLCBNT0RFX0VOQ1JZUFQsIGtleUxvb2t1cENhbGxiYWNrKTtcbiAgdmFyIHN0YXJ0ID0gMDtcbiAgdmFyIHBhZFNpemUgPSBQQURfU0laRVtoZWFkZXIudmVyc2lvbl07XG4gIHZhciBvdmVyaGVhZCA9IHBhZFNpemU7XG4gIGlmIChoZWFkZXIudmVyc2lvbiA9PT0gJ2FlczEyOGdjbScpIHtcbiAgICBvdmVyaGVhZCArPSBUQUdfTEVOR1RIO1xuICB9XG4gIHZhciBwYWQgPSBpc05hTihwYXJzZUludChwYXJhbXMucGFkLCAxMCkpID8gMCA6IHBhcnNlSW50KHBhcmFtcy5wYWQsIDEwKTtcblxuICB2YXIgY291bnRlciA9IDA7XG4gIHZhciBsYXN0ID0gZmFsc2U7XG4gIHdoaWxlICghbGFzdCkge1xuICAgIC8vIFBhZCBzbyB0aGF0IGF0IGxlYXN0IG9uZSBkYXRhIGJ5dGUgaXMgaW4gYSBibG9jay5cbiAgICB2YXIgcmVjb3JkUGFkID0gTWF0aC5taW4oaGVhZGVyLnJzIC0gb3ZlcmhlYWQgLSAxLCBwYWQpO1xuICAgIGlmIChoZWFkZXIudmVyc2lvbiAhPT0gJ2FlczEyOGdjbScpIHtcbiAgICAgIHJlY29yZFBhZCA9IE1hdGgubWluKCgxIDw8IChwYWRTaXplICogOCkpIC0gMSwgcmVjb3JkUGFkKTtcbiAgICB9XG4gICAgaWYgKHBhZCA+IDAgJiYgcmVjb3JkUGFkID09PSAwKSB7XG4gICAgICArK3JlY29yZFBhZDsgLy8gRGVhbCB3aXRoIHBlcnZlcnNlIGNhc2Ugb2YgcnM9b3ZlcmhlYWQrMSB3aXRoIHBhZGRpbmcuXG4gICAgfVxuICAgIHBhZCAtPSByZWNvcmRQYWQ7XG5cbiAgICB2YXIgZW5kID0gc3RhcnQgKyBoZWFkZXIucnMgLSBvdmVyaGVhZCAtIHJlY29yZFBhZDtcbiAgICBpZiAoaGVhZGVyLnZlcnNpb24gIT09ICdhZXMxMjhnY20nKSB7XG4gICAgICAvLyBUaGUgPiBoZXJlIGVuc3VyZXMgdGhhdCB3ZSB3cml0ZSBvdXQgYSBwYWRkaW5nLW9ubHkgYmxvY2sgYXQgdGhlIGVuZFxuICAgICAgLy8gb2YgYSBidWZmZXIuXG4gICAgICBsYXN0ID0gZW5kID4gYnVmZmVyLmxlbmd0aDtcbiAgICB9IGVsc2Uge1xuICAgICAgbGFzdCA9IGVuZCA+PSBidWZmZXIubGVuZ3RoO1xuICAgIH1cbiAgICBsYXN0ID0gbGFzdCAmJiBwYWQgPD0gMDtcbiAgICB2YXIgYmxvY2sgPSBlbmNyeXB0UmVjb3JkKGtleSwgY291bnRlciwgYnVmZmVyLnNsaWNlKHN0YXJ0LCBlbmQpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVjb3JkUGFkLCBoZWFkZXIsIGxhc3QpO1xuICAgIHJlc3VsdCA9IEJ1ZmZlci5jb25jYXQoW3Jlc3VsdCwgYmxvY2tdKTtcblxuICAgIHN0YXJ0ID0gZW5kO1xuICAgICsrY291bnRlcjtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5cbmZ1bmN0aW9uIGlzRnVuY3Rpb24ob2JqZWN0KSB7XG4gIHJldHVybiB0eXBlb2Yob2JqZWN0KSA9PT0gJ2Z1bmN0aW9uJztcbiB9XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBkZWNyeXB0OiBkZWNyeXB0LFxuICBlbmNyeXB0OiBlbmNyeXB0XG59O1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/http_ece/ece.js\n");

/***/ })

};
;