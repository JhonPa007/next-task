"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/web-push";
exports.ids = ["vendor-chunks/web-push"];
exports.modules = {

/***/ "(action-browser)/./node_modules/web-push/src/encryption-helper.js":
/*!********************************************************!*\
  !*** ./node_modules/web-push/src/encryption-helper.js ***!
  \********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nconst crypto = __webpack_require__(/*! crypto */ \"crypto\");\nconst ece = __webpack_require__(/*! http_ece */ \"(action-browser)/./node_modules/http_ece/ece.js\");\n\nconst encrypt = function(userPublicKey, userAuth, payload, contentEncoding) {\n  if (!userPublicKey) {\n    throw new Error('No user public key provided for encryption.');\n  }\n\n  if (typeof userPublicKey !== 'string') {\n    throw new Error('The subscription p256dh value must be a string.');\n  }\n\n  if (Buffer.from(userPublicKey, 'base64url').length !== 65) {\n    throw new Error('The subscription p256dh value should be 65 bytes long.');\n  }\n\n  if (!userAuth) {\n    throw new Error('No user auth provided for encryption.');\n  }\n\n  if (typeof userAuth !== 'string') {\n    throw new Error('The subscription auth key must be a string.');\n  }\n\n  if (Buffer.from(userAuth, 'base64url').length < 16) {\n    throw new Error('The subscription auth key should be at least 16 '\n    + 'bytes long');\n  }\n\n  if (typeof payload !== 'string' && !Buffer.isBuffer(payload)) {\n    throw new Error('Payload must be either a string or a Node Buffer.');\n  }\n\n  if (typeof payload === 'string' || payload instanceof String) {\n    payload = Buffer.from(payload);\n  }\n\n  const localCurve = crypto.createECDH('prime256v1');\n  const localPublicKey = localCurve.generateKeys();\n\n  const salt = crypto.randomBytes(16).toString('base64url');\n\n  const cipherText = ece.encrypt(payload, {\n    version: contentEncoding,\n    dh: userPublicKey,\n    privateKey: localCurve,\n    salt: salt,\n    authSecret: userAuth\n  });\n\n  return {\n    localPublicKey: localPublicKey,\n    salt: salt,\n    cipherText: cipherText\n  };\n};\n\nmodule.exports = {\n  encrypt: encrypt\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy93ZWItcHVzaC9zcmMvZW5jcnlwdGlvbi1oZWxwZXIuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsZUFBZSxtQkFBTyxDQUFDLHNCQUFRO0FBQy9CLFlBQVksbUJBQU8sQ0FBQyxpRUFBVTs7QUFFOUI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIkQ6XFxhcGxpY2FjaW9uZXMtaWFcXG5leHQtdGFza1xcbm9kZV9tb2R1bGVzXFx3ZWItcHVzaFxcc3JjXFxlbmNyeXB0aW9uLWhlbHBlci5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbmNvbnN0IGNyeXB0byA9IHJlcXVpcmUoJ2NyeXB0bycpO1xuY29uc3QgZWNlID0gcmVxdWlyZSgnaHR0cF9lY2UnKTtcblxuY29uc3QgZW5jcnlwdCA9IGZ1bmN0aW9uKHVzZXJQdWJsaWNLZXksIHVzZXJBdXRoLCBwYXlsb2FkLCBjb250ZW50RW5jb2RpbmcpIHtcbiAgaWYgKCF1c2VyUHVibGljS2V5KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdObyB1c2VyIHB1YmxpYyBrZXkgcHJvdmlkZWQgZm9yIGVuY3J5cHRpb24uJyk7XG4gIH1cblxuICBpZiAodHlwZW9mIHVzZXJQdWJsaWNLZXkgIT09ICdzdHJpbmcnKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdUaGUgc3Vic2NyaXB0aW9uIHAyNTZkaCB2YWx1ZSBtdXN0IGJlIGEgc3RyaW5nLicpO1xuICB9XG5cbiAgaWYgKEJ1ZmZlci5mcm9tKHVzZXJQdWJsaWNLZXksICdiYXNlNjR1cmwnKS5sZW5ndGggIT09IDY1KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdUaGUgc3Vic2NyaXB0aW9uIHAyNTZkaCB2YWx1ZSBzaG91bGQgYmUgNjUgYnl0ZXMgbG9uZy4nKTtcbiAgfVxuXG4gIGlmICghdXNlckF1dGgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ05vIHVzZXIgYXV0aCBwcm92aWRlZCBmb3IgZW5jcnlwdGlvbi4nKTtcbiAgfVxuXG4gIGlmICh0eXBlb2YgdXNlckF1dGggIT09ICdzdHJpbmcnKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdUaGUgc3Vic2NyaXB0aW9uIGF1dGgga2V5IG11c3QgYmUgYSBzdHJpbmcuJyk7XG4gIH1cblxuICBpZiAoQnVmZmVyLmZyb20odXNlckF1dGgsICdiYXNlNjR1cmwnKS5sZW5ndGggPCAxNikge1xuICAgIHRocm93IG5ldyBFcnJvcignVGhlIHN1YnNjcmlwdGlvbiBhdXRoIGtleSBzaG91bGQgYmUgYXQgbGVhc3QgMTYgJ1xuICAgICsgJ2J5dGVzIGxvbmcnKTtcbiAgfVxuXG4gIGlmICh0eXBlb2YgcGF5bG9hZCAhPT0gJ3N0cmluZycgJiYgIUJ1ZmZlci5pc0J1ZmZlcihwYXlsb2FkKSkge1xuICAgIHRocm93IG5ldyBFcnJvcignUGF5bG9hZCBtdXN0IGJlIGVpdGhlciBhIHN0cmluZyBvciBhIE5vZGUgQnVmZmVyLicpO1xuICB9XG5cbiAgaWYgKHR5cGVvZiBwYXlsb2FkID09PSAnc3RyaW5nJyB8fCBwYXlsb2FkIGluc3RhbmNlb2YgU3RyaW5nKSB7XG4gICAgcGF5bG9hZCA9IEJ1ZmZlci5mcm9tKHBheWxvYWQpO1xuICB9XG5cbiAgY29uc3QgbG9jYWxDdXJ2ZSA9IGNyeXB0by5jcmVhdGVFQ0RIKCdwcmltZTI1NnYxJyk7XG4gIGNvbnN0IGxvY2FsUHVibGljS2V5ID0gbG9jYWxDdXJ2ZS5nZW5lcmF0ZUtleXMoKTtcblxuICBjb25zdCBzYWx0ID0gY3J5cHRvLnJhbmRvbUJ5dGVzKDE2KS50b1N0cmluZygnYmFzZTY0dXJsJyk7XG5cbiAgY29uc3QgY2lwaGVyVGV4dCA9IGVjZS5lbmNyeXB0KHBheWxvYWQsIHtcbiAgICB2ZXJzaW9uOiBjb250ZW50RW5jb2RpbmcsXG4gICAgZGg6IHVzZXJQdWJsaWNLZXksXG4gICAgcHJpdmF0ZUtleTogbG9jYWxDdXJ2ZSxcbiAgICBzYWx0OiBzYWx0LFxuICAgIGF1dGhTZWNyZXQ6IHVzZXJBdXRoXG4gIH0pO1xuXG4gIHJldHVybiB7XG4gICAgbG9jYWxQdWJsaWNLZXk6IGxvY2FsUHVibGljS2V5LFxuICAgIHNhbHQ6IHNhbHQsXG4gICAgY2lwaGVyVGV4dDogY2lwaGVyVGV4dFxuICB9O1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGVuY3J5cHQ6IGVuY3J5cHRcbn07XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/web-push/src/encryption-helper.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/web-push/src/index.js":
/*!********************************************!*\
  !*** ./node_modules/web-push/src/index.js ***!
  \********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nconst vapidHelper = __webpack_require__(/*! ./vapid-helper.js */ \"(action-browser)/./node_modules/web-push/src/vapid-helper.js\");\nconst encryptionHelper = __webpack_require__(/*! ./encryption-helper.js */ \"(action-browser)/./node_modules/web-push/src/encryption-helper.js\");\nconst WebPushLib = __webpack_require__(/*! ./web-push-lib.js */ \"(action-browser)/./node_modules/web-push/src/web-push-lib.js\");\nconst WebPushError = __webpack_require__(/*! ./web-push-error.js */ \"(action-browser)/./node_modules/web-push/src/web-push-error.js\");\nconst WebPushConstants = __webpack_require__(/*! ./web-push-constants.js */ \"(action-browser)/./node_modules/web-push/src/web-push-constants.js\");\n\nconst webPush = new WebPushLib();\n\nmodule.exports = {\n  WebPushError: WebPushError,\n  supportedContentEncodings: WebPushConstants.supportedContentEncodings,\n  encrypt: encryptionHelper.encrypt,\n  getVapidHeaders: vapidHelper.getVapidHeaders,\n  generateVAPIDKeys: vapidHelper.generateVAPIDKeys,\n  setGCMAPIKey: webPush.setGCMAPIKey,\n  setVapidDetails: webPush.setVapidDetails,\n  generateRequestDetails: webPush.generateRequestDetails,\n  sendNotification: webPush.sendNotification.bind(webPush)\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy93ZWItcHVzaC9zcmMvaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsb0JBQW9CLG1CQUFPLENBQUMsdUZBQW1CO0FBQy9DLHlCQUF5QixtQkFBTyxDQUFDLGlHQUF3QjtBQUN6RCxtQkFBbUIsbUJBQU8sQ0FBQyx1RkFBbUI7QUFDOUMscUJBQXFCLG1CQUFPLENBQUMsMkZBQXFCO0FBQ2xELHlCQUF5QixtQkFBTyxDQUFDLG1HQUF5Qjs7QUFFMUQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiRDpcXGFwbGljYWNpb25lcy1pYVxcbmV4dC10YXNrXFxub2RlX21vZHVsZXNcXHdlYi1wdXNoXFxzcmNcXGluZGV4LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuY29uc3QgdmFwaWRIZWxwZXIgPSByZXF1aXJlKCcuL3ZhcGlkLWhlbHBlci5qcycpO1xuY29uc3QgZW5jcnlwdGlvbkhlbHBlciA9IHJlcXVpcmUoJy4vZW5jcnlwdGlvbi1oZWxwZXIuanMnKTtcbmNvbnN0IFdlYlB1c2hMaWIgPSByZXF1aXJlKCcuL3dlYi1wdXNoLWxpYi5qcycpO1xuY29uc3QgV2ViUHVzaEVycm9yID0gcmVxdWlyZSgnLi93ZWItcHVzaC1lcnJvci5qcycpO1xuY29uc3QgV2ViUHVzaENvbnN0YW50cyA9IHJlcXVpcmUoJy4vd2ViLXB1c2gtY29uc3RhbnRzLmpzJyk7XG5cbmNvbnN0IHdlYlB1c2ggPSBuZXcgV2ViUHVzaExpYigpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgV2ViUHVzaEVycm9yOiBXZWJQdXNoRXJyb3IsXG4gIHN1cHBvcnRlZENvbnRlbnRFbmNvZGluZ3M6IFdlYlB1c2hDb25zdGFudHMuc3VwcG9ydGVkQ29udGVudEVuY29kaW5ncyxcbiAgZW5jcnlwdDogZW5jcnlwdGlvbkhlbHBlci5lbmNyeXB0LFxuICBnZXRWYXBpZEhlYWRlcnM6IHZhcGlkSGVscGVyLmdldFZhcGlkSGVhZGVycyxcbiAgZ2VuZXJhdGVWQVBJREtleXM6IHZhcGlkSGVscGVyLmdlbmVyYXRlVkFQSURLZXlzLFxuICBzZXRHQ01BUElLZXk6IHdlYlB1c2guc2V0R0NNQVBJS2V5LFxuICBzZXRWYXBpZERldGFpbHM6IHdlYlB1c2guc2V0VmFwaWREZXRhaWxzLFxuICBnZW5lcmF0ZVJlcXVlc3REZXRhaWxzOiB3ZWJQdXNoLmdlbmVyYXRlUmVxdWVzdERldGFpbHMsXG4gIHNlbmROb3RpZmljYXRpb246IHdlYlB1c2guc2VuZE5vdGlmaWNhdGlvbi5iaW5kKHdlYlB1c2gpXG59O1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/web-push/src/index.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/web-push/src/urlsafe-base64-helper.js":
/*!************************************************************!*\
  !*** ./node_modules/web-push/src/urlsafe-base64-helper.js ***!
  \************************************************************/
/***/ ((module) => {

eval("\n\n/**\n * @param {string} base64\n * @returns {boolean}\n */\nfunction validate(base64) {\n  return /^[A-Za-z0-9\\-_]+$/.test(base64);\n}\n\nmodule.exports = {\n  validate: validate\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy93ZWItcHVzaC9zcmMvdXJsc2FmZS1iYXNlNjQtaGVscGVyLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIkQ6XFxhcGxpY2FjaW9uZXMtaWFcXG5leHQtdGFza1xcbm9kZV9tb2R1bGVzXFx3ZWItcHVzaFxcc3JjXFx1cmxzYWZlLWJhc2U2NC1oZWxwZXIuanMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSBiYXNlNjRcbiAqIEByZXR1cm5zIHtib29sZWFufVxuICovXG5mdW5jdGlvbiB2YWxpZGF0ZShiYXNlNjQpIHtcbiAgcmV0dXJuIC9eW0EtWmEtejAtOVxcLV9dKyQvLnRlc3QoYmFzZTY0KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIHZhbGlkYXRlOiB2YWxpZGF0ZVxufTtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/web-push/src/urlsafe-base64-helper.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/web-push/src/vapid-helper.js":
/*!***************************************************!*\
  !*** ./node_modules/web-push/src/vapid-helper.js ***!
  \***************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nconst crypto = __webpack_require__(/*! crypto */ \"crypto\");\nconst asn1 = __webpack_require__(/*! asn1.js */ \"(action-browser)/./node_modules/asn1.js/lib/asn1.js\");\nconst jws = __webpack_require__(/*! jws */ \"(action-browser)/./node_modules/jws/index.js\");\nconst { URL } = __webpack_require__(/*! url */ \"url\");\n\nconst WebPushConstants = __webpack_require__(/*! ./web-push-constants.js */ \"(action-browser)/./node_modules/web-push/src/web-push-constants.js\");\nconst urlBase64Helper = __webpack_require__(/*! ./urlsafe-base64-helper */ \"(action-browser)/./node_modules/web-push/src/urlsafe-base64-helper.js\");\n\n/**\n * DEFAULT_EXPIRATION is set to seconds in 12 hours\n */\nconst DEFAULT_EXPIRATION_SECONDS = 12 * 60 * 60;\n\n// Maximum expiration is 24 hours according. (See VAPID spec)\nconst MAX_EXPIRATION_SECONDS = 24 * 60 * 60;\n\nconst ECPrivateKeyASN = asn1.define('ECPrivateKey', function() {\n  this.seq().obj(\n    this.key('version').int(),\n    this.key('privateKey').octstr(),\n    this.key('parameters').explicit(0).objid()\n      .optional(),\n    this.key('publicKey').explicit(1).bitstr()\n      .optional()\n  );\n});\n\nfunction toPEM(key) {\n  return ECPrivateKeyASN.encode({\n    version: 1,\n    privateKey: key,\n    parameters: [1, 2, 840, 10045, 3, 1, 7] // prime256v1\n  }, 'pem', {\n    label: 'EC PRIVATE KEY'\n  });\n}\n\nfunction generateVAPIDKeys() {\n  const curve = crypto.createECDH('prime256v1');\n  curve.generateKeys();\n\n  let publicKeyBuffer = curve.getPublicKey();\n  let privateKeyBuffer = curve.getPrivateKey();\n\n  // Occassionally the keys will not be padded to the correct lengh resulting\n  // in errors, hence this padding.\n  // See https://github.com/web-push-libs/web-push/issues/295 for history.\n  if (privateKeyBuffer.length < 32) {\n    const padding = Buffer.alloc(32 - privateKeyBuffer.length);\n    padding.fill(0);\n    privateKeyBuffer = Buffer.concat([padding, privateKeyBuffer]);\n  }\n\n  if (publicKeyBuffer.length < 65) {\n    const padding = Buffer.alloc(65 - publicKeyBuffer.length);\n    padding.fill(0);\n    publicKeyBuffer = Buffer.concat([padding, publicKeyBuffer]);\n  }\n\n  return {\n    publicKey: publicKeyBuffer.toString('base64url'),\n    privateKey: privateKeyBuffer.toString('base64url')\n  };\n}\n\nfunction validateSubject(subject) {\n  if (!subject) {\n    throw new Error('No subject set in vapidDetails.subject.');\n  }\n\n  if (typeof subject !== 'string' || subject.length === 0) {\n    throw new Error('The subject value must be a string containing an https: URL or '\n    + 'mailto: address. ' + subject);\n  }\n\n  let subjectParseResult = null;\n  try {\n    subjectParseResult = new URL(subject);\n  } catch (err) {\n    throw new Error('Vapid subject is not a valid URL. ' + subject);\n  }\n  if (!['https:', 'mailto:'].includes(subjectParseResult.protocol)) {\n    throw new Error('Vapid subject is not an https: or mailto: URL. ' + subject);\n  }\n  if (subjectParseResult.hostname === 'localhost') {\n    console.warn('Vapid subject points to a localhost web URI, which is unsupported by '\n      + 'Apple\\'s push notification server and will result in a BadJwtToken error when '\n      + 'sending notifications.');\n    }\n}\n\nfunction validatePublicKey(publicKey) {\n  if (!publicKey) {\n    throw new Error('No key set vapidDetails.publicKey');\n  }\n\n  if (typeof publicKey !== 'string') {\n    throw new Error('Vapid public key is must be a URL safe Base 64 '\n    + 'encoded string.');\n  }\n\n  if (!urlBase64Helper.validate(publicKey)) {\n    throw new Error('Vapid public key must be a URL safe Base 64 (without \"=\")');\n  }\n\n  publicKey = Buffer.from(publicKey, 'base64url');\n\n  if (publicKey.length !== 65) {\n    throw new Error('Vapid public key should be 65 bytes long when decoded.');\n  }\n}\n\nfunction validatePrivateKey(privateKey) {\n  if (!privateKey) {\n    throw new Error('No key set in vapidDetails.privateKey');\n  }\n\n  if (typeof privateKey !== 'string') {\n    throw new Error('Vapid private key must be a URL safe Base 64 '\n    + 'encoded string.');\n  }\n\n  if (!urlBase64Helper.validate(privateKey)) {\n    throw new Error('Vapid private key must be a URL safe Base 64 (without \"=\")');\n  }\n\n  privateKey = Buffer.from(privateKey, 'base64url');\n\n  if (privateKey.length !== 32) {\n    throw new Error('Vapid private key should be 32 bytes long when decoded.');\n  }\n}\n\n/**\n * Given the number of seconds calculates\n * the expiration in the future by adding the passed `numSeconds`\n * with the current seconds from Unix Epoch\n *\n * @param {Number} numSeconds Number of seconds to be added\n * @return {Number} Future expiration in seconds\n */\nfunction getFutureExpirationTimestamp(numSeconds) {\n  const futureExp = new Date();\n  futureExp.setSeconds(futureExp.getSeconds() + numSeconds);\n  return Math.floor(futureExp.getTime() / 1000);\n}\n\n/**\n * Validates the Expiration Header based on the VAPID Spec\n * Throws error of type `Error` if the expiration is not validated\n *\n * @param {Number} expiration Expiration seconds from Epoch to be validated\n */\nfunction validateExpiration(expiration) {\n  if (!Number.isInteger(expiration)) {\n    throw new Error('`expiration` value must be a number');\n  }\n\n  if (expiration < 0) {\n    throw new Error('`expiration` must be a positive integer');\n  }\n\n  // Roughly checks the time of expiration, since the max expiration can be ahead\n  // of the time than at the moment the expiration was generated\n  const maxExpirationTimestamp = getFutureExpirationTimestamp(MAX_EXPIRATION_SECONDS);\n\n  if (expiration >= maxExpirationTimestamp) {\n    throw new Error('`expiration` value is greater than maximum of 24 hours');\n  }\n}\n\n/**\n * This method takes the required VAPID parameters and returns the required\n * header to be added to a Web Push Protocol Request.\n * @param  {string} audience        This must be the origin of the push service.\n * @param  {string} subject         This should be a URL or a 'mailto:' email\n * address.\n * @param  {string} publicKey       The VAPID public key.\n * @param  {string} privateKey      The VAPID private key.\n * @param  {string} contentEncoding The contentEncoding type.\n * @param  {integer} [expiration]   The expiration of the VAPID JWT.\n * @return {Object}                 Returns an Object with the Authorization and\n * 'Crypto-Key' values to be used as headers.\n */\nfunction getVapidHeaders(audience, subject, publicKey, privateKey, contentEncoding, expiration) {\n  if (!audience) {\n    throw new Error('No audience could be generated for VAPID.');\n  }\n\n  if (typeof audience !== 'string' || audience.length === 0) {\n    throw new Error('The audience value must be a string containing the '\n    + 'origin of a push service. ' + audience);\n  }\n\n  try {\n    new URL(audience); // eslint-disable-line no-new\n  } catch (err) {\n    throw new Error('VAPID audience is not a url. ' + audience);\n  }\n\n  validateSubject(subject);\n  validatePublicKey(publicKey);\n  validatePrivateKey(privateKey);\n\n  privateKey = Buffer.from(privateKey, 'base64url');\n\n  if (expiration) {\n    validateExpiration(expiration);\n  } else {\n    expiration = getFutureExpirationTimestamp(DEFAULT_EXPIRATION_SECONDS);\n  }\n\n  const header = {\n    typ: 'JWT',\n    alg: 'ES256'\n  };\n\n  const jwtPayload = {\n    aud: audience,\n    exp: expiration,\n    sub: subject\n  };\n\n  const jwt = jws.sign({\n    header: header,\n    payload: jwtPayload,\n    privateKey: toPEM(privateKey)\n  });\n\n  if (contentEncoding === WebPushConstants.supportedContentEncodings.AES_128_GCM) {\n    return {\n      Authorization: 'vapid t=' + jwt + ', k=' + publicKey\n    };\n  }\n  if (contentEncoding === WebPushConstants.supportedContentEncodings.AES_GCM) {\n    return {\n      Authorization: 'WebPush ' + jwt,\n      'Crypto-Key': 'p256ecdsa=' + publicKey\n    };\n  }\n\n  throw new Error('Unsupported encoding type specified.');\n}\n\nmodule.exports = {\n  generateVAPIDKeys: generateVAPIDKeys,\n  getFutureExpirationTimestamp: getFutureExpirationTimestamp,\n  getVapidHeaders: getVapidHeaders,\n  validateSubject: validateSubject,\n  validatePublicKey: validatePublicKey,\n  validatePrivateKey: validatePrivateKey,\n  validateExpiration: validateExpiration\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy93ZWItcHVzaC9zcmMvdmFwaWQtaGVscGVyLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLGVBQWUsbUJBQU8sQ0FBQyxzQkFBUTtBQUMvQixhQUFhLG1CQUFPLENBQUMsb0VBQVM7QUFDOUIsWUFBWSxtQkFBTyxDQUFDLHlEQUFLO0FBQ3pCLFFBQVEsTUFBTSxFQUFFLG1CQUFPLENBQUMsZ0JBQUs7O0FBRTdCLHlCQUF5QixtQkFBTyxDQUFDLG1HQUF5QjtBQUMxRCx3QkFBd0IsbUJBQU8sQ0FBQyxzR0FBeUI7O0FBRXpEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixZQUFZLFFBQVE7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLFFBQVE7QUFDcEIsWUFBWSxRQUFRO0FBQ3BCO0FBQ0EsWUFBWSxRQUFRO0FBQ3BCLFlBQVksUUFBUTtBQUNwQixZQUFZLFFBQVE7QUFDcEIsWUFBWSxTQUFTO0FBQ3JCLFlBQVksd0JBQXdCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHVCQUF1QjtBQUN2QixJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIkQ6XFxhcGxpY2FjaW9uZXMtaWFcXG5leHQtdGFza1xcbm9kZV9tb2R1bGVzXFx3ZWItcHVzaFxcc3JjXFx2YXBpZC1oZWxwZXIuanMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBjcnlwdG8gPSByZXF1aXJlKCdjcnlwdG8nKTtcbmNvbnN0IGFzbjEgPSByZXF1aXJlKCdhc24xLmpzJyk7XG5jb25zdCBqd3MgPSByZXF1aXJlKCdqd3MnKTtcbmNvbnN0IHsgVVJMIH0gPSByZXF1aXJlKCd1cmwnKTtcblxuY29uc3QgV2ViUHVzaENvbnN0YW50cyA9IHJlcXVpcmUoJy4vd2ViLXB1c2gtY29uc3RhbnRzLmpzJyk7XG5jb25zdCB1cmxCYXNlNjRIZWxwZXIgPSByZXF1aXJlKCcuL3VybHNhZmUtYmFzZTY0LWhlbHBlcicpO1xuXG4vKipcbiAqIERFRkFVTFRfRVhQSVJBVElPTiBpcyBzZXQgdG8gc2Vjb25kcyBpbiAxMiBob3Vyc1xuICovXG5jb25zdCBERUZBVUxUX0VYUElSQVRJT05fU0VDT05EUyA9IDEyICogNjAgKiA2MDtcblxuLy8gTWF4aW11bSBleHBpcmF0aW9uIGlzIDI0IGhvdXJzIGFjY29yZGluZy4gKFNlZSBWQVBJRCBzcGVjKVxuY29uc3QgTUFYX0VYUElSQVRJT05fU0VDT05EUyA9IDI0ICogNjAgKiA2MDtcblxuY29uc3QgRUNQcml2YXRlS2V5QVNOID0gYXNuMS5kZWZpbmUoJ0VDUHJpdmF0ZUtleScsIGZ1bmN0aW9uKCkge1xuICB0aGlzLnNlcSgpLm9iaihcbiAgICB0aGlzLmtleSgndmVyc2lvbicpLmludCgpLFxuICAgIHRoaXMua2V5KCdwcml2YXRlS2V5Jykub2N0c3RyKCksXG4gICAgdGhpcy5rZXkoJ3BhcmFtZXRlcnMnKS5leHBsaWNpdCgwKS5vYmppZCgpXG4gICAgICAub3B0aW9uYWwoKSxcbiAgICB0aGlzLmtleSgncHVibGljS2V5JykuZXhwbGljaXQoMSkuYml0c3RyKClcbiAgICAgIC5vcHRpb25hbCgpXG4gICk7XG59KTtcblxuZnVuY3Rpb24gdG9QRU0oa2V5KSB7XG4gIHJldHVybiBFQ1ByaXZhdGVLZXlBU04uZW5jb2RlKHtcbiAgICB2ZXJzaW9uOiAxLFxuICAgIHByaXZhdGVLZXk6IGtleSxcbiAgICBwYXJhbWV0ZXJzOiBbMSwgMiwgODQwLCAxMDA0NSwgMywgMSwgN10gLy8gcHJpbWUyNTZ2MVxuICB9LCAncGVtJywge1xuICAgIGxhYmVsOiAnRUMgUFJJVkFURSBLRVknXG4gIH0pO1xufVxuXG5mdW5jdGlvbiBnZW5lcmF0ZVZBUElES2V5cygpIHtcbiAgY29uc3QgY3VydmUgPSBjcnlwdG8uY3JlYXRlRUNESCgncHJpbWUyNTZ2MScpO1xuICBjdXJ2ZS5nZW5lcmF0ZUtleXMoKTtcblxuICBsZXQgcHVibGljS2V5QnVmZmVyID0gY3VydmUuZ2V0UHVibGljS2V5KCk7XG4gIGxldCBwcml2YXRlS2V5QnVmZmVyID0gY3VydmUuZ2V0UHJpdmF0ZUtleSgpO1xuXG4gIC8vIE9jY2Fzc2lvbmFsbHkgdGhlIGtleXMgd2lsbCBub3QgYmUgcGFkZGVkIHRvIHRoZSBjb3JyZWN0IGxlbmdoIHJlc3VsdGluZ1xuICAvLyBpbiBlcnJvcnMsIGhlbmNlIHRoaXMgcGFkZGluZy5cbiAgLy8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS93ZWItcHVzaC1saWJzL3dlYi1wdXNoL2lzc3Vlcy8yOTUgZm9yIGhpc3RvcnkuXG4gIGlmIChwcml2YXRlS2V5QnVmZmVyLmxlbmd0aCA8IDMyKSB7XG4gICAgY29uc3QgcGFkZGluZyA9IEJ1ZmZlci5hbGxvYygzMiAtIHByaXZhdGVLZXlCdWZmZXIubGVuZ3RoKTtcbiAgICBwYWRkaW5nLmZpbGwoMCk7XG4gICAgcHJpdmF0ZUtleUJ1ZmZlciA9IEJ1ZmZlci5jb25jYXQoW3BhZGRpbmcsIHByaXZhdGVLZXlCdWZmZXJdKTtcbiAgfVxuXG4gIGlmIChwdWJsaWNLZXlCdWZmZXIubGVuZ3RoIDwgNjUpIHtcbiAgICBjb25zdCBwYWRkaW5nID0gQnVmZmVyLmFsbG9jKDY1IC0gcHVibGljS2V5QnVmZmVyLmxlbmd0aCk7XG4gICAgcGFkZGluZy5maWxsKDApO1xuICAgIHB1YmxpY0tleUJ1ZmZlciA9IEJ1ZmZlci5jb25jYXQoW3BhZGRpbmcsIHB1YmxpY0tleUJ1ZmZlcl0pO1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBwdWJsaWNLZXk6IHB1YmxpY0tleUJ1ZmZlci50b1N0cmluZygnYmFzZTY0dXJsJyksXG4gICAgcHJpdmF0ZUtleTogcHJpdmF0ZUtleUJ1ZmZlci50b1N0cmluZygnYmFzZTY0dXJsJylcbiAgfTtcbn1cblxuZnVuY3Rpb24gdmFsaWRhdGVTdWJqZWN0KHN1YmplY3QpIHtcbiAgaWYgKCFzdWJqZWN0KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdObyBzdWJqZWN0IHNldCBpbiB2YXBpZERldGFpbHMuc3ViamVjdC4nKTtcbiAgfVxuXG4gIGlmICh0eXBlb2Ygc3ViamVjdCAhPT0gJ3N0cmluZycgfHwgc3ViamVjdC5sZW5ndGggPT09IDApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoZSBzdWJqZWN0IHZhbHVlIG11c3QgYmUgYSBzdHJpbmcgY29udGFpbmluZyBhbiBodHRwczogVVJMIG9yICdcbiAgICArICdtYWlsdG86IGFkZHJlc3MuICcgKyBzdWJqZWN0KTtcbiAgfVxuXG4gIGxldCBzdWJqZWN0UGFyc2VSZXN1bHQgPSBudWxsO1xuICB0cnkge1xuICAgIHN1YmplY3RQYXJzZVJlc3VsdCA9IG5ldyBVUkwoc3ViamVjdCk7XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIHRocm93IG5ldyBFcnJvcignVmFwaWQgc3ViamVjdCBpcyBub3QgYSB2YWxpZCBVUkwuICcgKyBzdWJqZWN0KTtcbiAgfVxuICBpZiAoIVsnaHR0cHM6JywgJ21haWx0bzonXS5pbmNsdWRlcyhzdWJqZWN0UGFyc2VSZXN1bHQucHJvdG9jb2wpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdWYXBpZCBzdWJqZWN0IGlzIG5vdCBhbiBodHRwczogb3IgbWFpbHRvOiBVUkwuICcgKyBzdWJqZWN0KTtcbiAgfVxuICBpZiAoc3ViamVjdFBhcnNlUmVzdWx0Lmhvc3RuYW1lID09PSAnbG9jYWxob3N0Jykge1xuICAgIGNvbnNvbGUud2FybignVmFwaWQgc3ViamVjdCBwb2ludHMgdG8gYSBsb2NhbGhvc3Qgd2ViIFVSSSwgd2hpY2ggaXMgdW5zdXBwb3J0ZWQgYnkgJ1xuICAgICAgKyAnQXBwbGVcXCdzIHB1c2ggbm90aWZpY2F0aW9uIHNlcnZlciBhbmQgd2lsbCByZXN1bHQgaW4gYSBCYWRKd3RUb2tlbiBlcnJvciB3aGVuICdcbiAgICAgICsgJ3NlbmRpbmcgbm90aWZpY2F0aW9ucy4nKTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIHZhbGlkYXRlUHVibGljS2V5KHB1YmxpY0tleSkge1xuICBpZiAoIXB1YmxpY0tleSkge1xuICAgIHRocm93IG5ldyBFcnJvcignTm8ga2V5IHNldCB2YXBpZERldGFpbHMucHVibGljS2V5Jyk7XG4gIH1cblxuICBpZiAodHlwZW9mIHB1YmxpY0tleSAhPT0gJ3N0cmluZycpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1ZhcGlkIHB1YmxpYyBrZXkgaXMgbXVzdCBiZSBhIFVSTCBzYWZlIEJhc2UgNjQgJ1xuICAgICsgJ2VuY29kZWQgc3RyaW5nLicpO1xuICB9XG5cbiAgaWYgKCF1cmxCYXNlNjRIZWxwZXIudmFsaWRhdGUocHVibGljS2V5KSkge1xuICAgIHRocm93IG5ldyBFcnJvcignVmFwaWQgcHVibGljIGtleSBtdXN0IGJlIGEgVVJMIHNhZmUgQmFzZSA2NCAod2l0aG91dCBcIj1cIiknKTtcbiAgfVxuXG4gIHB1YmxpY0tleSA9IEJ1ZmZlci5mcm9tKHB1YmxpY0tleSwgJ2Jhc2U2NHVybCcpO1xuXG4gIGlmIChwdWJsaWNLZXkubGVuZ3RoICE9PSA2NSkge1xuICAgIHRocm93IG5ldyBFcnJvcignVmFwaWQgcHVibGljIGtleSBzaG91bGQgYmUgNjUgYnl0ZXMgbG9uZyB3aGVuIGRlY29kZWQuJyk7XG4gIH1cbn1cblxuZnVuY3Rpb24gdmFsaWRhdGVQcml2YXRlS2V5KHByaXZhdGVLZXkpIHtcbiAgaWYgKCFwcml2YXRlS2V5KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdObyBrZXkgc2V0IGluIHZhcGlkRGV0YWlscy5wcml2YXRlS2V5Jyk7XG4gIH1cblxuICBpZiAodHlwZW9mIHByaXZhdGVLZXkgIT09ICdzdHJpbmcnKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdWYXBpZCBwcml2YXRlIGtleSBtdXN0IGJlIGEgVVJMIHNhZmUgQmFzZSA2NCAnXG4gICAgKyAnZW5jb2RlZCBzdHJpbmcuJyk7XG4gIH1cblxuICBpZiAoIXVybEJhc2U2NEhlbHBlci52YWxpZGF0ZShwcml2YXRlS2V5KSkge1xuICAgIHRocm93IG5ldyBFcnJvcignVmFwaWQgcHJpdmF0ZSBrZXkgbXVzdCBiZSBhIFVSTCBzYWZlIEJhc2UgNjQgKHdpdGhvdXQgXCI9XCIpJyk7XG4gIH1cblxuICBwcml2YXRlS2V5ID0gQnVmZmVyLmZyb20ocHJpdmF0ZUtleSwgJ2Jhc2U2NHVybCcpO1xuXG4gIGlmIChwcml2YXRlS2V5Lmxlbmd0aCAhPT0gMzIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1ZhcGlkIHByaXZhdGUga2V5IHNob3VsZCBiZSAzMiBieXRlcyBsb25nIHdoZW4gZGVjb2RlZC4nKTtcbiAgfVxufVxuXG4vKipcbiAqIEdpdmVuIHRoZSBudW1iZXIgb2Ygc2Vjb25kcyBjYWxjdWxhdGVzXG4gKiB0aGUgZXhwaXJhdGlvbiBpbiB0aGUgZnV0dXJlIGJ5IGFkZGluZyB0aGUgcGFzc2VkIGBudW1TZWNvbmRzYFxuICogd2l0aCB0aGUgY3VycmVudCBzZWNvbmRzIGZyb20gVW5peCBFcG9jaFxuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSBudW1TZWNvbmRzIE51bWJlciBvZiBzZWNvbmRzIHRvIGJlIGFkZGVkXG4gKiBAcmV0dXJuIHtOdW1iZXJ9IEZ1dHVyZSBleHBpcmF0aW9uIGluIHNlY29uZHNcbiAqL1xuZnVuY3Rpb24gZ2V0RnV0dXJlRXhwaXJhdGlvblRpbWVzdGFtcChudW1TZWNvbmRzKSB7XG4gIGNvbnN0IGZ1dHVyZUV4cCA9IG5ldyBEYXRlKCk7XG4gIGZ1dHVyZUV4cC5zZXRTZWNvbmRzKGZ1dHVyZUV4cC5nZXRTZWNvbmRzKCkgKyBudW1TZWNvbmRzKTtcbiAgcmV0dXJuIE1hdGguZmxvb3IoZnV0dXJlRXhwLmdldFRpbWUoKSAvIDEwMDApO1xufVxuXG4vKipcbiAqIFZhbGlkYXRlcyB0aGUgRXhwaXJhdGlvbiBIZWFkZXIgYmFzZWQgb24gdGhlIFZBUElEIFNwZWNcbiAqIFRocm93cyBlcnJvciBvZiB0eXBlIGBFcnJvcmAgaWYgdGhlIGV4cGlyYXRpb24gaXMgbm90IHZhbGlkYXRlZFxuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSBleHBpcmF0aW9uIEV4cGlyYXRpb24gc2Vjb25kcyBmcm9tIEVwb2NoIHRvIGJlIHZhbGlkYXRlZFxuICovXG5mdW5jdGlvbiB2YWxpZGF0ZUV4cGlyYXRpb24oZXhwaXJhdGlvbikge1xuICBpZiAoIU51bWJlci5pc0ludGVnZXIoZXhwaXJhdGlvbikpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2BleHBpcmF0aW9uYCB2YWx1ZSBtdXN0IGJlIGEgbnVtYmVyJyk7XG4gIH1cblxuICBpZiAoZXhwaXJhdGlvbiA8IDApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2BleHBpcmF0aW9uYCBtdXN0IGJlIGEgcG9zaXRpdmUgaW50ZWdlcicpO1xuICB9XG5cbiAgLy8gUm91Z2hseSBjaGVja3MgdGhlIHRpbWUgb2YgZXhwaXJhdGlvbiwgc2luY2UgdGhlIG1heCBleHBpcmF0aW9uIGNhbiBiZSBhaGVhZFxuICAvLyBvZiB0aGUgdGltZSB0aGFuIGF0IHRoZSBtb21lbnQgdGhlIGV4cGlyYXRpb24gd2FzIGdlbmVyYXRlZFxuICBjb25zdCBtYXhFeHBpcmF0aW9uVGltZXN0YW1wID0gZ2V0RnV0dXJlRXhwaXJhdGlvblRpbWVzdGFtcChNQVhfRVhQSVJBVElPTl9TRUNPTkRTKTtcblxuICBpZiAoZXhwaXJhdGlvbiA+PSBtYXhFeHBpcmF0aW9uVGltZXN0YW1wKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdgZXhwaXJhdGlvbmAgdmFsdWUgaXMgZ3JlYXRlciB0aGFuIG1heGltdW0gb2YgMjQgaG91cnMnKTtcbiAgfVxufVxuXG4vKipcbiAqIFRoaXMgbWV0aG9kIHRha2VzIHRoZSByZXF1aXJlZCBWQVBJRCBwYXJhbWV0ZXJzIGFuZCByZXR1cm5zIHRoZSByZXF1aXJlZFxuICogaGVhZGVyIHRvIGJlIGFkZGVkIHRvIGEgV2ViIFB1c2ggUHJvdG9jb2wgUmVxdWVzdC5cbiAqIEBwYXJhbSAge3N0cmluZ30gYXVkaWVuY2UgICAgICAgIFRoaXMgbXVzdCBiZSB0aGUgb3JpZ2luIG9mIHRoZSBwdXNoIHNlcnZpY2UuXG4gKiBAcGFyYW0gIHtzdHJpbmd9IHN1YmplY3QgICAgICAgICBUaGlzIHNob3VsZCBiZSBhIFVSTCBvciBhICdtYWlsdG86JyBlbWFpbFxuICogYWRkcmVzcy5cbiAqIEBwYXJhbSAge3N0cmluZ30gcHVibGljS2V5ICAgICAgIFRoZSBWQVBJRCBwdWJsaWMga2V5LlxuICogQHBhcmFtICB7c3RyaW5nfSBwcml2YXRlS2V5ICAgICAgVGhlIFZBUElEIHByaXZhdGUga2V5LlxuICogQHBhcmFtICB7c3RyaW5nfSBjb250ZW50RW5jb2RpbmcgVGhlIGNvbnRlbnRFbmNvZGluZyB0eXBlLlxuICogQHBhcmFtICB7aW50ZWdlcn0gW2V4cGlyYXRpb25dICAgVGhlIGV4cGlyYXRpb24gb2YgdGhlIFZBUElEIEpXVC5cbiAqIEByZXR1cm4ge09iamVjdH0gICAgICAgICAgICAgICAgIFJldHVybnMgYW4gT2JqZWN0IHdpdGggdGhlIEF1dGhvcml6YXRpb24gYW5kXG4gKiAnQ3J5cHRvLUtleScgdmFsdWVzIHRvIGJlIHVzZWQgYXMgaGVhZGVycy5cbiAqL1xuZnVuY3Rpb24gZ2V0VmFwaWRIZWFkZXJzKGF1ZGllbmNlLCBzdWJqZWN0LCBwdWJsaWNLZXksIHByaXZhdGVLZXksIGNvbnRlbnRFbmNvZGluZywgZXhwaXJhdGlvbikge1xuICBpZiAoIWF1ZGllbmNlKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdObyBhdWRpZW5jZSBjb3VsZCBiZSBnZW5lcmF0ZWQgZm9yIFZBUElELicpO1xuICB9XG5cbiAgaWYgKHR5cGVvZiBhdWRpZW5jZSAhPT0gJ3N0cmluZycgfHwgYXVkaWVuY2UubGVuZ3RoID09PSAwKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdUaGUgYXVkaWVuY2UgdmFsdWUgbXVzdCBiZSBhIHN0cmluZyBjb250YWluaW5nIHRoZSAnXG4gICAgKyAnb3JpZ2luIG9mIGEgcHVzaCBzZXJ2aWNlLiAnICsgYXVkaWVuY2UpO1xuICB9XG5cbiAgdHJ5IHtcbiAgICBuZXcgVVJMKGF1ZGllbmNlKTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1uZXdcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdWQVBJRCBhdWRpZW5jZSBpcyBub3QgYSB1cmwuICcgKyBhdWRpZW5jZSk7XG4gIH1cblxuICB2YWxpZGF0ZVN1YmplY3Qoc3ViamVjdCk7XG4gIHZhbGlkYXRlUHVibGljS2V5KHB1YmxpY0tleSk7XG4gIHZhbGlkYXRlUHJpdmF0ZUtleShwcml2YXRlS2V5KTtcblxuICBwcml2YXRlS2V5ID0gQnVmZmVyLmZyb20ocHJpdmF0ZUtleSwgJ2Jhc2U2NHVybCcpO1xuXG4gIGlmIChleHBpcmF0aW9uKSB7XG4gICAgdmFsaWRhdGVFeHBpcmF0aW9uKGV4cGlyYXRpb24pO1xuICB9IGVsc2Uge1xuICAgIGV4cGlyYXRpb24gPSBnZXRGdXR1cmVFeHBpcmF0aW9uVGltZXN0YW1wKERFRkFVTFRfRVhQSVJBVElPTl9TRUNPTkRTKTtcbiAgfVxuXG4gIGNvbnN0IGhlYWRlciA9IHtcbiAgICB0eXA6ICdKV1QnLFxuICAgIGFsZzogJ0VTMjU2J1xuICB9O1xuXG4gIGNvbnN0IGp3dFBheWxvYWQgPSB7XG4gICAgYXVkOiBhdWRpZW5jZSxcbiAgICBleHA6IGV4cGlyYXRpb24sXG4gICAgc3ViOiBzdWJqZWN0XG4gIH07XG5cbiAgY29uc3Qgand0ID0gandzLnNpZ24oe1xuICAgIGhlYWRlcjogaGVhZGVyLFxuICAgIHBheWxvYWQ6IGp3dFBheWxvYWQsXG4gICAgcHJpdmF0ZUtleTogdG9QRU0ocHJpdmF0ZUtleSlcbiAgfSk7XG5cbiAgaWYgKGNvbnRlbnRFbmNvZGluZyA9PT0gV2ViUHVzaENvbnN0YW50cy5zdXBwb3J0ZWRDb250ZW50RW5jb2RpbmdzLkFFU18xMjhfR0NNKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIEF1dGhvcml6YXRpb246ICd2YXBpZCB0PScgKyBqd3QgKyAnLCBrPScgKyBwdWJsaWNLZXlcbiAgICB9O1xuICB9XG4gIGlmIChjb250ZW50RW5jb2RpbmcgPT09IFdlYlB1c2hDb25zdGFudHMuc3VwcG9ydGVkQ29udGVudEVuY29kaW5ncy5BRVNfR0NNKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIEF1dGhvcml6YXRpb246ICdXZWJQdXNoICcgKyBqd3QsXG4gICAgICAnQ3J5cHRvLUtleSc6ICdwMjU2ZWNkc2E9JyArIHB1YmxpY0tleVxuICAgIH07XG4gIH1cblxuICB0aHJvdyBuZXcgRXJyb3IoJ1Vuc3VwcG9ydGVkIGVuY29kaW5nIHR5cGUgc3BlY2lmaWVkLicpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgZ2VuZXJhdGVWQVBJREtleXM6IGdlbmVyYXRlVkFQSURLZXlzLFxuICBnZXRGdXR1cmVFeHBpcmF0aW9uVGltZXN0YW1wOiBnZXRGdXR1cmVFeHBpcmF0aW9uVGltZXN0YW1wLFxuICBnZXRWYXBpZEhlYWRlcnM6IGdldFZhcGlkSGVhZGVycyxcbiAgdmFsaWRhdGVTdWJqZWN0OiB2YWxpZGF0ZVN1YmplY3QsXG4gIHZhbGlkYXRlUHVibGljS2V5OiB2YWxpZGF0ZVB1YmxpY0tleSxcbiAgdmFsaWRhdGVQcml2YXRlS2V5OiB2YWxpZGF0ZVByaXZhdGVLZXksXG4gIHZhbGlkYXRlRXhwaXJhdGlvbjogdmFsaWRhdGVFeHBpcmF0aW9uXG59O1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/web-push/src/vapid-helper.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/web-push/src/web-push-constants.js":
/*!*********************************************************!*\
  !*** ./node_modules/web-push/src/web-push-constants.js ***!
  \*********************************************************/
/***/ ((module) => {

eval("\n\nconst WebPushConstants = {};\n\nWebPushConstants.supportedContentEncodings = {\n  AES_GCM: 'aesgcm',\n  AES_128_GCM: 'aes128gcm'\n};\n\nWebPushConstants.supportedUrgency = {\n  VERY_LOW: 'very-low',\n  LOW: 'low',\n  NORMAL: 'normal',\n  HIGH: 'high'\n};\n\nmodule.exports = WebPushConstants;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy93ZWItcHVzaC9zcmMvd2ViLXB1c2gtY29uc3RhbnRzLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSIsInNvdXJjZXMiOlsiRDpcXGFwbGljYWNpb25lcy1pYVxcbmV4dC10YXNrXFxub2RlX21vZHVsZXNcXHdlYi1wdXNoXFxzcmNcXHdlYi1wdXNoLWNvbnN0YW50cy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbmNvbnN0IFdlYlB1c2hDb25zdGFudHMgPSB7fTtcblxuV2ViUHVzaENvbnN0YW50cy5zdXBwb3J0ZWRDb250ZW50RW5jb2RpbmdzID0ge1xuICBBRVNfR0NNOiAnYWVzZ2NtJyxcbiAgQUVTXzEyOF9HQ006ICdhZXMxMjhnY20nXG59O1xuXG5XZWJQdXNoQ29uc3RhbnRzLnN1cHBvcnRlZFVyZ2VuY3kgPSB7XG4gIFZFUllfTE9XOiAndmVyeS1sb3cnLFxuICBMT1c6ICdsb3cnLFxuICBOT1JNQUw6ICdub3JtYWwnLFxuICBISUdIOiAnaGlnaCdcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gV2ViUHVzaENvbnN0YW50cztcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/web-push/src/web-push-constants.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/web-push/src/web-push-error.js":
/*!*****************************************************!*\
  !*** ./node_modules/web-push/src/web-push-error.js ***!
  \*****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nfunction WebPushError(message, statusCode, headers, body, endpoint) {\n  Error.captureStackTrace(this, this.constructor);\n\n  this.name = this.constructor.name;\n  this.message = message;\n  this.statusCode = statusCode;\n  this.headers = headers;\n  this.body = body;\n  this.endpoint = endpoint;\n}\n\n(__webpack_require__(/*! util */ \"util\").inherits)(WebPushError, Error);\n\nmodule.exports = WebPushError;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy93ZWItcHVzaC9zcmMvd2ViLXB1c2gtZXJyb3IuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxrREFBd0I7O0FBRXhCIiwic291cmNlcyI6WyJEOlxcYXBsaWNhY2lvbmVzLWlhXFxuZXh0LXRhc2tcXG5vZGVfbW9kdWxlc1xcd2ViLXB1c2hcXHNyY1xcd2ViLXB1c2gtZXJyb3IuanMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5mdW5jdGlvbiBXZWJQdXNoRXJyb3IobWVzc2FnZSwgc3RhdHVzQ29kZSwgaGVhZGVycywgYm9keSwgZW5kcG9pbnQpIHtcbiAgRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UodGhpcywgdGhpcy5jb25zdHJ1Y3Rvcik7XG5cbiAgdGhpcy5uYW1lID0gdGhpcy5jb25zdHJ1Y3Rvci5uYW1lO1xuICB0aGlzLm1lc3NhZ2UgPSBtZXNzYWdlO1xuICB0aGlzLnN0YXR1c0NvZGUgPSBzdGF0dXNDb2RlO1xuICB0aGlzLmhlYWRlcnMgPSBoZWFkZXJzO1xuICB0aGlzLmJvZHkgPSBib2R5O1xuICB0aGlzLmVuZHBvaW50ID0gZW5kcG9pbnQ7XG59XG5cbnJlcXVpcmUoJ3V0aWwnKS5pbmhlcml0cyhXZWJQdXNoRXJyb3IsIEVycm9yKTtcblxubW9kdWxlLmV4cG9ydHMgPSBXZWJQdXNoRXJyb3I7XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/web-push/src/web-push-error.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/web-push/src/web-push-lib.js":
/*!***************************************************!*\
  !*** ./node_modules/web-push/src/web-push-lib.js ***!
  \***************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nconst url = __webpack_require__(/*! url */ \"url\");\nconst https = __webpack_require__(/*! https */ \"https\");\n\nconst WebPushError = __webpack_require__(/*! ./web-push-error.js */ \"(action-browser)/./node_modules/web-push/src/web-push-error.js\");\nconst vapidHelper = __webpack_require__(/*! ./vapid-helper.js */ \"(action-browser)/./node_modules/web-push/src/vapid-helper.js\");\nconst encryptionHelper = __webpack_require__(/*! ./encryption-helper.js */ \"(action-browser)/./node_modules/web-push/src/encryption-helper.js\");\nconst webPushConstants = __webpack_require__(/*! ./web-push-constants.js */ \"(action-browser)/./node_modules/web-push/src/web-push-constants.js\");\nconst urlBase64Helper = __webpack_require__(/*! ./urlsafe-base64-helper */ \"(action-browser)/./node_modules/web-push/src/urlsafe-base64-helper.js\");\n\n// Default TTL is four weeks.\nconst DEFAULT_TTL = 2419200;\n\nlet gcmAPIKey = '';\nlet vapidDetails;\n\nfunction WebPushLib() {\n\n}\n\n/**\n * When sending messages to a GCM endpoint you need to set the GCM API key\n * by either calling setGMAPIKey() or passing in the API key as an option\n * to sendNotification().\n * @param  {string} apiKey The API key to send with the GCM request.\n */\nWebPushLib.prototype.setGCMAPIKey = function(apiKey) {\n  if (apiKey === null) {\n    gcmAPIKey = null;\n    return;\n  }\n\n  if (typeof apiKey === 'undefined'\n  || typeof apiKey !== 'string'\n  || apiKey.length === 0) {\n    throw new Error('The GCM API Key should be a non-empty string or null.');\n  }\n\n  gcmAPIKey = apiKey;\n};\n\n/**\n * When making requests where you want to define VAPID details, call this\n * method before sendNotification() or pass in the details and options to\n * sendNotification.\n * @param  {string} subject    This must be either a URL or a 'mailto:'\n * address. For example: 'https://my-site.com/contact' or\n * 'mailto: contact@my-site.com'\n * @param  {string} publicKey  The public VAPID key, a URL safe, base64 encoded string\n * @param  {string} privateKey The private VAPID key, a URL safe, base64 encoded string.\n */\nWebPushLib.prototype.setVapidDetails = function(subject, publicKey, privateKey) {\n    if (arguments.length === 1 && arguments[0] === null) {\n      vapidDetails = null;\n      return;\n    }\n\n    vapidHelper.validateSubject(subject);\n    vapidHelper.validatePublicKey(publicKey);\n    vapidHelper.validatePrivateKey(privateKey);\n\n    vapidDetails = {\n      subject: subject,\n      publicKey: publicKey,\n      privateKey: privateKey\n    };\n  };\n\n  /**\n   * To get the details of a request to trigger a push message, without sending\n   * a push notification call this method.\n   *\n   * This method will throw an error if there is an issue with the input.\n   * @param  {PushSubscription} subscription The PushSubscription you wish to\n   * send the notification to.\n   * @param  {string|Buffer} [payload]       The payload you wish to send to the\n   * the user.\n   * @param  {Object} [options]              Options for the GCM API key and\n   * vapid keys can be passed in if they are unique for each notification you\n   * wish to send.\n   * @return {Object}                       This method returns an Object which\n   * contains 'endpoint', 'method', 'headers' and 'payload'.\n   */\nWebPushLib.prototype.generateRequestDetails = function(subscription, payload, options) {\n    if (!subscription || !subscription.endpoint) {\n      throw new Error('You must pass in a subscription with at least '\n      + 'an endpoint.');\n    }\n\n    if (typeof subscription.endpoint !== 'string'\n    || subscription.endpoint.length === 0) {\n      throw new Error('The subscription endpoint must be a string with '\n      + 'a valid URL.');\n    }\n\n    if (payload) {\n      // Validate the subscription keys\n      if (typeof subscription !== 'object' || !subscription.keys\n      || !subscription.keys.p256dh\n      || !subscription.keys.auth) {\n        throw new Error('To send a message with a payload, the '\n        + 'subscription must have \\'auth\\' and \\'p256dh\\' keys.');\n      }\n    }\n\n    let currentGCMAPIKey = gcmAPIKey;\n    let currentVapidDetails = vapidDetails;\n    let timeToLive = DEFAULT_TTL;\n    let extraHeaders = {};\n    let contentEncoding = webPushConstants.supportedContentEncodings.AES_128_GCM;\n    let urgency = webPushConstants.supportedUrgency.NORMAL;\n    let topic;\n    let proxy;\n    let agent;\n    let timeout;\n\n    if (options) {\n      const validOptionKeys = [\n        'headers',\n        'gcmAPIKey',\n        'vapidDetails',\n        'TTL',\n        'contentEncoding',\n        'urgency',\n        'topic',\n        'proxy',\n        'agent',\n        'timeout'\n      ];\n      const optionKeys = Object.keys(options);\n      for (let i = 0; i < optionKeys.length; i += 1) {\n        const optionKey = optionKeys[i];\n        if (!validOptionKeys.includes(optionKey)) {\n          throw new Error('\\'' + optionKey + '\\' is an invalid option. '\n          + 'The valid options are [\\'' + validOptionKeys.join('\\', \\'')\n          + '\\'].');\n        }\n      }\n\n      if (options.headers) {\n        extraHeaders = options.headers;\n        let duplicates = Object.keys(extraHeaders)\n            .filter(function (header) {\n              return typeof options[header] !== 'undefined';\n            });\n\n        if (duplicates.length > 0) {\n          throw new Error('Duplicated headers defined ['\n          + duplicates.join(',') + ']. Please either define the header in the'\n          + 'top level options OR in the \\'headers\\' key.');\n        }\n      }\n\n      if (options.gcmAPIKey) {\n        currentGCMAPIKey = options.gcmAPIKey;\n      }\n\n      // Falsy values are allowed here so one can skip Vapid `else if` below and use FCM\n      if (options.vapidDetails !== undefined) {\n        currentVapidDetails = options.vapidDetails;\n      }\n\n      if (options.TTL !== undefined) {\n        timeToLive = Number(options.TTL);\n        if (timeToLive < 0) {\n          throw new Error('TTL should be a number and should be at least 0');\n        }\n      }\n\n      if (options.contentEncoding) {\n        if ((options.contentEncoding === webPushConstants.supportedContentEncodings.AES_128_GCM\n          || options.contentEncoding === webPushConstants.supportedContentEncodings.AES_GCM)) {\n          contentEncoding = options.contentEncoding;\n        } else {\n          throw new Error('Unsupported content encoding specified.');\n        }\n      }\n\n      if (options.urgency) {\n        if ((options.urgency === webPushConstants.supportedUrgency.VERY_LOW\n          || options.urgency === webPushConstants.supportedUrgency.LOW\n          || options.urgency === webPushConstants.supportedUrgency.NORMAL\n          || options.urgency === webPushConstants.supportedUrgency.HIGH)) {\n          urgency = options.urgency;\n        } else {\n          throw new Error('Unsupported urgency specified.');\n        }\n      }\n\n      if (options.topic) {\n        if (!urlBase64Helper.validate(options.topic)) {\n          throw new Error('Unsupported characters set use the URL or filename-safe Base64 characters set');\n        }\n        if (options.topic.length > 32) {\n          throw new Error('use maximum of 32 characters from the URL or filename-safe Base64 characters set');\n        }\n        topic = options.topic;\n      }\n\n      if (options.proxy) {\n        if (typeof options.proxy === 'string'\n          || typeof options.proxy.host === 'string') {\n          proxy = options.proxy;\n        } else {\n          console.warn('Attempt to use proxy option, but invalid type it should be a string or proxy options object.');\n        }\n      }\n\n      if (options.agent) {\n        if (options.agent instanceof https.Agent) {\n          if (proxy) {\n            console.warn('Agent option will be ignored because proxy option is defined.');\n          }\n\n          agent = options.agent;\n        } else {\n          console.warn('Wrong type for the agent option, it should be an instance of https.Agent.');\n        }\n      }\n\n      if (typeof options.timeout === 'number') {\n        timeout = options.timeout;\n      }\n    }\n\n    if (typeof timeToLive === 'undefined') {\n      timeToLive = DEFAULT_TTL;\n    }\n\n    const requestDetails = {\n      method: 'POST',\n      headers: {\n        TTL: timeToLive\n      }\n    };\n    Object.keys(extraHeaders).forEach(function (header) {\n      requestDetails.headers[header] = extraHeaders[header];\n    });\n    let requestPayload = null;\n\n    if (payload) {\n      const encrypted = encryptionHelper\n        .encrypt(subscription.keys.p256dh, subscription.keys.auth, payload, contentEncoding);\n\n      requestDetails.headers['Content-Length'] = encrypted.cipherText.length;\n      requestDetails.headers['Content-Type'] = 'application/octet-stream';\n\n      if (contentEncoding === webPushConstants.supportedContentEncodings.AES_128_GCM) {\n        requestDetails.headers['Content-Encoding'] = webPushConstants.supportedContentEncodings.AES_128_GCM;\n      } else if (contentEncoding === webPushConstants.supportedContentEncodings.AES_GCM) {\n        requestDetails.headers['Content-Encoding'] = webPushConstants.supportedContentEncodings.AES_GCM;\n        requestDetails.headers.Encryption = 'salt=' + encrypted.salt;\n        requestDetails.headers['Crypto-Key'] = 'dh=' + encrypted.localPublicKey.toString('base64url');\n      }\n\n      requestPayload = encrypted.cipherText;\n    } else {\n      requestDetails.headers['Content-Length'] = 0;\n    }\n\n    const isGCM = subscription.endpoint.startsWith('https://android.googleapis.com/gcm/send');\n    const isFCM = subscription.endpoint.startsWith('https://fcm.googleapis.com/fcm/send');\n    // VAPID isn't supported by GCM hence the if, else if.\n    if (isGCM) {\n      if (!currentGCMAPIKey) {\n        console.warn('Attempt to send push notification to GCM endpoint, '\n        + 'but no GCM key is defined. Please use setGCMApiKey() or add '\n        + '\\'gcmAPIKey\\' as an option.');\n      } else {\n        requestDetails.headers.Authorization = 'key=' + currentGCMAPIKey;\n      }\n    } else if (currentVapidDetails) {\n      const parsedUrl = url.parse(subscription.endpoint);\n      const audience = parsedUrl.protocol + '//'\n      + parsedUrl.host;\n\n      const vapidHeaders = vapidHelper.getVapidHeaders(\n        audience,\n        currentVapidDetails.subject,\n        currentVapidDetails.publicKey,\n        currentVapidDetails.privateKey,\n        contentEncoding\n      );\n\n      requestDetails.headers.Authorization = vapidHeaders.Authorization;\n\n      if (contentEncoding === webPushConstants.supportedContentEncodings.AES_GCM) {\n        if (requestDetails.headers['Crypto-Key']) {\n          requestDetails.headers['Crypto-Key'] += ';'\n          + vapidHeaders['Crypto-Key'];\n        } else {\n          requestDetails.headers['Crypto-Key'] = vapidHeaders['Crypto-Key'];\n        }\n      }\n    } else if (isFCM && currentGCMAPIKey) {\n      requestDetails.headers.Authorization = 'key=' + currentGCMAPIKey;\n    }\n\n    requestDetails.headers.Urgency = urgency;\n\n    if (topic) {\n      requestDetails.headers.Topic = topic;\n    }\n\n    requestDetails.body = requestPayload;\n    requestDetails.endpoint = subscription.endpoint;\n\n    if (proxy) {\n      requestDetails.proxy = proxy;\n    }\n\n    if (agent) {\n      requestDetails.agent = agent;\n    }\n\n    if (timeout) {\n      requestDetails.timeout = timeout;\n    }\n\n    return requestDetails;\n  };\n\n/**\n * To send a push notification call this method with a subscription, optional\n * payload and any options.\n * @param  {PushSubscription} subscription The PushSubscription you wish to\n * send the notification to.\n * @param  {string|Buffer} [payload]       The payload you wish to send to the\n * the user.\n * @param  {Object} [options]              Options for the GCM API key and\n * vapid keys can be passed in if they are unique for each notification you\n * wish to send.\n * @return {Promise}                       This method returns a Promise which\n * resolves if the sending of the notification was successful, otherwise it\n * rejects.\n */\nWebPushLib.prototype.sendNotification = function(subscription, payload, options) {\n    let requestDetails;\n    try {\n      requestDetails = this.generateRequestDetails(subscription, payload, options);\n    } catch (err) {\n      return Promise.reject(err);\n    }\n\n    return new Promise(function(resolve, reject) {\n      const httpsOptions = {};\n      const urlParts = url.parse(requestDetails.endpoint);\n      httpsOptions.hostname = urlParts.hostname;\n      httpsOptions.port = urlParts.port;\n      httpsOptions.path = urlParts.path;\n\n      httpsOptions.headers = requestDetails.headers;\n      httpsOptions.method = requestDetails.method;\n\n      if (requestDetails.timeout) {\n        httpsOptions.timeout = requestDetails.timeout;\n      }\n\n      if (requestDetails.agent) {\n        httpsOptions.agent = requestDetails.agent;\n      }\n\n      if (requestDetails.proxy) {\n        const { HttpsProxyAgent } = __webpack_require__(/*! https-proxy-agent */ \"(action-browser)/./node_modules/https-proxy-agent/dist/index.js\"); // eslint-disable-line global-require\n        httpsOptions.agent = new HttpsProxyAgent(requestDetails.proxy);\n      }\n\n      const pushRequest = https.request(httpsOptions, function(pushResponse) {\n        let responseText = '';\n\n        pushResponse.on('data', function(chunk) {\n          responseText += chunk;\n        });\n\n        pushResponse.on('end', function() {\n          if (pushResponse.statusCode < 200 || pushResponse.statusCode > 299) {\n            reject(new WebPushError(\n              'Received unexpected response code',\n              pushResponse.statusCode,\n              pushResponse.headers,\n              responseText,\n              requestDetails.endpoint\n            ));\n          } else {\n            resolve({\n              statusCode: pushResponse.statusCode,\n              body: responseText,\n              headers: pushResponse.headers\n            });\n          }\n        });\n      });\n\n      if (requestDetails.timeout) {\n        pushRequest.on('timeout', function() {\n          pushRequest.destroy(new Error('Socket timeout'));\n        });\n      }\n\n      pushRequest.on('error', function(e) {\n        reject(e);\n      });\n\n      if (requestDetails.body) {\n        pushRequest.write(requestDetails.body);\n      }\n\n      pushRequest.end();\n    });\n  };\n\nmodule.exports = WebPushLib;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy93ZWItcHVzaC9zcmMvd2ViLXB1c2gtbGliLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLFlBQVksbUJBQU8sQ0FBQyxnQkFBSztBQUN6QixjQUFjLG1CQUFPLENBQUMsb0JBQU87O0FBRTdCLHFCQUFxQixtQkFBTyxDQUFDLDJGQUFxQjtBQUNsRCxvQkFBb0IsbUJBQU8sQ0FBQyx1RkFBbUI7QUFDL0MseUJBQXlCLG1CQUFPLENBQUMsaUdBQXdCO0FBQ3pELHlCQUF5QixtQkFBTyxDQUFDLG1HQUF5QjtBQUMxRCx3QkFBd0IsbUJBQU8sQ0FBQyxzR0FBeUI7O0FBRXpEO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksUUFBUTtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxRQUFRO0FBQ3BCO0FBQ0E7QUFDQSxZQUFZLFFBQVE7QUFDcEIsWUFBWSxRQUFRO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLGtCQUFrQjtBQUNoQztBQUNBLGNBQWMsZUFBZTtBQUM3QjtBQUNBLGNBQWMsUUFBUTtBQUN0QjtBQUNBO0FBQ0EsY0FBYyw4QkFBOEI7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQix1QkFBdUI7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7O0FBRWI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0Esb0RBQW9EO0FBQ3BEO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBWSxrQkFBa0I7QUFDOUI7QUFDQSxZQUFZLGVBQWU7QUFDM0I7QUFDQSxZQUFZLFFBQVE7QUFDcEI7QUFDQTtBQUNBLFlBQVksK0JBQStCO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGdCQUFnQixrQkFBa0IsRUFBRSxtQkFBTyxDQUFDLDBGQUFtQixHQUFHO0FBQ2xFO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxTQUFTO0FBQ1QsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMOztBQUVBIiwic291cmNlcyI6WyJEOlxcYXBsaWNhY2lvbmVzLWlhXFxuZXh0LXRhc2tcXG5vZGVfbW9kdWxlc1xcd2ViLXB1c2hcXHNyY1xcd2ViLXB1c2gtbGliLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuY29uc3QgdXJsID0gcmVxdWlyZSgndXJsJyk7XG5jb25zdCBodHRwcyA9IHJlcXVpcmUoJ2h0dHBzJyk7XG5cbmNvbnN0IFdlYlB1c2hFcnJvciA9IHJlcXVpcmUoJy4vd2ViLXB1c2gtZXJyb3IuanMnKTtcbmNvbnN0IHZhcGlkSGVscGVyID0gcmVxdWlyZSgnLi92YXBpZC1oZWxwZXIuanMnKTtcbmNvbnN0IGVuY3J5cHRpb25IZWxwZXIgPSByZXF1aXJlKCcuL2VuY3J5cHRpb24taGVscGVyLmpzJyk7XG5jb25zdCB3ZWJQdXNoQ29uc3RhbnRzID0gcmVxdWlyZSgnLi93ZWItcHVzaC1jb25zdGFudHMuanMnKTtcbmNvbnN0IHVybEJhc2U2NEhlbHBlciA9IHJlcXVpcmUoJy4vdXJsc2FmZS1iYXNlNjQtaGVscGVyJyk7XG5cbi8vIERlZmF1bHQgVFRMIGlzIGZvdXIgd2Vla3MuXG5jb25zdCBERUZBVUxUX1RUTCA9IDI0MTkyMDA7XG5cbmxldCBnY21BUElLZXkgPSAnJztcbmxldCB2YXBpZERldGFpbHM7XG5cbmZ1bmN0aW9uIFdlYlB1c2hMaWIoKSB7XG5cbn1cblxuLyoqXG4gKiBXaGVuIHNlbmRpbmcgbWVzc2FnZXMgdG8gYSBHQ00gZW5kcG9pbnQgeW91IG5lZWQgdG8gc2V0IHRoZSBHQ00gQVBJIGtleVxuICogYnkgZWl0aGVyIGNhbGxpbmcgc2V0R01BUElLZXkoKSBvciBwYXNzaW5nIGluIHRoZSBBUEkga2V5IGFzIGFuIG9wdGlvblxuICogdG8gc2VuZE5vdGlmaWNhdGlvbigpLlxuICogQHBhcmFtICB7c3RyaW5nfSBhcGlLZXkgVGhlIEFQSSBrZXkgdG8gc2VuZCB3aXRoIHRoZSBHQ00gcmVxdWVzdC5cbiAqL1xuV2ViUHVzaExpYi5wcm90b3R5cGUuc2V0R0NNQVBJS2V5ID0gZnVuY3Rpb24oYXBpS2V5KSB7XG4gIGlmIChhcGlLZXkgPT09IG51bGwpIHtcbiAgICBnY21BUElLZXkgPSBudWxsO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGlmICh0eXBlb2YgYXBpS2V5ID09PSAndW5kZWZpbmVkJ1xuICB8fCB0eXBlb2YgYXBpS2V5ICE9PSAnc3RyaW5nJ1xuICB8fCBhcGlLZXkubGVuZ3RoID09PSAwKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdUaGUgR0NNIEFQSSBLZXkgc2hvdWxkIGJlIGEgbm9uLWVtcHR5IHN0cmluZyBvciBudWxsLicpO1xuICB9XG5cbiAgZ2NtQVBJS2V5ID0gYXBpS2V5O1xufTtcblxuLyoqXG4gKiBXaGVuIG1ha2luZyByZXF1ZXN0cyB3aGVyZSB5b3Ugd2FudCB0byBkZWZpbmUgVkFQSUQgZGV0YWlscywgY2FsbCB0aGlzXG4gKiBtZXRob2QgYmVmb3JlIHNlbmROb3RpZmljYXRpb24oKSBvciBwYXNzIGluIHRoZSBkZXRhaWxzIGFuZCBvcHRpb25zIHRvXG4gKiBzZW5kTm90aWZpY2F0aW9uLlxuICogQHBhcmFtICB7c3RyaW5nfSBzdWJqZWN0ICAgIFRoaXMgbXVzdCBiZSBlaXRoZXIgYSBVUkwgb3IgYSAnbWFpbHRvOidcbiAqIGFkZHJlc3MuIEZvciBleGFtcGxlOiAnaHR0cHM6Ly9teS1zaXRlLmNvbS9jb250YWN0JyBvclxuICogJ21haWx0bzogY29udGFjdEBteS1zaXRlLmNvbSdcbiAqIEBwYXJhbSAge3N0cmluZ30gcHVibGljS2V5ICBUaGUgcHVibGljIFZBUElEIGtleSwgYSBVUkwgc2FmZSwgYmFzZTY0IGVuY29kZWQgc3RyaW5nXG4gKiBAcGFyYW0gIHtzdHJpbmd9IHByaXZhdGVLZXkgVGhlIHByaXZhdGUgVkFQSUQga2V5LCBhIFVSTCBzYWZlLCBiYXNlNjQgZW5jb2RlZCBzdHJpbmcuXG4gKi9cbldlYlB1c2hMaWIucHJvdG90eXBlLnNldFZhcGlkRGV0YWlscyA9IGZ1bmN0aW9uKHN1YmplY3QsIHB1YmxpY0tleSwgcHJpdmF0ZUtleSkge1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxICYmIGFyZ3VtZW50c1swXSA9PT0gbnVsbCkge1xuICAgICAgdmFwaWREZXRhaWxzID0gbnVsbDtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXBpZEhlbHBlci52YWxpZGF0ZVN1YmplY3Qoc3ViamVjdCk7XG4gICAgdmFwaWRIZWxwZXIudmFsaWRhdGVQdWJsaWNLZXkocHVibGljS2V5KTtcbiAgICB2YXBpZEhlbHBlci52YWxpZGF0ZVByaXZhdGVLZXkocHJpdmF0ZUtleSk7XG5cbiAgICB2YXBpZERldGFpbHMgPSB7XG4gICAgICBzdWJqZWN0OiBzdWJqZWN0LFxuICAgICAgcHVibGljS2V5OiBwdWJsaWNLZXksXG4gICAgICBwcml2YXRlS2V5OiBwcml2YXRlS2V5XG4gICAgfTtcbiAgfTtcblxuICAvKipcbiAgICogVG8gZ2V0IHRoZSBkZXRhaWxzIG9mIGEgcmVxdWVzdCB0byB0cmlnZ2VyIGEgcHVzaCBtZXNzYWdlLCB3aXRob3V0IHNlbmRpbmdcbiAgICogYSBwdXNoIG5vdGlmaWNhdGlvbiBjYWxsIHRoaXMgbWV0aG9kLlxuICAgKlxuICAgKiBUaGlzIG1ldGhvZCB3aWxsIHRocm93IGFuIGVycm9yIGlmIHRoZXJlIGlzIGFuIGlzc3VlIHdpdGggdGhlIGlucHV0LlxuICAgKiBAcGFyYW0gIHtQdXNoU3Vic2NyaXB0aW9ufSBzdWJzY3JpcHRpb24gVGhlIFB1c2hTdWJzY3JpcHRpb24geW91IHdpc2ggdG9cbiAgICogc2VuZCB0aGUgbm90aWZpY2F0aW9uIHRvLlxuICAgKiBAcGFyYW0gIHtzdHJpbmd8QnVmZmVyfSBbcGF5bG9hZF0gICAgICAgVGhlIHBheWxvYWQgeW91IHdpc2ggdG8gc2VuZCB0byB0aGVcbiAgICogdGhlIHVzZXIuXG4gICAqIEBwYXJhbSAge09iamVjdH0gW29wdGlvbnNdICAgICAgICAgICAgICBPcHRpb25zIGZvciB0aGUgR0NNIEFQSSBrZXkgYW5kXG4gICAqIHZhcGlkIGtleXMgY2FuIGJlIHBhc3NlZCBpbiBpZiB0aGV5IGFyZSB1bmlxdWUgZm9yIGVhY2ggbm90aWZpY2F0aW9uIHlvdVxuICAgKiB3aXNoIHRvIHNlbmQuXG4gICAqIEByZXR1cm4ge09iamVjdH0gICAgICAgICAgICAgICAgICAgICAgIFRoaXMgbWV0aG9kIHJldHVybnMgYW4gT2JqZWN0IHdoaWNoXG4gICAqIGNvbnRhaW5zICdlbmRwb2ludCcsICdtZXRob2QnLCAnaGVhZGVycycgYW5kICdwYXlsb2FkJy5cbiAgICovXG5XZWJQdXNoTGliLnByb3RvdHlwZS5nZW5lcmF0ZVJlcXVlc3REZXRhaWxzID0gZnVuY3Rpb24oc3Vic2NyaXB0aW9uLCBwYXlsb2FkLCBvcHRpb25zKSB7XG4gICAgaWYgKCFzdWJzY3JpcHRpb24gfHwgIXN1YnNjcmlwdGlvbi5lbmRwb2ludCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdZb3UgbXVzdCBwYXNzIGluIGEgc3Vic2NyaXB0aW9uIHdpdGggYXQgbGVhc3QgJ1xuICAgICAgKyAnYW4gZW5kcG9pbnQuJyk7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBzdWJzY3JpcHRpb24uZW5kcG9pbnQgIT09ICdzdHJpbmcnXG4gICAgfHwgc3Vic2NyaXB0aW9uLmVuZHBvaW50Lmxlbmd0aCA9PT0gMCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdUaGUgc3Vic2NyaXB0aW9uIGVuZHBvaW50IG11c3QgYmUgYSBzdHJpbmcgd2l0aCAnXG4gICAgICArICdhIHZhbGlkIFVSTC4nKTtcbiAgICB9XG5cbiAgICBpZiAocGF5bG9hZCkge1xuICAgICAgLy8gVmFsaWRhdGUgdGhlIHN1YnNjcmlwdGlvbiBrZXlzXG4gICAgICBpZiAodHlwZW9mIHN1YnNjcmlwdGlvbiAhPT0gJ29iamVjdCcgfHwgIXN1YnNjcmlwdGlvbi5rZXlzXG4gICAgICB8fCAhc3Vic2NyaXB0aW9uLmtleXMucDI1NmRoXG4gICAgICB8fCAhc3Vic2NyaXB0aW9uLmtleXMuYXV0aCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RvIHNlbmQgYSBtZXNzYWdlIHdpdGggYSBwYXlsb2FkLCB0aGUgJ1xuICAgICAgICArICdzdWJzY3JpcHRpb24gbXVzdCBoYXZlIFxcJ2F1dGhcXCcgYW5kIFxcJ3AyNTZkaFxcJyBrZXlzLicpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGxldCBjdXJyZW50R0NNQVBJS2V5ID0gZ2NtQVBJS2V5O1xuICAgIGxldCBjdXJyZW50VmFwaWREZXRhaWxzID0gdmFwaWREZXRhaWxzO1xuICAgIGxldCB0aW1lVG9MaXZlID0gREVGQVVMVF9UVEw7XG4gICAgbGV0IGV4dHJhSGVhZGVycyA9IHt9O1xuICAgIGxldCBjb250ZW50RW5jb2RpbmcgPSB3ZWJQdXNoQ29uc3RhbnRzLnN1cHBvcnRlZENvbnRlbnRFbmNvZGluZ3MuQUVTXzEyOF9HQ007XG4gICAgbGV0IHVyZ2VuY3kgPSB3ZWJQdXNoQ29uc3RhbnRzLnN1cHBvcnRlZFVyZ2VuY3kuTk9STUFMO1xuICAgIGxldCB0b3BpYztcbiAgICBsZXQgcHJveHk7XG4gICAgbGV0IGFnZW50O1xuICAgIGxldCB0aW1lb3V0O1xuXG4gICAgaWYgKG9wdGlvbnMpIHtcbiAgICAgIGNvbnN0IHZhbGlkT3B0aW9uS2V5cyA9IFtcbiAgICAgICAgJ2hlYWRlcnMnLFxuICAgICAgICAnZ2NtQVBJS2V5JyxcbiAgICAgICAgJ3ZhcGlkRGV0YWlscycsXG4gICAgICAgICdUVEwnLFxuICAgICAgICAnY29udGVudEVuY29kaW5nJyxcbiAgICAgICAgJ3VyZ2VuY3knLFxuICAgICAgICAndG9waWMnLFxuICAgICAgICAncHJveHknLFxuICAgICAgICAnYWdlbnQnLFxuICAgICAgICAndGltZW91dCdcbiAgICAgIF07XG4gICAgICBjb25zdCBvcHRpb25LZXlzID0gT2JqZWN0LmtleXMob3B0aW9ucyk7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG9wdGlvbktleXMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgY29uc3Qgb3B0aW9uS2V5ID0gb3B0aW9uS2V5c1tpXTtcbiAgICAgICAgaWYgKCF2YWxpZE9wdGlvbktleXMuaW5jbHVkZXMob3B0aW9uS2V5KSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignXFwnJyArIG9wdGlvbktleSArICdcXCcgaXMgYW4gaW52YWxpZCBvcHRpb24uICdcbiAgICAgICAgICArICdUaGUgdmFsaWQgb3B0aW9ucyBhcmUgW1xcJycgKyB2YWxpZE9wdGlvbktleXMuam9pbignXFwnLCBcXCcnKVxuICAgICAgICAgICsgJ1xcJ10uJyk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKG9wdGlvbnMuaGVhZGVycykge1xuICAgICAgICBleHRyYUhlYWRlcnMgPSBvcHRpb25zLmhlYWRlcnM7XG4gICAgICAgIGxldCBkdXBsaWNhdGVzID0gT2JqZWN0LmtleXMoZXh0cmFIZWFkZXJzKVxuICAgICAgICAgICAgLmZpbHRlcihmdW5jdGlvbiAoaGVhZGVyKSB7XG4gICAgICAgICAgICAgIHJldHVybiB0eXBlb2Ygb3B0aW9uc1toZWFkZXJdICE9PSAndW5kZWZpbmVkJztcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgIGlmIChkdXBsaWNhdGVzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0R1cGxpY2F0ZWQgaGVhZGVycyBkZWZpbmVkIFsnXG4gICAgICAgICAgKyBkdXBsaWNhdGVzLmpvaW4oJywnKSArICddLiBQbGVhc2UgZWl0aGVyIGRlZmluZSB0aGUgaGVhZGVyIGluIHRoZSdcbiAgICAgICAgICArICd0b3AgbGV2ZWwgb3B0aW9ucyBPUiBpbiB0aGUgXFwnaGVhZGVyc1xcJyBrZXkuJyk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKG9wdGlvbnMuZ2NtQVBJS2V5KSB7XG4gICAgICAgIGN1cnJlbnRHQ01BUElLZXkgPSBvcHRpb25zLmdjbUFQSUtleTtcbiAgICAgIH1cblxuICAgICAgLy8gRmFsc3kgdmFsdWVzIGFyZSBhbGxvd2VkIGhlcmUgc28gb25lIGNhbiBza2lwIFZhcGlkIGBlbHNlIGlmYCBiZWxvdyBhbmQgdXNlIEZDTVxuICAgICAgaWYgKG9wdGlvbnMudmFwaWREZXRhaWxzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgY3VycmVudFZhcGlkRGV0YWlscyA9IG9wdGlvbnMudmFwaWREZXRhaWxzO1xuICAgICAgfVxuXG4gICAgICBpZiAob3B0aW9ucy5UVEwgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aW1lVG9MaXZlID0gTnVtYmVyKG9wdGlvbnMuVFRMKTtcbiAgICAgICAgaWYgKHRpbWVUb0xpdmUgPCAwKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUVEwgc2hvdWxkIGJlIGEgbnVtYmVyIGFuZCBzaG91bGQgYmUgYXQgbGVhc3QgMCcpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChvcHRpb25zLmNvbnRlbnRFbmNvZGluZykge1xuICAgICAgICBpZiAoKG9wdGlvbnMuY29udGVudEVuY29kaW5nID09PSB3ZWJQdXNoQ29uc3RhbnRzLnN1cHBvcnRlZENvbnRlbnRFbmNvZGluZ3MuQUVTXzEyOF9HQ01cbiAgICAgICAgICB8fCBvcHRpb25zLmNvbnRlbnRFbmNvZGluZyA9PT0gd2ViUHVzaENvbnN0YW50cy5zdXBwb3J0ZWRDb250ZW50RW5jb2RpbmdzLkFFU19HQ00pKSB7XG4gICAgICAgICAgY29udGVudEVuY29kaW5nID0gb3B0aW9ucy5jb250ZW50RW5jb2Rpbmc7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbnN1cHBvcnRlZCBjb250ZW50IGVuY29kaW5nIHNwZWNpZmllZC4nKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAob3B0aW9ucy51cmdlbmN5KSB7XG4gICAgICAgIGlmICgob3B0aW9ucy51cmdlbmN5ID09PSB3ZWJQdXNoQ29uc3RhbnRzLnN1cHBvcnRlZFVyZ2VuY3kuVkVSWV9MT1dcbiAgICAgICAgICB8fCBvcHRpb25zLnVyZ2VuY3kgPT09IHdlYlB1c2hDb25zdGFudHMuc3VwcG9ydGVkVXJnZW5jeS5MT1dcbiAgICAgICAgICB8fCBvcHRpb25zLnVyZ2VuY3kgPT09IHdlYlB1c2hDb25zdGFudHMuc3VwcG9ydGVkVXJnZW5jeS5OT1JNQUxcbiAgICAgICAgICB8fCBvcHRpb25zLnVyZ2VuY3kgPT09IHdlYlB1c2hDb25zdGFudHMuc3VwcG9ydGVkVXJnZW5jeS5ISUdIKSkge1xuICAgICAgICAgIHVyZ2VuY3kgPSBvcHRpb25zLnVyZ2VuY3k7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbnN1cHBvcnRlZCB1cmdlbmN5IHNwZWNpZmllZC4nKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAob3B0aW9ucy50b3BpYykge1xuICAgICAgICBpZiAoIXVybEJhc2U2NEhlbHBlci52YWxpZGF0ZShvcHRpb25zLnRvcGljKSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVW5zdXBwb3J0ZWQgY2hhcmFjdGVycyBzZXQgdXNlIHRoZSBVUkwgb3IgZmlsZW5hbWUtc2FmZSBCYXNlNjQgY2hhcmFjdGVycyBzZXQnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob3B0aW9ucy50b3BpYy5sZW5ndGggPiAzMikge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcigndXNlIG1heGltdW0gb2YgMzIgY2hhcmFjdGVycyBmcm9tIHRoZSBVUkwgb3IgZmlsZW5hbWUtc2FmZSBCYXNlNjQgY2hhcmFjdGVycyBzZXQnKTtcbiAgICAgICAgfVxuICAgICAgICB0b3BpYyA9IG9wdGlvbnMudG9waWM7XG4gICAgICB9XG5cbiAgICAgIGlmIChvcHRpb25zLnByb3h5KSB7XG4gICAgICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5wcm94eSA9PT0gJ3N0cmluZydcbiAgICAgICAgICB8fCB0eXBlb2Ygb3B0aW9ucy5wcm94eS5ob3N0ID09PSAnc3RyaW5nJykge1xuICAgICAgICAgIHByb3h5ID0gb3B0aW9ucy5wcm94eTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb25zb2xlLndhcm4oJ0F0dGVtcHQgdG8gdXNlIHByb3h5IG9wdGlvbiwgYnV0IGludmFsaWQgdHlwZSBpdCBzaG91bGQgYmUgYSBzdHJpbmcgb3IgcHJveHkgb3B0aW9ucyBvYmplY3QuJyk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKG9wdGlvbnMuYWdlbnQpIHtcbiAgICAgICAgaWYgKG9wdGlvbnMuYWdlbnQgaW5zdGFuY2VvZiBodHRwcy5BZ2VudCkge1xuICAgICAgICAgIGlmIChwcm94eSkge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKCdBZ2VudCBvcHRpb24gd2lsbCBiZSBpZ25vcmVkIGJlY2F1c2UgcHJveHkgb3B0aW9uIGlzIGRlZmluZWQuJyk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgYWdlbnQgPSBvcHRpb25zLmFnZW50O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvbnNvbGUud2FybignV3JvbmcgdHlwZSBmb3IgdGhlIGFnZW50IG9wdGlvbiwgaXQgc2hvdWxkIGJlIGFuIGluc3RhbmNlIG9mIGh0dHBzLkFnZW50LicpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmICh0eXBlb2Ygb3B0aW9ucy50aW1lb3V0ID09PSAnbnVtYmVyJykge1xuICAgICAgICB0aW1lb3V0ID0gb3B0aW9ucy50aW1lb3V0O1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh0eXBlb2YgdGltZVRvTGl2ZSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHRpbWVUb0xpdmUgPSBERUZBVUxUX1RUTDtcbiAgICB9XG5cbiAgICBjb25zdCByZXF1ZXN0RGV0YWlscyA9IHtcbiAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgaGVhZGVyczoge1xuICAgICAgICBUVEw6IHRpbWVUb0xpdmVcbiAgICAgIH1cbiAgICB9O1xuICAgIE9iamVjdC5rZXlzKGV4dHJhSGVhZGVycykuZm9yRWFjaChmdW5jdGlvbiAoaGVhZGVyKSB7XG4gICAgICByZXF1ZXN0RGV0YWlscy5oZWFkZXJzW2hlYWRlcl0gPSBleHRyYUhlYWRlcnNbaGVhZGVyXTtcbiAgICB9KTtcbiAgICBsZXQgcmVxdWVzdFBheWxvYWQgPSBudWxsO1xuXG4gICAgaWYgKHBheWxvYWQpIHtcbiAgICAgIGNvbnN0IGVuY3J5cHRlZCA9IGVuY3J5cHRpb25IZWxwZXJcbiAgICAgICAgLmVuY3J5cHQoc3Vic2NyaXB0aW9uLmtleXMucDI1NmRoLCBzdWJzY3JpcHRpb24ua2V5cy5hdXRoLCBwYXlsb2FkLCBjb250ZW50RW5jb2RpbmcpO1xuXG4gICAgICByZXF1ZXN0RGV0YWlscy5oZWFkZXJzWydDb250ZW50LUxlbmd0aCddID0gZW5jcnlwdGVkLmNpcGhlclRleHQubGVuZ3RoO1xuICAgICAgcmVxdWVzdERldGFpbHMuaGVhZGVyc1snQ29udGVudC1UeXBlJ10gPSAnYXBwbGljYXRpb24vb2N0ZXQtc3RyZWFtJztcblxuICAgICAgaWYgKGNvbnRlbnRFbmNvZGluZyA9PT0gd2ViUHVzaENvbnN0YW50cy5zdXBwb3J0ZWRDb250ZW50RW5jb2RpbmdzLkFFU18xMjhfR0NNKSB7XG4gICAgICAgIHJlcXVlc3REZXRhaWxzLmhlYWRlcnNbJ0NvbnRlbnQtRW5jb2RpbmcnXSA9IHdlYlB1c2hDb25zdGFudHMuc3VwcG9ydGVkQ29udGVudEVuY29kaW5ncy5BRVNfMTI4X0dDTTtcbiAgICAgIH0gZWxzZSBpZiAoY29udGVudEVuY29kaW5nID09PSB3ZWJQdXNoQ29uc3RhbnRzLnN1cHBvcnRlZENvbnRlbnRFbmNvZGluZ3MuQUVTX0dDTSkge1xuICAgICAgICByZXF1ZXN0RGV0YWlscy5oZWFkZXJzWydDb250ZW50LUVuY29kaW5nJ10gPSB3ZWJQdXNoQ29uc3RhbnRzLnN1cHBvcnRlZENvbnRlbnRFbmNvZGluZ3MuQUVTX0dDTTtcbiAgICAgICAgcmVxdWVzdERldGFpbHMuaGVhZGVycy5FbmNyeXB0aW9uID0gJ3NhbHQ9JyArIGVuY3J5cHRlZC5zYWx0O1xuICAgICAgICByZXF1ZXN0RGV0YWlscy5oZWFkZXJzWydDcnlwdG8tS2V5J10gPSAnZGg9JyArIGVuY3J5cHRlZC5sb2NhbFB1YmxpY0tleS50b1N0cmluZygnYmFzZTY0dXJsJyk7XG4gICAgICB9XG5cbiAgICAgIHJlcXVlc3RQYXlsb2FkID0gZW5jcnlwdGVkLmNpcGhlclRleHQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlcXVlc3REZXRhaWxzLmhlYWRlcnNbJ0NvbnRlbnQtTGVuZ3RoJ10gPSAwO1xuICAgIH1cblxuICAgIGNvbnN0IGlzR0NNID0gc3Vic2NyaXB0aW9uLmVuZHBvaW50LnN0YXJ0c1dpdGgoJ2h0dHBzOi8vYW5kcm9pZC5nb29nbGVhcGlzLmNvbS9nY20vc2VuZCcpO1xuICAgIGNvbnN0IGlzRkNNID0gc3Vic2NyaXB0aW9uLmVuZHBvaW50LnN0YXJ0c1dpdGgoJ2h0dHBzOi8vZmNtLmdvb2dsZWFwaXMuY29tL2ZjbS9zZW5kJyk7XG4gICAgLy8gVkFQSUQgaXNuJ3Qgc3VwcG9ydGVkIGJ5IEdDTSBoZW5jZSB0aGUgaWYsIGVsc2UgaWYuXG4gICAgaWYgKGlzR0NNKSB7XG4gICAgICBpZiAoIWN1cnJlbnRHQ01BUElLZXkpIHtcbiAgICAgICAgY29uc29sZS53YXJuKCdBdHRlbXB0IHRvIHNlbmQgcHVzaCBub3RpZmljYXRpb24gdG8gR0NNIGVuZHBvaW50LCAnXG4gICAgICAgICsgJ2J1dCBubyBHQ00ga2V5IGlzIGRlZmluZWQuIFBsZWFzZSB1c2Ugc2V0R0NNQXBpS2V5KCkgb3IgYWRkICdcbiAgICAgICAgKyAnXFwnZ2NtQVBJS2V5XFwnIGFzIGFuIG9wdGlvbi4nKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlcXVlc3REZXRhaWxzLmhlYWRlcnMuQXV0aG9yaXphdGlvbiA9ICdrZXk9JyArIGN1cnJlbnRHQ01BUElLZXk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChjdXJyZW50VmFwaWREZXRhaWxzKSB7XG4gICAgICBjb25zdCBwYXJzZWRVcmwgPSB1cmwucGFyc2Uoc3Vic2NyaXB0aW9uLmVuZHBvaW50KTtcbiAgICAgIGNvbnN0IGF1ZGllbmNlID0gcGFyc2VkVXJsLnByb3RvY29sICsgJy8vJ1xuICAgICAgKyBwYXJzZWRVcmwuaG9zdDtcblxuICAgICAgY29uc3QgdmFwaWRIZWFkZXJzID0gdmFwaWRIZWxwZXIuZ2V0VmFwaWRIZWFkZXJzKFxuICAgICAgICBhdWRpZW5jZSxcbiAgICAgICAgY3VycmVudFZhcGlkRGV0YWlscy5zdWJqZWN0LFxuICAgICAgICBjdXJyZW50VmFwaWREZXRhaWxzLnB1YmxpY0tleSxcbiAgICAgICAgY3VycmVudFZhcGlkRGV0YWlscy5wcml2YXRlS2V5LFxuICAgICAgICBjb250ZW50RW5jb2RpbmdcbiAgICAgICk7XG5cbiAgICAgIHJlcXVlc3REZXRhaWxzLmhlYWRlcnMuQXV0aG9yaXphdGlvbiA9IHZhcGlkSGVhZGVycy5BdXRob3JpemF0aW9uO1xuXG4gICAgICBpZiAoY29udGVudEVuY29kaW5nID09PSB3ZWJQdXNoQ29uc3RhbnRzLnN1cHBvcnRlZENvbnRlbnRFbmNvZGluZ3MuQUVTX0dDTSkge1xuICAgICAgICBpZiAocmVxdWVzdERldGFpbHMuaGVhZGVyc1snQ3J5cHRvLUtleSddKSB7XG4gICAgICAgICAgcmVxdWVzdERldGFpbHMuaGVhZGVyc1snQ3J5cHRvLUtleSddICs9ICc7J1xuICAgICAgICAgICsgdmFwaWRIZWFkZXJzWydDcnlwdG8tS2V5J107XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVxdWVzdERldGFpbHMuaGVhZGVyc1snQ3J5cHRvLUtleSddID0gdmFwaWRIZWFkZXJzWydDcnlwdG8tS2V5J107XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGlzRkNNICYmIGN1cnJlbnRHQ01BUElLZXkpIHtcbiAgICAgIHJlcXVlc3REZXRhaWxzLmhlYWRlcnMuQXV0aG9yaXphdGlvbiA9ICdrZXk9JyArIGN1cnJlbnRHQ01BUElLZXk7XG4gICAgfVxuXG4gICAgcmVxdWVzdERldGFpbHMuaGVhZGVycy5VcmdlbmN5ID0gdXJnZW5jeTtcblxuICAgIGlmICh0b3BpYykge1xuICAgICAgcmVxdWVzdERldGFpbHMuaGVhZGVycy5Ub3BpYyA9IHRvcGljO1xuICAgIH1cblxuICAgIHJlcXVlc3REZXRhaWxzLmJvZHkgPSByZXF1ZXN0UGF5bG9hZDtcbiAgICByZXF1ZXN0RGV0YWlscy5lbmRwb2ludCA9IHN1YnNjcmlwdGlvbi5lbmRwb2ludDtcblxuICAgIGlmIChwcm94eSkge1xuICAgICAgcmVxdWVzdERldGFpbHMucHJveHkgPSBwcm94eTtcbiAgICB9XG5cbiAgICBpZiAoYWdlbnQpIHtcbiAgICAgIHJlcXVlc3REZXRhaWxzLmFnZW50ID0gYWdlbnQ7XG4gICAgfVxuXG4gICAgaWYgKHRpbWVvdXQpIHtcbiAgICAgIHJlcXVlc3REZXRhaWxzLnRpbWVvdXQgPSB0aW1lb3V0O1xuICAgIH1cblxuICAgIHJldHVybiByZXF1ZXN0RGV0YWlscztcbiAgfTtcblxuLyoqXG4gKiBUbyBzZW5kIGEgcHVzaCBub3RpZmljYXRpb24gY2FsbCB0aGlzIG1ldGhvZCB3aXRoIGEgc3Vic2NyaXB0aW9uLCBvcHRpb25hbFxuICogcGF5bG9hZCBhbmQgYW55IG9wdGlvbnMuXG4gKiBAcGFyYW0gIHtQdXNoU3Vic2NyaXB0aW9ufSBzdWJzY3JpcHRpb24gVGhlIFB1c2hTdWJzY3JpcHRpb24geW91IHdpc2ggdG9cbiAqIHNlbmQgdGhlIG5vdGlmaWNhdGlvbiB0by5cbiAqIEBwYXJhbSAge3N0cmluZ3xCdWZmZXJ9IFtwYXlsb2FkXSAgICAgICBUaGUgcGF5bG9hZCB5b3Ugd2lzaCB0byBzZW5kIHRvIHRoZVxuICogdGhlIHVzZXIuXG4gKiBAcGFyYW0gIHtPYmplY3R9IFtvcHRpb25zXSAgICAgICAgICAgICAgT3B0aW9ucyBmb3IgdGhlIEdDTSBBUEkga2V5IGFuZFxuICogdmFwaWQga2V5cyBjYW4gYmUgcGFzc2VkIGluIGlmIHRoZXkgYXJlIHVuaXF1ZSBmb3IgZWFjaCBub3RpZmljYXRpb24geW91XG4gKiB3aXNoIHRvIHNlbmQuXG4gKiBAcmV0dXJuIHtQcm9taXNlfSAgICAgICAgICAgICAgICAgICAgICAgVGhpcyBtZXRob2QgcmV0dXJucyBhIFByb21pc2Ugd2hpY2hcbiAqIHJlc29sdmVzIGlmIHRoZSBzZW5kaW5nIG9mIHRoZSBub3RpZmljYXRpb24gd2FzIHN1Y2Nlc3NmdWwsIG90aGVyd2lzZSBpdFxuICogcmVqZWN0cy5cbiAqL1xuV2ViUHVzaExpYi5wcm90b3R5cGUuc2VuZE5vdGlmaWNhdGlvbiA9IGZ1bmN0aW9uKHN1YnNjcmlwdGlvbiwgcGF5bG9hZCwgb3B0aW9ucykge1xuICAgIGxldCByZXF1ZXN0RGV0YWlscztcbiAgICB0cnkge1xuICAgICAgcmVxdWVzdERldGFpbHMgPSB0aGlzLmdlbmVyYXRlUmVxdWVzdERldGFpbHMoc3Vic2NyaXB0aW9uLCBwYXlsb2FkLCBvcHRpb25zKTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChlcnIpO1xuICAgIH1cblxuICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgIGNvbnN0IGh0dHBzT3B0aW9ucyA9IHt9O1xuICAgICAgY29uc3QgdXJsUGFydHMgPSB1cmwucGFyc2UocmVxdWVzdERldGFpbHMuZW5kcG9pbnQpO1xuICAgICAgaHR0cHNPcHRpb25zLmhvc3RuYW1lID0gdXJsUGFydHMuaG9zdG5hbWU7XG4gICAgICBodHRwc09wdGlvbnMucG9ydCA9IHVybFBhcnRzLnBvcnQ7XG4gICAgICBodHRwc09wdGlvbnMucGF0aCA9IHVybFBhcnRzLnBhdGg7XG5cbiAgICAgIGh0dHBzT3B0aW9ucy5oZWFkZXJzID0gcmVxdWVzdERldGFpbHMuaGVhZGVycztcbiAgICAgIGh0dHBzT3B0aW9ucy5tZXRob2QgPSByZXF1ZXN0RGV0YWlscy5tZXRob2Q7XG5cbiAgICAgIGlmIChyZXF1ZXN0RGV0YWlscy50aW1lb3V0KSB7XG4gICAgICAgIGh0dHBzT3B0aW9ucy50aW1lb3V0ID0gcmVxdWVzdERldGFpbHMudGltZW91dDtcbiAgICAgIH1cblxuICAgICAgaWYgKHJlcXVlc3REZXRhaWxzLmFnZW50KSB7XG4gICAgICAgIGh0dHBzT3B0aW9ucy5hZ2VudCA9IHJlcXVlc3REZXRhaWxzLmFnZW50O1xuICAgICAgfVxuXG4gICAgICBpZiAocmVxdWVzdERldGFpbHMucHJveHkpIHtcbiAgICAgICAgY29uc3QgeyBIdHRwc1Byb3h5QWdlbnQgfSA9IHJlcXVpcmUoJ2h0dHBzLXByb3h5LWFnZW50Jyk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgZ2xvYmFsLXJlcXVpcmVcbiAgICAgICAgaHR0cHNPcHRpb25zLmFnZW50ID0gbmV3IEh0dHBzUHJveHlBZ2VudChyZXF1ZXN0RGV0YWlscy5wcm94eSk7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHB1c2hSZXF1ZXN0ID0gaHR0cHMucmVxdWVzdChodHRwc09wdGlvbnMsIGZ1bmN0aW9uKHB1c2hSZXNwb25zZSkge1xuICAgICAgICBsZXQgcmVzcG9uc2VUZXh0ID0gJyc7XG5cbiAgICAgICAgcHVzaFJlc3BvbnNlLm9uKCdkYXRhJywgZnVuY3Rpb24oY2h1bmspIHtcbiAgICAgICAgICByZXNwb25zZVRleHQgKz0gY2h1bms7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHB1c2hSZXNwb25zZS5vbignZW5kJywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgaWYgKHB1c2hSZXNwb25zZS5zdGF0dXNDb2RlIDwgMjAwIHx8IHB1c2hSZXNwb25zZS5zdGF0dXNDb2RlID4gMjk5KSB7XG4gICAgICAgICAgICByZWplY3QobmV3IFdlYlB1c2hFcnJvcihcbiAgICAgICAgICAgICAgJ1JlY2VpdmVkIHVuZXhwZWN0ZWQgcmVzcG9uc2UgY29kZScsXG4gICAgICAgICAgICAgIHB1c2hSZXNwb25zZS5zdGF0dXNDb2RlLFxuICAgICAgICAgICAgICBwdXNoUmVzcG9uc2UuaGVhZGVycyxcbiAgICAgICAgICAgICAgcmVzcG9uc2VUZXh0LFxuICAgICAgICAgICAgICByZXF1ZXN0RGV0YWlscy5lbmRwb2ludFxuICAgICAgICAgICAgKSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlc29sdmUoe1xuICAgICAgICAgICAgICBzdGF0dXNDb2RlOiBwdXNoUmVzcG9uc2Uuc3RhdHVzQ29kZSxcbiAgICAgICAgICAgICAgYm9keTogcmVzcG9uc2VUZXh0LFxuICAgICAgICAgICAgICBoZWFkZXJzOiBwdXNoUmVzcG9uc2UuaGVhZGVyc1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH0pO1xuXG4gICAgICBpZiAocmVxdWVzdERldGFpbHMudGltZW91dCkge1xuICAgICAgICBwdXNoUmVxdWVzdC5vbigndGltZW91dCcsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHB1c2hSZXF1ZXN0LmRlc3Ryb3kobmV3IEVycm9yKCdTb2NrZXQgdGltZW91dCcpKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIHB1c2hSZXF1ZXN0Lm9uKCdlcnJvcicsIGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgcmVqZWN0KGUpO1xuICAgICAgfSk7XG5cbiAgICAgIGlmIChyZXF1ZXN0RGV0YWlscy5ib2R5KSB7XG4gICAgICAgIHB1c2hSZXF1ZXN0LndyaXRlKHJlcXVlc3REZXRhaWxzLmJvZHkpO1xuICAgICAgfVxuXG4gICAgICBwdXNoUmVxdWVzdC5lbmQoKTtcbiAgICB9KTtcbiAgfTtcblxubW9kdWxlLmV4cG9ydHMgPSBXZWJQdXNoTGliO1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/web-push/src/web-push-lib.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/web-push/src/encryption-helper.js":
/*!********************************************************!*\
  !*** ./node_modules/web-push/src/encryption-helper.js ***!
  \********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nconst crypto = __webpack_require__(/*! crypto */ \"crypto\");\nconst ece = __webpack_require__(/*! http_ece */ \"(rsc)/./node_modules/http_ece/ece.js\");\n\nconst encrypt = function(userPublicKey, userAuth, payload, contentEncoding) {\n  if (!userPublicKey) {\n    throw new Error('No user public key provided for encryption.');\n  }\n\n  if (typeof userPublicKey !== 'string') {\n    throw new Error('The subscription p256dh value must be a string.');\n  }\n\n  if (Buffer.from(userPublicKey, 'base64url').length !== 65) {\n    throw new Error('The subscription p256dh value should be 65 bytes long.');\n  }\n\n  if (!userAuth) {\n    throw new Error('No user auth provided for encryption.');\n  }\n\n  if (typeof userAuth !== 'string') {\n    throw new Error('The subscription auth key must be a string.');\n  }\n\n  if (Buffer.from(userAuth, 'base64url').length < 16) {\n    throw new Error('The subscription auth key should be at least 16 '\n    + 'bytes long');\n  }\n\n  if (typeof payload !== 'string' && !Buffer.isBuffer(payload)) {\n    throw new Error('Payload must be either a string or a Node Buffer.');\n  }\n\n  if (typeof payload === 'string' || payload instanceof String) {\n    payload = Buffer.from(payload);\n  }\n\n  const localCurve = crypto.createECDH('prime256v1');\n  const localPublicKey = localCurve.generateKeys();\n\n  const salt = crypto.randomBytes(16).toString('base64url');\n\n  const cipherText = ece.encrypt(payload, {\n    version: contentEncoding,\n    dh: userPublicKey,\n    privateKey: localCurve,\n    salt: salt,\n    authSecret: userAuth\n  });\n\n  return {\n    localPublicKey: localPublicKey,\n    salt: salt,\n    cipherText: cipherText\n  };\n};\n\nmodule.exports = {\n  encrypt: encrypt\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvd2ViLXB1c2gvc3JjL2VuY3J5cHRpb24taGVscGVyLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLGVBQWUsbUJBQU8sQ0FBQyxzQkFBUTtBQUMvQixZQUFZLG1CQUFPLENBQUMsc0RBQVU7O0FBRTlCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBIiwic291cmNlcyI6WyJEOlxcYXBsaWNhY2lvbmVzLWlhXFxuZXh0LXRhc2tcXG5vZGVfbW9kdWxlc1xcd2ViLXB1c2hcXHNyY1xcZW5jcnlwdGlvbi1oZWxwZXIuanMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBjcnlwdG8gPSByZXF1aXJlKCdjcnlwdG8nKTtcbmNvbnN0IGVjZSA9IHJlcXVpcmUoJ2h0dHBfZWNlJyk7XG5cbmNvbnN0IGVuY3J5cHQgPSBmdW5jdGlvbih1c2VyUHVibGljS2V5LCB1c2VyQXV0aCwgcGF5bG9hZCwgY29udGVudEVuY29kaW5nKSB7XG4gIGlmICghdXNlclB1YmxpY0tleSkge1xuICAgIHRocm93IG5ldyBFcnJvcignTm8gdXNlciBwdWJsaWMga2V5IHByb3ZpZGVkIGZvciBlbmNyeXB0aW9uLicpO1xuICB9XG5cbiAgaWYgKHR5cGVvZiB1c2VyUHVibGljS2V5ICE9PSAnc3RyaW5nJykge1xuICAgIHRocm93IG5ldyBFcnJvcignVGhlIHN1YnNjcmlwdGlvbiBwMjU2ZGggdmFsdWUgbXVzdCBiZSBhIHN0cmluZy4nKTtcbiAgfVxuXG4gIGlmIChCdWZmZXIuZnJvbSh1c2VyUHVibGljS2V5LCAnYmFzZTY0dXJsJykubGVuZ3RoICE9PSA2NSkge1xuICAgIHRocm93IG5ldyBFcnJvcignVGhlIHN1YnNjcmlwdGlvbiBwMjU2ZGggdmFsdWUgc2hvdWxkIGJlIDY1IGJ5dGVzIGxvbmcuJyk7XG4gIH1cblxuICBpZiAoIXVzZXJBdXRoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdObyB1c2VyIGF1dGggcHJvdmlkZWQgZm9yIGVuY3J5cHRpb24uJyk7XG4gIH1cblxuICBpZiAodHlwZW9mIHVzZXJBdXRoICE9PSAnc3RyaW5nJykge1xuICAgIHRocm93IG5ldyBFcnJvcignVGhlIHN1YnNjcmlwdGlvbiBhdXRoIGtleSBtdXN0IGJlIGEgc3RyaW5nLicpO1xuICB9XG5cbiAgaWYgKEJ1ZmZlci5mcm9tKHVzZXJBdXRoLCAnYmFzZTY0dXJsJykubGVuZ3RoIDwgMTYpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoZSBzdWJzY3JpcHRpb24gYXV0aCBrZXkgc2hvdWxkIGJlIGF0IGxlYXN0IDE2ICdcbiAgICArICdieXRlcyBsb25nJyk7XG4gIH1cblxuICBpZiAodHlwZW9mIHBheWxvYWQgIT09ICdzdHJpbmcnICYmICFCdWZmZXIuaXNCdWZmZXIocGF5bG9hZCkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1BheWxvYWQgbXVzdCBiZSBlaXRoZXIgYSBzdHJpbmcgb3IgYSBOb2RlIEJ1ZmZlci4nKTtcbiAgfVxuXG4gIGlmICh0eXBlb2YgcGF5bG9hZCA9PT0gJ3N0cmluZycgfHwgcGF5bG9hZCBpbnN0YW5jZW9mIFN0cmluZykge1xuICAgIHBheWxvYWQgPSBCdWZmZXIuZnJvbShwYXlsb2FkKTtcbiAgfVxuXG4gIGNvbnN0IGxvY2FsQ3VydmUgPSBjcnlwdG8uY3JlYXRlRUNESCgncHJpbWUyNTZ2MScpO1xuICBjb25zdCBsb2NhbFB1YmxpY0tleSA9IGxvY2FsQ3VydmUuZ2VuZXJhdGVLZXlzKCk7XG5cbiAgY29uc3Qgc2FsdCA9IGNyeXB0by5yYW5kb21CeXRlcygxNikudG9TdHJpbmcoJ2Jhc2U2NHVybCcpO1xuXG4gIGNvbnN0IGNpcGhlclRleHQgPSBlY2UuZW5jcnlwdChwYXlsb2FkLCB7XG4gICAgdmVyc2lvbjogY29udGVudEVuY29kaW5nLFxuICAgIGRoOiB1c2VyUHVibGljS2V5LFxuICAgIHByaXZhdGVLZXk6IGxvY2FsQ3VydmUsXG4gICAgc2FsdDogc2FsdCxcbiAgICBhdXRoU2VjcmV0OiB1c2VyQXV0aFxuICB9KTtcblxuICByZXR1cm4ge1xuICAgIGxvY2FsUHVibGljS2V5OiBsb2NhbFB1YmxpY0tleSxcbiAgICBzYWx0OiBzYWx0LFxuICAgIGNpcGhlclRleHQ6IGNpcGhlclRleHRcbiAgfTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBlbmNyeXB0OiBlbmNyeXB0XG59O1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/web-push/src/encryption-helper.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/web-push/src/index.js":
/*!********************************************!*\
  !*** ./node_modules/web-push/src/index.js ***!
  \********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nconst vapidHelper = __webpack_require__(/*! ./vapid-helper.js */ \"(rsc)/./node_modules/web-push/src/vapid-helper.js\");\nconst encryptionHelper = __webpack_require__(/*! ./encryption-helper.js */ \"(rsc)/./node_modules/web-push/src/encryption-helper.js\");\nconst WebPushLib = __webpack_require__(/*! ./web-push-lib.js */ \"(rsc)/./node_modules/web-push/src/web-push-lib.js\");\nconst WebPushError = __webpack_require__(/*! ./web-push-error.js */ \"(rsc)/./node_modules/web-push/src/web-push-error.js\");\nconst WebPushConstants = __webpack_require__(/*! ./web-push-constants.js */ \"(rsc)/./node_modules/web-push/src/web-push-constants.js\");\n\nconst webPush = new WebPushLib();\n\nmodule.exports = {\n  WebPushError: WebPushError,\n  supportedContentEncodings: WebPushConstants.supportedContentEncodings,\n  encrypt: encryptionHelper.encrypt,\n  getVapidHeaders: vapidHelper.getVapidHeaders,\n  generateVAPIDKeys: vapidHelper.generateVAPIDKeys,\n  setGCMAPIKey: webPush.setGCMAPIKey,\n  setVapidDetails: webPush.setVapidDetails,\n  generateRequestDetails: webPush.generateRequestDetails,\n  sendNotification: webPush.sendNotification.bind(webPush)\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvd2ViLXB1c2gvc3JjL2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLG9CQUFvQixtQkFBTyxDQUFDLDRFQUFtQjtBQUMvQyx5QkFBeUIsbUJBQU8sQ0FBQyxzRkFBd0I7QUFDekQsbUJBQW1CLG1CQUFPLENBQUMsNEVBQW1CO0FBQzlDLHFCQUFxQixtQkFBTyxDQUFDLGdGQUFxQjtBQUNsRCx5QkFBeUIsbUJBQU8sQ0FBQyx3RkFBeUI7O0FBRTFEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIkQ6XFxhcGxpY2FjaW9uZXMtaWFcXG5leHQtdGFza1xcbm9kZV9tb2R1bGVzXFx3ZWItcHVzaFxcc3JjXFxpbmRleC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbmNvbnN0IHZhcGlkSGVscGVyID0gcmVxdWlyZSgnLi92YXBpZC1oZWxwZXIuanMnKTtcbmNvbnN0IGVuY3J5cHRpb25IZWxwZXIgPSByZXF1aXJlKCcuL2VuY3J5cHRpb24taGVscGVyLmpzJyk7XG5jb25zdCBXZWJQdXNoTGliID0gcmVxdWlyZSgnLi93ZWItcHVzaC1saWIuanMnKTtcbmNvbnN0IFdlYlB1c2hFcnJvciA9IHJlcXVpcmUoJy4vd2ViLXB1c2gtZXJyb3IuanMnKTtcbmNvbnN0IFdlYlB1c2hDb25zdGFudHMgPSByZXF1aXJlKCcuL3dlYi1wdXNoLWNvbnN0YW50cy5qcycpO1xuXG5jb25zdCB3ZWJQdXNoID0gbmV3IFdlYlB1c2hMaWIoKTtcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIFdlYlB1c2hFcnJvcjogV2ViUHVzaEVycm9yLFxuICBzdXBwb3J0ZWRDb250ZW50RW5jb2RpbmdzOiBXZWJQdXNoQ29uc3RhbnRzLnN1cHBvcnRlZENvbnRlbnRFbmNvZGluZ3MsXG4gIGVuY3J5cHQ6IGVuY3J5cHRpb25IZWxwZXIuZW5jcnlwdCxcbiAgZ2V0VmFwaWRIZWFkZXJzOiB2YXBpZEhlbHBlci5nZXRWYXBpZEhlYWRlcnMsXG4gIGdlbmVyYXRlVkFQSURLZXlzOiB2YXBpZEhlbHBlci5nZW5lcmF0ZVZBUElES2V5cyxcbiAgc2V0R0NNQVBJS2V5OiB3ZWJQdXNoLnNldEdDTUFQSUtleSxcbiAgc2V0VmFwaWREZXRhaWxzOiB3ZWJQdXNoLnNldFZhcGlkRGV0YWlscyxcbiAgZ2VuZXJhdGVSZXF1ZXN0RGV0YWlsczogd2ViUHVzaC5nZW5lcmF0ZVJlcXVlc3REZXRhaWxzLFxuICBzZW5kTm90aWZpY2F0aW9uOiB3ZWJQdXNoLnNlbmROb3RpZmljYXRpb24uYmluZCh3ZWJQdXNoKVxufTtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/web-push/src/index.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/web-push/src/urlsafe-base64-helper.js":
/*!************************************************************!*\
  !*** ./node_modules/web-push/src/urlsafe-base64-helper.js ***!
  \************************************************************/
/***/ ((module) => {

eval("\n\n/**\n * @param {string} base64\n * @returns {boolean}\n */\nfunction validate(base64) {\n  return /^[A-Za-z0-9\\-_]+$/.test(base64);\n}\n\nmodule.exports = {\n  validate: validate\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvd2ViLXB1c2gvc3JjL3VybHNhZmUtYmFzZTY0LWhlbHBlci5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYjtBQUNBLFdBQVcsUUFBUTtBQUNuQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBIiwic291cmNlcyI6WyJEOlxcYXBsaWNhY2lvbmVzLWlhXFxuZXh0LXRhc2tcXG5vZGVfbW9kdWxlc1xcd2ViLXB1c2hcXHNyY1xcdXJsc2FmZS1iYXNlNjQtaGVscGVyLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gYmFzZTY0XG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAqL1xuZnVuY3Rpb24gdmFsaWRhdGUoYmFzZTY0KSB7XG4gIHJldHVybiAvXltBLVphLXowLTlcXC1fXSskLy50ZXN0KGJhc2U2NCk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICB2YWxpZGF0ZTogdmFsaWRhdGVcbn07XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/web-push/src/urlsafe-base64-helper.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/web-push/src/vapid-helper.js":
/*!***************************************************!*\
  !*** ./node_modules/web-push/src/vapid-helper.js ***!
  \***************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nconst crypto = __webpack_require__(/*! crypto */ \"crypto\");\nconst asn1 = __webpack_require__(/*! asn1.js */ \"(rsc)/./node_modules/asn1.js/lib/asn1.js\");\nconst jws = __webpack_require__(/*! jws */ \"(rsc)/./node_modules/jws/index.js\");\nconst { URL } = __webpack_require__(/*! url */ \"url\");\n\nconst WebPushConstants = __webpack_require__(/*! ./web-push-constants.js */ \"(rsc)/./node_modules/web-push/src/web-push-constants.js\");\nconst urlBase64Helper = __webpack_require__(/*! ./urlsafe-base64-helper */ \"(rsc)/./node_modules/web-push/src/urlsafe-base64-helper.js\");\n\n/**\n * DEFAULT_EXPIRATION is set to seconds in 12 hours\n */\nconst DEFAULT_EXPIRATION_SECONDS = 12 * 60 * 60;\n\n// Maximum expiration is 24 hours according. (See VAPID spec)\nconst MAX_EXPIRATION_SECONDS = 24 * 60 * 60;\n\nconst ECPrivateKeyASN = asn1.define('ECPrivateKey', function() {\n  this.seq().obj(\n    this.key('version').int(),\n    this.key('privateKey').octstr(),\n    this.key('parameters').explicit(0).objid()\n      .optional(),\n    this.key('publicKey').explicit(1).bitstr()\n      .optional()\n  );\n});\n\nfunction toPEM(key) {\n  return ECPrivateKeyASN.encode({\n    version: 1,\n    privateKey: key,\n    parameters: [1, 2, 840, 10045, 3, 1, 7] // prime256v1\n  }, 'pem', {\n    label: 'EC PRIVATE KEY'\n  });\n}\n\nfunction generateVAPIDKeys() {\n  const curve = crypto.createECDH('prime256v1');\n  curve.generateKeys();\n\n  let publicKeyBuffer = curve.getPublicKey();\n  let privateKeyBuffer = curve.getPrivateKey();\n\n  // Occassionally the keys will not be padded to the correct lengh resulting\n  // in errors, hence this padding.\n  // See https://github.com/web-push-libs/web-push/issues/295 for history.\n  if (privateKeyBuffer.length < 32) {\n    const padding = Buffer.alloc(32 - privateKeyBuffer.length);\n    padding.fill(0);\n    privateKeyBuffer = Buffer.concat([padding, privateKeyBuffer]);\n  }\n\n  if (publicKeyBuffer.length < 65) {\n    const padding = Buffer.alloc(65 - publicKeyBuffer.length);\n    padding.fill(0);\n    publicKeyBuffer = Buffer.concat([padding, publicKeyBuffer]);\n  }\n\n  return {\n    publicKey: publicKeyBuffer.toString('base64url'),\n    privateKey: privateKeyBuffer.toString('base64url')\n  };\n}\n\nfunction validateSubject(subject) {\n  if (!subject) {\n    throw new Error('No subject set in vapidDetails.subject.');\n  }\n\n  if (typeof subject !== 'string' || subject.length === 0) {\n    throw new Error('The subject value must be a string containing an https: URL or '\n    + 'mailto: address. ' + subject);\n  }\n\n  let subjectParseResult = null;\n  try {\n    subjectParseResult = new URL(subject);\n  } catch (err) {\n    throw new Error('Vapid subject is not a valid URL. ' + subject);\n  }\n  if (!['https:', 'mailto:'].includes(subjectParseResult.protocol)) {\n    throw new Error('Vapid subject is not an https: or mailto: URL. ' + subject);\n  }\n  if (subjectParseResult.hostname === 'localhost') {\n    console.warn('Vapid subject points to a localhost web URI, which is unsupported by '\n      + 'Apple\\'s push notification server and will result in a BadJwtToken error when '\n      + 'sending notifications.');\n    }\n}\n\nfunction validatePublicKey(publicKey) {\n  if (!publicKey) {\n    throw new Error('No key set vapidDetails.publicKey');\n  }\n\n  if (typeof publicKey !== 'string') {\n    throw new Error('Vapid public key is must be a URL safe Base 64 '\n    + 'encoded string.');\n  }\n\n  if (!urlBase64Helper.validate(publicKey)) {\n    throw new Error('Vapid public key must be a URL safe Base 64 (without \"=\")');\n  }\n\n  publicKey = Buffer.from(publicKey, 'base64url');\n\n  if (publicKey.length !== 65) {\n    throw new Error('Vapid public key should be 65 bytes long when decoded.');\n  }\n}\n\nfunction validatePrivateKey(privateKey) {\n  if (!privateKey) {\n    throw new Error('No key set in vapidDetails.privateKey');\n  }\n\n  if (typeof privateKey !== 'string') {\n    throw new Error('Vapid private key must be a URL safe Base 64 '\n    + 'encoded string.');\n  }\n\n  if (!urlBase64Helper.validate(privateKey)) {\n    throw new Error('Vapid private key must be a URL safe Base 64 (without \"=\")');\n  }\n\n  privateKey = Buffer.from(privateKey, 'base64url');\n\n  if (privateKey.length !== 32) {\n    throw new Error('Vapid private key should be 32 bytes long when decoded.');\n  }\n}\n\n/**\n * Given the number of seconds calculates\n * the expiration in the future by adding the passed `numSeconds`\n * with the current seconds from Unix Epoch\n *\n * @param {Number} numSeconds Number of seconds to be added\n * @return {Number} Future expiration in seconds\n */\nfunction getFutureExpirationTimestamp(numSeconds) {\n  const futureExp = new Date();\n  futureExp.setSeconds(futureExp.getSeconds() + numSeconds);\n  return Math.floor(futureExp.getTime() / 1000);\n}\n\n/**\n * Validates the Expiration Header based on the VAPID Spec\n * Throws error of type `Error` if the expiration is not validated\n *\n * @param {Number} expiration Expiration seconds from Epoch to be validated\n */\nfunction validateExpiration(expiration) {\n  if (!Number.isInteger(expiration)) {\n    throw new Error('`expiration` value must be a number');\n  }\n\n  if (expiration < 0) {\n    throw new Error('`expiration` must be a positive integer');\n  }\n\n  // Roughly checks the time of expiration, since the max expiration can be ahead\n  // of the time than at the moment the expiration was generated\n  const maxExpirationTimestamp = getFutureExpirationTimestamp(MAX_EXPIRATION_SECONDS);\n\n  if (expiration >= maxExpirationTimestamp) {\n    throw new Error('`expiration` value is greater than maximum of 24 hours');\n  }\n}\n\n/**\n * This method takes the required VAPID parameters and returns the required\n * header to be added to a Web Push Protocol Request.\n * @param  {string} audience        This must be the origin of the push service.\n * @param  {string} subject         This should be a URL or a 'mailto:' email\n * address.\n * @param  {string} publicKey       The VAPID public key.\n * @param  {string} privateKey      The VAPID private key.\n * @param  {string} contentEncoding The contentEncoding type.\n * @param  {integer} [expiration]   The expiration of the VAPID JWT.\n * @return {Object}                 Returns an Object with the Authorization and\n * 'Crypto-Key' values to be used as headers.\n */\nfunction getVapidHeaders(audience, subject, publicKey, privateKey, contentEncoding, expiration) {\n  if (!audience) {\n    throw new Error('No audience could be generated for VAPID.');\n  }\n\n  if (typeof audience !== 'string' || audience.length === 0) {\n    throw new Error('The audience value must be a string containing the '\n    + 'origin of a push service. ' + audience);\n  }\n\n  try {\n    new URL(audience); // eslint-disable-line no-new\n  } catch (err) {\n    throw new Error('VAPID audience is not a url. ' + audience);\n  }\n\n  validateSubject(subject);\n  validatePublicKey(publicKey);\n  validatePrivateKey(privateKey);\n\n  privateKey = Buffer.from(privateKey, 'base64url');\n\n  if (expiration) {\n    validateExpiration(expiration);\n  } else {\n    expiration = getFutureExpirationTimestamp(DEFAULT_EXPIRATION_SECONDS);\n  }\n\n  const header = {\n    typ: 'JWT',\n    alg: 'ES256'\n  };\n\n  const jwtPayload = {\n    aud: audience,\n    exp: expiration,\n    sub: subject\n  };\n\n  const jwt = jws.sign({\n    header: header,\n    payload: jwtPayload,\n    privateKey: toPEM(privateKey)\n  });\n\n  if (contentEncoding === WebPushConstants.supportedContentEncodings.AES_128_GCM) {\n    return {\n      Authorization: 'vapid t=' + jwt + ', k=' + publicKey\n    };\n  }\n  if (contentEncoding === WebPushConstants.supportedContentEncodings.AES_GCM) {\n    return {\n      Authorization: 'WebPush ' + jwt,\n      'Crypto-Key': 'p256ecdsa=' + publicKey\n    };\n  }\n\n  throw new Error('Unsupported encoding type specified.');\n}\n\nmodule.exports = {\n  generateVAPIDKeys: generateVAPIDKeys,\n  getFutureExpirationTimestamp: getFutureExpirationTimestamp,\n  getVapidHeaders: getVapidHeaders,\n  validateSubject: validateSubject,\n  validatePublicKey: validatePublicKey,\n  validatePrivateKey: validatePrivateKey,\n  validateExpiration: validateExpiration\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvd2ViLXB1c2gvc3JjL3ZhcGlkLWhlbHBlci5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYixlQUFlLG1CQUFPLENBQUMsc0JBQVE7QUFDL0IsYUFBYSxtQkFBTyxDQUFDLHlEQUFTO0FBQzlCLFlBQVksbUJBQU8sQ0FBQyw4Q0FBSztBQUN6QixRQUFRLE1BQU0sRUFBRSxtQkFBTyxDQUFDLGdCQUFLOztBQUU3Qix5QkFBeUIsbUJBQU8sQ0FBQyx3RkFBeUI7QUFDMUQsd0JBQXdCLG1CQUFPLENBQUMsMkZBQXlCOztBQUV6RDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsWUFBWSxRQUFRO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBWSxRQUFRO0FBQ3BCLFlBQVksUUFBUTtBQUNwQjtBQUNBLFlBQVksUUFBUTtBQUNwQixZQUFZLFFBQVE7QUFDcEIsWUFBWSxRQUFRO0FBQ3BCLFlBQVksU0FBUztBQUNyQixZQUFZLHdCQUF3QjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx1QkFBdUI7QUFDdkIsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJEOlxcYXBsaWNhY2lvbmVzLWlhXFxuZXh0LXRhc2tcXG5vZGVfbW9kdWxlc1xcd2ViLXB1c2hcXHNyY1xcdmFwaWQtaGVscGVyLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuY29uc3QgY3J5cHRvID0gcmVxdWlyZSgnY3J5cHRvJyk7XG5jb25zdCBhc24xID0gcmVxdWlyZSgnYXNuMS5qcycpO1xuY29uc3QgandzID0gcmVxdWlyZSgnandzJyk7XG5jb25zdCB7IFVSTCB9ID0gcmVxdWlyZSgndXJsJyk7XG5cbmNvbnN0IFdlYlB1c2hDb25zdGFudHMgPSByZXF1aXJlKCcuL3dlYi1wdXNoLWNvbnN0YW50cy5qcycpO1xuY29uc3QgdXJsQmFzZTY0SGVscGVyID0gcmVxdWlyZSgnLi91cmxzYWZlLWJhc2U2NC1oZWxwZXInKTtcblxuLyoqXG4gKiBERUZBVUxUX0VYUElSQVRJT04gaXMgc2V0IHRvIHNlY29uZHMgaW4gMTIgaG91cnNcbiAqL1xuY29uc3QgREVGQVVMVF9FWFBJUkFUSU9OX1NFQ09ORFMgPSAxMiAqIDYwICogNjA7XG5cbi8vIE1heGltdW0gZXhwaXJhdGlvbiBpcyAyNCBob3VycyBhY2NvcmRpbmcuIChTZWUgVkFQSUQgc3BlYylcbmNvbnN0IE1BWF9FWFBJUkFUSU9OX1NFQ09ORFMgPSAyNCAqIDYwICogNjA7XG5cbmNvbnN0IEVDUHJpdmF0ZUtleUFTTiA9IGFzbjEuZGVmaW5lKCdFQ1ByaXZhdGVLZXknLCBmdW5jdGlvbigpIHtcbiAgdGhpcy5zZXEoKS5vYmooXG4gICAgdGhpcy5rZXkoJ3ZlcnNpb24nKS5pbnQoKSxcbiAgICB0aGlzLmtleSgncHJpdmF0ZUtleScpLm9jdHN0cigpLFxuICAgIHRoaXMua2V5KCdwYXJhbWV0ZXJzJykuZXhwbGljaXQoMCkub2JqaWQoKVxuICAgICAgLm9wdGlvbmFsKCksXG4gICAgdGhpcy5rZXkoJ3B1YmxpY0tleScpLmV4cGxpY2l0KDEpLmJpdHN0cigpXG4gICAgICAub3B0aW9uYWwoKVxuICApO1xufSk7XG5cbmZ1bmN0aW9uIHRvUEVNKGtleSkge1xuICByZXR1cm4gRUNQcml2YXRlS2V5QVNOLmVuY29kZSh7XG4gICAgdmVyc2lvbjogMSxcbiAgICBwcml2YXRlS2V5OiBrZXksXG4gICAgcGFyYW1ldGVyczogWzEsIDIsIDg0MCwgMTAwNDUsIDMsIDEsIDddIC8vIHByaW1lMjU2djFcbiAgfSwgJ3BlbScsIHtcbiAgICBsYWJlbDogJ0VDIFBSSVZBVEUgS0VZJ1xuICB9KTtcbn1cblxuZnVuY3Rpb24gZ2VuZXJhdGVWQVBJREtleXMoKSB7XG4gIGNvbnN0IGN1cnZlID0gY3J5cHRvLmNyZWF0ZUVDREgoJ3ByaW1lMjU2djEnKTtcbiAgY3VydmUuZ2VuZXJhdGVLZXlzKCk7XG5cbiAgbGV0IHB1YmxpY0tleUJ1ZmZlciA9IGN1cnZlLmdldFB1YmxpY0tleSgpO1xuICBsZXQgcHJpdmF0ZUtleUJ1ZmZlciA9IGN1cnZlLmdldFByaXZhdGVLZXkoKTtcblxuICAvLyBPY2Nhc3Npb25hbGx5IHRoZSBrZXlzIHdpbGwgbm90IGJlIHBhZGRlZCB0byB0aGUgY29ycmVjdCBsZW5naCByZXN1bHRpbmdcbiAgLy8gaW4gZXJyb3JzLCBoZW5jZSB0aGlzIHBhZGRpbmcuXG4gIC8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vd2ViLXB1c2gtbGlicy93ZWItcHVzaC9pc3N1ZXMvMjk1IGZvciBoaXN0b3J5LlxuICBpZiAocHJpdmF0ZUtleUJ1ZmZlci5sZW5ndGggPCAzMikge1xuICAgIGNvbnN0IHBhZGRpbmcgPSBCdWZmZXIuYWxsb2MoMzIgLSBwcml2YXRlS2V5QnVmZmVyLmxlbmd0aCk7XG4gICAgcGFkZGluZy5maWxsKDApO1xuICAgIHByaXZhdGVLZXlCdWZmZXIgPSBCdWZmZXIuY29uY2F0KFtwYWRkaW5nLCBwcml2YXRlS2V5QnVmZmVyXSk7XG4gIH1cblxuICBpZiAocHVibGljS2V5QnVmZmVyLmxlbmd0aCA8IDY1KSB7XG4gICAgY29uc3QgcGFkZGluZyA9IEJ1ZmZlci5hbGxvYyg2NSAtIHB1YmxpY0tleUJ1ZmZlci5sZW5ndGgpO1xuICAgIHBhZGRpbmcuZmlsbCgwKTtcbiAgICBwdWJsaWNLZXlCdWZmZXIgPSBCdWZmZXIuY29uY2F0KFtwYWRkaW5nLCBwdWJsaWNLZXlCdWZmZXJdKTtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgcHVibGljS2V5OiBwdWJsaWNLZXlCdWZmZXIudG9TdHJpbmcoJ2Jhc2U2NHVybCcpLFxuICAgIHByaXZhdGVLZXk6IHByaXZhdGVLZXlCdWZmZXIudG9TdHJpbmcoJ2Jhc2U2NHVybCcpXG4gIH07XG59XG5cbmZ1bmN0aW9uIHZhbGlkYXRlU3ViamVjdChzdWJqZWN0KSB7XG4gIGlmICghc3ViamVjdCkge1xuICAgIHRocm93IG5ldyBFcnJvcignTm8gc3ViamVjdCBzZXQgaW4gdmFwaWREZXRhaWxzLnN1YmplY3QuJyk7XG4gIH1cblxuICBpZiAodHlwZW9mIHN1YmplY3QgIT09ICdzdHJpbmcnIHx8IHN1YmplY3QubGVuZ3RoID09PSAwKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdUaGUgc3ViamVjdCB2YWx1ZSBtdXN0IGJlIGEgc3RyaW5nIGNvbnRhaW5pbmcgYW4gaHR0cHM6IFVSTCBvciAnXG4gICAgKyAnbWFpbHRvOiBhZGRyZXNzLiAnICsgc3ViamVjdCk7XG4gIH1cblxuICBsZXQgc3ViamVjdFBhcnNlUmVzdWx0ID0gbnVsbDtcbiAgdHJ5IHtcbiAgICBzdWJqZWN0UGFyc2VSZXN1bHQgPSBuZXcgVVJMKHN1YmplY3QpO1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1ZhcGlkIHN1YmplY3QgaXMgbm90IGEgdmFsaWQgVVJMLiAnICsgc3ViamVjdCk7XG4gIH1cbiAgaWYgKCFbJ2h0dHBzOicsICdtYWlsdG86J10uaW5jbHVkZXMoc3ViamVjdFBhcnNlUmVzdWx0LnByb3RvY29sKSkge1xuICAgIHRocm93IG5ldyBFcnJvcignVmFwaWQgc3ViamVjdCBpcyBub3QgYW4gaHR0cHM6IG9yIG1haWx0bzogVVJMLiAnICsgc3ViamVjdCk7XG4gIH1cbiAgaWYgKHN1YmplY3RQYXJzZVJlc3VsdC5ob3N0bmFtZSA9PT0gJ2xvY2FsaG9zdCcpIHtcbiAgICBjb25zb2xlLndhcm4oJ1ZhcGlkIHN1YmplY3QgcG9pbnRzIHRvIGEgbG9jYWxob3N0IHdlYiBVUkksIHdoaWNoIGlzIHVuc3VwcG9ydGVkIGJ5ICdcbiAgICAgICsgJ0FwcGxlXFwncyBwdXNoIG5vdGlmaWNhdGlvbiBzZXJ2ZXIgYW5kIHdpbGwgcmVzdWx0IGluIGEgQmFkSnd0VG9rZW4gZXJyb3Igd2hlbiAnXG4gICAgICArICdzZW5kaW5nIG5vdGlmaWNhdGlvbnMuJyk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiB2YWxpZGF0ZVB1YmxpY0tleShwdWJsaWNLZXkpIHtcbiAgaWYgKCFwdWJsaWNLZXkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ05vIGtleSBzZXQgdmFwaWREZXRhaWxzLnB1YmxpY0tleScpO1xuICB9XG5cbiAgaWYgKHR5cGVvZiBwdWJsaWNLZXkgIT09ICdzdHJpbmcnKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdWYXBpZCBwdWJsaWMga2V5IGlzIG11c3QgYmUgYSBVUkwgc2FmZSBCYXNlIDY0ICdcbiAgICArICdlbmNvZGVkIHN0cmluZy4nKTtcbiAgfVxuXG4gIGlmICghdXJsQmFzZTY0SGVscGVyLnZhbGlkYXRlKHB1YmxpY0tleSkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1ZhcGlkIHB1YmxpYyBrZXkgbXVzdCBiZSBhIFVSTCBzYWZlIEJhc2UgNjQgKHdpdGhvdXQgXCI9XCIpJyk7XG4gIH1cblxuICBwdWJsaWNLZXkgPSBCdWZmZXIuZnJvbShwdWJsaWNLZXksICdiYXNlNjR1cmwnKTtcblxuICBpZiAocHVibGljS2V5Lmxlbmd0aCAhPT0gNjUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1ZhcGlkIHB1YmxpYyBrZXkgc2hvdWxkIGJlIDY1IGJ5dGVzIGxvbmcgd2hlbiBkZWNvZGVkLicpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHZhbGlkYXRlUHJpdmF0ZUtleShwcml2YXRlS2V5KSB7XG4gIGlmICghcHJpdmF0ZUtleSkge1xuICAgIHRocm93IG5ldyBFcnJvcignTm8ga2V5IHNldCBpbiB2YXBpZERldGFpbHMucHJpdmF0ZUtleScpO1xuICB9XG5cbiAgaWYgKHR5cGVvZiBwcml2YXRlS2V5ICE9PSAnc3RyaW5nJykge1xuICAgIHRocm93IG5ldyBFcnJvcignVmFwaWQgcHJpdmF0ZSBrZXkgbXVzdCBiZSBhIFVSTCBzYWZlIEJhc2UgNjQgJ1xuICAgICsgJ2VuY29kZWQgc3RyaW5nLicpO1xuICB9XG5cbiAgaWYgKCF1cmxCYXNlNjRIZWxwZXIudmFsaWRhdGUocHJpdmF0ZUtleSkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1ZhcGlkIHByaXZhdGUga2V5IG11c3QgYmUgYSBVUkwgc2FmZSBCYXNlIDY0ICh3aXRob3V0IFwiPVwiKScpO1xuICB9XG5cbiAgcHJpdmF0ZUtleSA9IEJ1ZmZlci5mcm9tKHByaXZhdGVLZXksICdiYXNlNjR1cmwnKTtcblxuICBpZiAocHJpdmF0ZUtleS5sZW5ndGggIT09IDMyKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdWYXBpZCBwcml2YXRlIGtleSBzaG91bGQgYmUgMzIgYnl0ZXMgbG9uZyB3aGVuIGRlY29kZWQuJyk7XG4gIH1cbn1cblxuLyoqXG4gKiBHaXZlbiB0aGUgbnVtYmVyIG9mIHNlY29uZHMgY2FsY3VsYXRlc1xuICogdGhlIGV4cGlyYXRpb24gaW4gdGhlIGZ1dHVyZSBieSBhZGRpbmcgdGhlIHBhc3NlZCBgbnVtU2Vjb25kc2BcbiAqIHdpdGggdGhlIGN1cnJlbnQgc2Vjb25kcyBmcm9tIFVuaXggRXBvY2hcbiAqXG4gKiBAcGFyYW0ge051bWJlcn0gbnVtU2Vjb25kcyBOdW1iZXIgb2Ygc2Vjb25kcyB0byBiZSBhZGRlZFxuICogQHJldHVybiB7TnVtYmVyfSBGdXR1cmUgZXhwaXJhdGlvbiBpbiBzZWNvbmRzXG4gKi9cbmZ1bmN0aW9uIGdldEZ1dHVyZUV4cGlyYXRpb25UaW1lc3RhbXAobnVtU2Vjb25kcykge1xuICBjb25zdCBmdXR1cmVFeHAgPSBuZXcgRGF0ZSgpO1xuICBmdXR1cmVFeHAuc2V0U2Vjb25kcyhmdXR1cmVFeHAuZ2V0U2Vjb25kcygpICsgbnVtU2Vjb25kcyk7XG4gIHJldHVybiBNYXRoLmZsb29yKGZ1dHVyZUV4cC5nZXRUaW1lKCkgLyAxMDAwKTtcbn1cblxuLyoqXG4gKiBWYWxpZGF0ZXMgdGhlIEV4cGlyYXRpb24gSGVhZGVyIGJhc2VkIG9uIHRoZSBWQVBJRCBTcGVjXG4gKiBUaHJvd3MgZXJyb3Igb2YgdHlwZSBgRXJyb3JgIGlmIHRoZSBleHBpcmF0aW9uIGlzIG5vdCB2YWxpZGF0ZWRcbiAqXG4gKiBAcGFyYW0ge051bWJlcn0gZXhwaXJhdGlvbiBFeHBpcmF0aW9uIHNlY29uZHMgZnJvbSBFcG9jaCB0byBiZSB2YWxpZGF0ZWRcbiAqL1xuZnVuY3Rpb24gdmFsaWRhdGVFeHBpcmF0aW9uKGV4cGlyYXRpb24pIHtcbiAgaWYgKCFOdW1iZXIuaXNJbnRlZ2VyKGV4cGlyYXRpb24pKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdgZXhwaXJhdGlvbmAgdmFsdWUgbXVzdCBiZSBhIG51bWJlcicpO1xuICB9XG5cbiAgaWYgKGV4cGlyYXRpb24gPCAwKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdgZXhwaXJhdGlvbmAgbXVzdCBiZSBhIHBvc2l0aXZlIGludGVnZXInKTtcbiAgfVxuXG4gIC8vIFJvdWdobHkgY2hlY2tzIHRoZSB0aW1lIG9mIGV4cGlyYXRpb24sIHNpbmNlIHRoZSBtYXggZXhwaXJhdGlvbiBjYW4gYmUgYWhlYWRcbiAgLy8gb2YgdGhlIHRpbWUgdGhhbiBhdCB0aGUgbW9tZW50IHRoZSBleHBpcmF0aW9uIHdhcyBnZW5lcmF0ZWRcbiAgY29uc3QgbWF4RXhwaXJhdGlvblRpbWVzdGFtcCA9IGdldEZ1dHVyZUV4cGlyYXRpb25UaW1lc3RhbXAoTUFYX0VYUElSQVRJT05fU0VDT05EUyk7XG5cbiAgaWYgKGV4cGlyYXRpb24gPj0gbWF4RXhwaXJhdGlvblRpbWVzdGFtcCkge1xuICAgIHRocm93IG5ldyBFcnJvcignYGV4cGlyYXRpb25gIHZhbHVlIGlzIGdyZWF0ZXIgdGhhbiBtYXhpbXVtIG9mIDI0IGhvdXJzJyk7XG4gIH1cbn1cblxuLyoqXG4gKiBUaGlzIG1ldGhvZCB0YWtlcyB0aGUgcmVxdWlyZWQgVkFQSUQgcGFyYW1ldGVycyBhbmQgcmV0dXJucyB0aGUgcmVxdWlyZWRcbiAqIGhlYWRlciB0byBiZSBhZGRlZCB0byBhIFdlYiBQdXNoIFByb3RvY29sIFJlcXVlc3QuXG4gKiBAcGFyYW0gIHtzdHJpbmd9IGF1ZGllbmNlICAgICAgICBUaGlzIG11c3QgYmUgdGhlIG9yaWdpbiBvZiB0aGUgcHVzaCBzZXJ2aWNlLlxuICogQHBhcmFtICB7c3RyaW5nfSBzdWJqZWN0ICAgICAgICAgVGhpcyBzaG91bGQgYmUgYSBVUkwgb3IgYSAnbWFpbHRvOicgZW1haWxcbiAqIGFkZHJlc3MuXG4gKiBAcGFyYW0gIHtzdHJpbmd9IHB1YmxpY0tleSAgICAgICBUaGUgVkFQSUQgcHVibGljIGtleS5cbiAqIEBwYXJhbSAge3N0cmluZ30gcHJpdmF0ZUtleSAgICAgIFRoZSBWQVBJRCBwcml2YXRlIGtleS5cbiAqIEBwYXJhbSAge3N0cmluZ30gY29udGVudEVuY29kaW5nIFRoZSBjb250ZW50RW5jb2RpbmcgdHlwZS5cbiAqIEBwYXJhbSAge2ludGVnZXJ9IFtleHBpcmF0aW9uXSAgIFRoZSBleHBpcmF0aW9uIG9mIHRoZSBWQVBJRCBKV1QuXG4gKiBAcmV0dXJuIHtPYmplY3R9ICAgICAgICAgICAgICAgICBSZXR1cm5zIGFuIE9iamVjdCB3aXRoIHRoZSBBdXRob3JpemF0aW9uIGFuZFxuICogJ0NyeXB0by1LZXknIHZhbHVlcyB0byBiZSB1c2VkIGFzIGhlYWRlcnMuXG4gKi9cbmZ1bmN0aW9uIGdldFZhcGlkSGVhZGVycyhhdWRpZW5jZSwgc3ViamVjdCwgcHVibGljS2V5LCBwcml2YXRlS2V5LCBjb250ZW50RW5jb2RpbmcsIGV4cGlyYXRpb24pIHtcbiAgaWYgKCFhdWRpZW5jZSkge1xuICAgIHRocm93IG5ldyBFcnJvcignTm8gYXVkaWVuY2UgY291bGQgYmUgZ2VuZXJhdGVkIGZvciBWQVBJRC4nKTtcbiAgfVxuXG4gIGlmICh0eXBlb2YgYXVkaWVuY2UgIT09ICdzdHJpbmcnIHx8IGF1ZGllbmNlLmxlbmd0aCA9PT0gMCkge1xuICAgIHRocm93IG5ldyBFcnJvcignVGhlIGF1ZGllbmNlIHZhbHVlIG11c3QgYmUgYSBzdHJpbmcgY29udGFpbmluZyB0aGUgJ1xuICAgICsgJ29yaWdpbiBvZiBhIHB1c2ggc2VydmljZS4gJyArIGF1ZGllbmNlKTtcbiAgfVxuXG4gIHRyeSB7XG4gICAgbmV3IFVSTChhdWRpZW5jZSk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tbmV3XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIHRocm93IG5ldyBFcnJvcignVkFQSUQgYXVkaWVuY2UgaXMgbm90IGEgdXJsLiAnICsgYXVkaWVuY2UpO1xuICB9XG5cbiAgdmFsaWRhdGVTdWJqZWN0KHN1YmplY3QpO1xuICB2YWxpZGF0ZVB1YmxpY0tleShwdWJsaWNLZXkpO1xuICB2YWxpZGF0ZVByaXZhdGVLZXkocHJpdmF0ZUtleSk7XG5cbiAgcHJpdmF0ZUtleSA9IEJ1ZmZlci5mcm9tKHByaXZhdGVLZXksICdiYXNlNjR1cmwnKTtcblxuICBpZiAoZXhwaXJhdGlvbikge1xuICAgIHZhbGlkYXRlRXhwaXJhdGlvbihleHBpcmF0aW9uKTtcbiAgfSBlbHNlIHtcbiAgICBleHBpcmF0aW9uID0gZ2V0RnV0dXJlRXhwaXJhdGlvblRpbWVzdGFtcChERUZBVUxUX0VYUElSQVRJT05fU0VDT05EUyk7XG4gIH1cblxuICBjb25zdCBoZWFkZXIgPSB7XG4gICAgdHlwOiAnSldUJyxcbiAgICBhbGc6ICdFUzI1NidcbiAgfTtcblxuICBjb25zdCBqd3RQYXlsb2FkID0ge1xuICAgIGF1ZDogYXVkaWVuY2UsXG4gICAgZXhwOiBleHBpcmF0aW9uLFxuICAgIHN1Yjogc3ViamVjdFxuICB9O1xuXG4gIGNvbnN0IGp3dCA9IGp3cy5zaWduKHtcbiAgICBoZWFkZXI6IGhlYWRlcixcbiAgICBwYXlsb2FkOiBqd3RQYXlsb2FkLFxuICAgIHByaXZhdGVLZXk6IHRvUEVNKHByaXZhdGVLZXkpXG4gIH0pO1xuXG4gIGlmIChjb250ZW50RW5jb2RpbmcgPT09IFdlYlB1c2hDb25zdGFudHMuc3VwcG9ydGVkQ29udGVudEVuY29kaW5ncy5BRVNfMTI4X0dDTSkge1xuICAgIHJldHVybiB7XG4gICAgICBBdXRob3JpemF0aW9uOiAndmFwaWQgdD0nICsgand0ICsgJywgaz0nICsgcHVibGljS2V5XG4gICAgfTtcbiAgfVxuICBpZiAoY29udGVudEVuY29kaW5nID09PSBXZWJQdXNoQ29uc3RhbnRzLnN1cHBvcnRlZENvbnRlbnRFbmNvZGluZ3MuQUVTX0dDTSkge1xuICAgIHJldHVybiB7XG4gICAgICBBdXRob3JpemF0aW9uOiAnV2ViUHVzaCAnICsgand0LFxuICAgICAgJ0NyeXB0by1LZXknOiAncDI1NmVjZHNhPScgKyBwdWJsaWNLZXlcbiAgICB9O1xuICB9XG5cbiAgdGhyb3cgbmV3IEVycm9yKCdVbnN1cHBvcnRlZCBlbmNvZGluZyB0eXBlIHNwZWNpZmllZC4nKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGdlbmVyYXRlVkFQSURLZXlzOiBnZW5lcmF0ZVZBUElES2V5cyxcbiAgZ2V0RnV0dXJlRXhwaXJhdGlvblRpbWVzdGFtcDogZ2V0RnV0dXJlRXhwaXJhdGlvblRpbWVzdGFtcCxcbiAgZ2V0VmFwaWRIZWFkZXJzOiBnZXRWYXBpZEhlYWRlcnMsXG4gIHZhbGlkYXRlU3ViamVjdDogdmFsaWRhdGVTdWJqZWN0LFxuICB2YWxpZGF0ZVB1YmxpY0tleTogdmFsaWRhdGVQdWJsaWNLZXksXG4gIHZhbGlkYXRlUHJpdmF0ZUtleTogdmFsaWRhdGVQcml2YXRlS2V5LFxuICB2YWxpZGF0ZUV4cGlyYXRpb246IHZhbGlkYXRlRXhwaXJhdGlvblxufTtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/web-push/src/vapid-helper.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/web-push/src/web-push-constants.js":
/*!*********************************************************!*\
  !*** ./node_modules/web-push/src/web-push-constants.js ***!
  \*********************************************************/
/***/ ((module) => {

eval("\n\nconst WebPushConstants = {};\n\nWebPushConstants.supportedContentEncodings = {\n  AES_GCM: 'aesgcm',\n  AES_128_GCM: 'aes128gcm'\n};\n\nWebPushConstants.supportedUrgency = {\n  VERY_LOW: 'very-low',\n  LOW: 'low',\n  NORMAL: 'normal',\n  HIGH: 'high'\n};\n\nmodule.exports = WebPushConstants;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvd2ViLXB1c2gvc3JjL3dlYi1wdXNoLWNvbnN0YW50cy5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEiLCJzb3VyY2VzIjpbIkQ6XFxhcGxpY2FjaW9uZXMtaWFcXG5leHQtdGFza1xcbm9kZV9tb2R1bGVzXFx3ZWItcHVzaFxcc3JjXFx3ZWItcHVzaC1jb25zdGFudHMuanMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBXZWJQdXNoQ29uc3RhbnRzID0ge307XG5cbldlYlB1c2hDb25zdGFudHMuc3VwcG9ydGVkQ29udGVudEVuY29kaW5ncyA9IHtcbiAgQUVTX0dDTTogJ2Flc2djbScsXG4gIEFFU18xMjhfR0NNOiAnYWVzMTI4Z2NtJ1xufTtcblxuV2ViUHVzaENvbnN0YW50cy5zdXBwb3J0ZWRVcmdlbmN5ID0ge1xuICBWRVJZX0xPVzogJ3ZlcnktbG93JyxcbiAgTE9XOiAnbG93JyxcbiAgTk9STUFMOiAnbm9ybWFsJyxcbiAgSElHSDogJ2hpZ2gnXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFdlYlB1c2hDb25zdGFudHM7XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/web-push/src/web-push-constants.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/web-push/src/web-push-error.js":
/*!*****************************************************!*\
  !*** ./node_modules/web-push/src/web-push-error.js ***!
  \*****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nfunction WebPushError(message, statusCode, headers, body, endpoint) {\n  Error.captureStackTrace(this, this.constructor);\n\n  this.name = this.constructor.name;\n  this.message = message;\n  this.statusCode = statusCode;\n  this.headers = headers;\n  this.body = body;\n  this.endpoint = endpoint;\n}\n\n(__webpack_require__(/*! util */ \"util\").inherits)(WebPushError, Error);\n\nmodule.exports = WebPushError;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvd2ViLXB1c2gvc3JjL3dlYi1wdXNoLWVycm9yLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsa0RBQXdCOztBQUV4QiIsInNvdXJjZXMiOlsiRDpcXGFwbGljYWNpb25lcy1pYVxcbmV4dC10YXNrXFxub2RlX21vZHVsZXNcXHdlYi1wdXNoXFxzcmNcXHdlYi1wdXNoLWVycm9yLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuZnVuY3Rpb24gV2ViUHVzaEVycm9yKG1lc3NhZ2UsIHN0YXR1c0NvZGUsIGhlYWRlcnMsIGJvZHksIGVuZHBvaW50KSB7XG4gIEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKHRoaXMsIHRoaXMuY29uc3RydWN0b3IpO1xuXG4gIHRoaXMubmFtZSA9IHRoaXMuY29uc3RydWN0b3IubmFtZTtcbiAgdGhpcy5tZXNzYWdlID0gbWVzc2FnZTtcbiAgdGhpcy5zdGF0dXNDb2RlID0gc3RhdHVzQ29kZTtcbiAgdGhpcy5oZWFkZXJzID0gaGVhZGVycztcbiAgdGhpcy5ib2R5ID0gYm9keTtcbiAgdGhpcy5lbmRwb2ludCA9IGVuZHBvaW50O1xufVxuXG5yZXF1aXJlKCd1dGlsJykuaW5oZXJpdHMoV2ViUHVzaEVycm9yLCBFcnJvcik7XG5cbm1vZHVsZS5leHBvcnRzID0gV2ViUHVzaEVycm9yO1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/web-push/src/web-push-error.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/web-push/src/web-push-lib.js":
/*!***************************************************!*\
  !*** ./node_modules/web-push/src/web-push-lib.js ***!
  \***************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nconst url = __webpack_require__(/*! url */ \"url\");\nconst https = __webpack_require__(/*! https */ \"https\");\n\nconst WebPushError = __webpack_require__(/*! ./web-push-error.js */ \"(rsc)/./node_modules/web-push/src/web-push-error.js\");\nconst vapidHelper = __webpack_require__(/*! ./vapid-helper.js */ \"(rsc)/./node_modules/web-push/src/vapid-helper.js\");\nconst encryptionHelper = __webpack_require__(/*! ./encryption-helper.js */ \"(rsc)/./node_modules/web-push/src/encryption-helper.js\");\nconst webPushConstants = __webpack_require__(/*! ./web-push-constants.js */ \"(rsc)/./node_modules/web-push/src/web-push-constants.js\");\nconst urlBase64Helper = __webpack_require__(/*! ./urlsafe-base64-helper */ \"(rsc)/./node_modules/web-push/src/urlsafe-base64-helper.js\");\n\n// Default TTL is four weeks.\nconst DEFAULT_TTL = 2419200;\n\nlet gcmAPIKey = '';\nlet vapidDetails;\n\nfunction WebPushLib() {\n\n}\n\n/**\n * When sending messages to a GCM endpoint you need to set the GCM API key\n * by either calling setGMAPIKey() or passing in the API key as an option\n * to sendNotification().\n * @param  {string} apiKey The API key to send with the GCM request.\n */\nWebPushLib.prototype.setGCMAPIKey = function(apiKey) {\n  if (apiKey === null) {\n    gcmAPIKey = null;\n    return;\n  }\n\n  if (typeof apiKey === 'undefined'\n  || typeof apiKey !== 'string'\n  || apiKey.length === 0) {\n    throw new Error('The GCM API Key should be a non-empty string or null.');\n  }\n\n  gcmAPIKey = apiKey;\n};\n\n/**\n * When making requests where you want to define VAPID details, call this\n * method before sendNotification() or pass in the details and options to\n * sendNotification.\n * @param  {string} subject    This must be either a URL or a 'mailto:'\n * address. For example: 'https://my-site.com/contact' or\n * 'mailto: contact@my-site.com'\n * @param  {string} publicKey  The public VAPID key, a URL safe, base64 encoded string\n * @param  {string} privateKey The private VAPID key, a URL safe, base64 encoded string.\n */\nWebPushLib.prototype.setVapidDetails = function(subject, publicKey, privateKey) {\n    if (arguments.length === 1 && arguments[0] === null) {\n      vapidDetails = null;\n      return;\n    }\n\n    vapidHelper.validateSubject(subject);\n    vapidHelper.validatePublicKey(publicKey);\n    vapidHelper.validatePrivateKey(privateKey);\n\n    vapidDetails = {\n      subject: subject,\n      publicKey: publicKey,\n      privateKey: privateKey\n    };\n  };\n\n  /**\n   * To get the details of a request to trigger a push message, without sending\n   * a push notification call this method.\n   *\n   * This method will throw an error if there is an issue with the input.\n   * @param  {PushSubscription} subscription The PushSubscription you wish to\n   * send the notification to.\n   * @param  {string|Buffer} [payload]       The payload you wish to send to the\n   * the user.\n   * @param  {Object} [options]              Options for the GCM API key and\n   * vapid keys can be passed in if they are unique for each notification you\n   * wish to send.\n   * @return {Object}                       This method returns an Object which\n   * contains 'endpoint', 'method', 'headers' and 'payload'.\n   */\nWebPushLib.prototype.generateRequestDetails = function(subscription, payload, options) {\n    if (!subscription || !subscription.endpoint) {\n      throw new Error('You must pass in a subscription with at least '\n      + 'an endpoint.');\n    }\n\n    if (typeof subscription.endpoint !== 'string'\n    || subscription.endpoint.length === 0) {\n      throw new Error('The subscription endpoint must be a string with '\n      + 'a valid URL.');\n    }\n\n    if (payload) {\n      // Validate the subscription keys\n      if (typeof subscription !== 'object' || !subscription.keys\n      || !subscription.keys.p256dh\n      || !subscription.keys.auth) {\n        throw new Error('To send a message with a payload, the '\n        + 'subscription must have \\'auth\\' and \\'p256dh\\' keys.');\n      }\n    }\n\n    let currentGCMAPIKey = gcmAPIKey;\n    let currentVapidDetails = vapidDetails;\n    let timeToLive = DEFAULT_TTL;\n    let extraHeaders = {};\n    let contentEncoding = webPushConstants.supportedContentEncodings.AES_128_GCM;\n    let urgency = webPushConstants.supportedUrgency.NORMAL;\n    let topic;\n    let proxy;\n    let agent;\n    let timeout;\n\n    if (options) {\n      const validOptionKeys = [\n        'headers',\n        'gcmAPIKey',\n        'vapidDetails',\n        'TTL',\n        'contentEncoding',\n        'urgency',\n        'topic',\n        'proxy',\n        'agent',\n        'timeout'\n      ];\n      const optionKeys = Object.keys(options);\n      for (let i = 0; i < optionKeys.length; i += 1) {\n        const optionKey = optionKeys[i];\n        if (!validOptionKeys.includes(optionKey)) {\n          throw new Error('\\'' + optionKey + '\\' is an invalid option. '\n          + 'The valid options are [\\'' + validOptionKeys.join('\\', \\'')\n          + '\\'].');\n        }\n      }\n\n      if (options.headers) {\n        extraHeaders = options.headers;\n        let duplicates = Object.keys(extraHeaders)\n            .filter(function (header) {\n              return typeof options[header] !== 'undefined';\n            });\n\n        if (duplicates.length > 0) {\n          throw new Error('Duplicated headers defined ['\n          + duplicates.join(',') + ']. Please either define the header in the'\n          + 'top level options OR in the \\'headers\\' key.');\n        }\n      }\n\n      if (options.gcmAPIKey) {\n        currentGCMAPIKey = options.gcmAPIKey;\n      }\n\n      // Falsy values are allowed here so one can skip Vapid `else if` below and use FCM\n      if (options.vapidDetails !== undefined) {\n        currentVapidDetails = options.vapidDetails;\n      }\n\n      if (options.TTL !== undefined) {\n        timeToLive = Number(options.TTL);\n        if (timeToLive < 0) {\n          throw new Error('TTL should be a number and should be at least 0');\n        }\n      }\n\n      if (options.contentEncoding) {\n        if ((options.contentEncoding === webPushConstants.supportedContentEncodings.AES_128_GCM\n          || options.contentEncoding === webPushConstants.supportedContentEncodings.AES_GCM)) {\n          contentEncoding = options.contentEncoding;\n        } else {\n          throw new Error('Unsupported content encoding specified.');\n        }\n      }\n\n      if (options.urgency) {\n        if ((options.urgency === webPushConstants.supportedUrgency.VERY_LOW\n          || options.urgency === webPushConstants.supportedUrgency.LOW\n          || options.urgency === webPushConstants.supportedUrgency.NORMAL\n          || options.urgency === webPushConstants.supportedUrgency.HIGH)) {\n          urgency = options.urgency;\n        } else {\n          throw new Error('Unsupported urgency specified.');\n        }\n      }\n\n      if (options.topic) {\n        if (!urlBase64Helper.validate(options.topic)) {\n          throw new Error('Unsupported characters set use the URL or filename-safe Base64 characters set');\n        }\n        if (options.topic.length > 32) {\n          throw new Error('use maximum of 32 characters from the URL or filename-safe Base64 characters set');\n        }\n        topic = options.topic;\n      }\n\n      if (options.proxy) {\n        if (typeof options.proxy === 'string'\n          || typeof options.proxy.host === 'string') {\n          proxy = options.proxy;\n        } else {\n          console.warn('Attempt to use proxy option, but invalid type it should be a string or proxy options object.');\n        }\n      }\n\n      if (options.agent) {\n        if (options.agent instanceof https.Agent) {\n          if (proxy) {\n            console.warn('Agent option will be ignored because proxy option is defined.');\n          }\n\n          agent = options.agent;\n        } else {\n          console.warn('Wrong type for the agent option, it should be an instance of https.Agent.');\n        }\n      }\n\n      if (typeof options.timeout === 'number') {\n        timeout = options.timeout;\n      }\n    }\n\n    if (typeof timeToLive === 'undefined') {\n      timeToLive = DEFAULT_TTL;\n    }\n\n    const requestDetails = {\n      method: 'POST',\n      headers: {\n        TTL: timeToLive\n      }\n    };\n    Object.keys(extraHeaders).forEach(function (header) {\n      requestDetails.headers[header] = extraHeaders[header];\n    });\n    let requestPayload = null;\n\n    if (payload) {\n      const encrypted = encryptionHelper\n        .encrypt(subscription.keys.p256dh, subscription.keys.auth, payload, contentEncoding);\n\n      requestDetails.headers['Content-Length'] = encrypted.cipherText.length;\n      requestDetails.headers['Content-Type'] = 'application/octet-stream';\n\n      if (contentEncoding === webPushConstants.supportedContentEncodings.AES_128_GCM) {\n        requestDetails.headers['Content-Encoding'] = webPushConstants.supportedContentEncodings.AES_128_GCM;\n      } else if (contentEncoding === webPushConstants.supportedContentEncodings.AES_GCM) {\n        requestDetails.headers['Content-Encoding'] = webPushConstants.supportedContentEncodings.AES_GCM;\n        requestDetails.headers.Encryption = 'salt=' + encrypted.salt;\n        requestDetails.headers['Crypto-Key'] = 'dh=' + encrypted.localPublicKey.toString('base64url');\n      }\n\n      requestPayload = encrypted.cipherText;\n    } else {\n      requestDetails.headers['Content-Length'] = 0;\n    }\n\n    const isGCM = subscription.endpoint.startsWith('https://android.googleapis.com/gcm/send');\n    const isFCM = subscription.endpoint.startsWith('https://fcm.googleapis.com/fcm/send');\n    // VAPID isn't supported by GCM hence the if, else if.\n    if (isGCM) {\n      if (!currentGCMAPIKey) {\n        console.warn('Attempt to send push notification to GCM endpoint, '\n        + 'but no GCM key is defined. Please use setGCMApiKey() or add '\n        + '\\'gcmAPIKey\\' as an option.');\n      } else {\n        requestDetails.headers.Authorization = 'key=' + currentGCMAPIKey;\n      }\n    } else if (currentVapidDetails) {\n      const parsedUrl = url.parse(subscription.endpoint);\n      const audience = parsedUrl.protocol + '//'\n      + parsedUrl.host;\n\n      const vapidHeaders = vapidHelper.getVapidHeaders(\n        audience,\n        currentVapidDetails.subject,\n        currentVapidDetails.publicKey,\n        currentVapidDetails.privateKey,\n        contentEncoding\n      );\n\n      requestDetails.headers.Authorization = vapidHeaders.Authorization;\n\n      if (contentEncoding === webPushConstants.supportedContentEncodings.AES_GCM) {\n        if (requestDetails.headers['Crypto-Key']) {\n          requestDetails.headers['Crypto-Key'] += ';'\n          + vapidHeaders['Crypto-Key'];\n        } else {\n          requestDetails.headers['Crypto-Key'] = vapidHeaders['Crypto-Key'];\n        }\n      }\n    } else if (isFCM && currentGCMAPIKey) {\n      requestDetails.headers.Authorization = 'key=' + currentGCMAPIKey;\n    }\n\n    requestDetails.headers.Urgency = urgency;\n\n    if (topic) {\n      requestDetails.headers.Topic = topic;\n    }\n\n    requestDetails.body = requestPayload;\n    requestDetails.endpoint = subscription.endpoint;\n\n    if (proxy) {\n      requestDetails.proxy = proxy;\n    }\n\n    if (agent) {\n      requestDetails.agent = agent;\n    }\n\n    if (timeout) {\n      requestDetails.timeout = timeout;\n    }\n\n    return requestDetails;\n  };\n\n/**\n * To send a push notification call this method with a subscription, optional\n * payload and any options.\n * @param  {PushSubscription} subscription The PushSubscription you wish to\n * send the notification to.\n * @param  {string|Buffer} [payload]       The payload you wish to send to the\n * the user.\n * @param  {Object} [options]              Options for the GCM API key and\n * vapid keys can be passed in if they are unique for each notification you\n * wish to send.\n * @return {Promise}                       This method returns a Promise which\n * resolves if the sending of the notification was successful, otherwise it\n * rejects.\n */\nWebPushLib.prototype.sendNotification = function(subscription, payload, options) {\n    let requestDetails;\n    try {\n      requestDetails = this.generateRequestDetails(subscription, payload, options);\n    } catch (err) {\n      return Promise.reject(err);\n    }\n\n    return new Promise(function(resolve, reject) {\n      const httpsOptions = {};\n      const urlParts = url.parse(requestDetails.endpoint);\n      httpsOptions.hostname = urlParts.hostname;\n      httpsOptions.port = urlParts.port;\n      httpsOptions.path = urlParts.path;\n\n      httpsOptions.headers = requestDetails.headers;\n      httpsOptions.method = requestDetails.method;\n\n      if (requestDetails.timeout) {\n        httpsOptions.timeout = requestDetails.timeout;\n      }\n\n      if (requestDetails.agent) {\n        httpsOptions.agent = requestDetails.agent;\n      }\n\n      if (requestDetails.proxy) {\n        const { HttpsProxyAgent } = __webpack_require__(/*! https-proxy-agent */ \"(rsc)/./node_modules/https-proxy-agent/dist/index.js\"); // eslint-disable-line global-require\n        httpsOptions.agent = new HttpsProxyAgent(requestDetails.proxy);\n      }\n\n      const pushRequest = https.request(httpsOptions, function(pushResponse) {\n        let responseText = '';\n\n        pushResponse.on('data', function(chunk) {\n          responseText += chunk;\n        });\n\n        pushResponse.on('end', function() {\n          if (pushResponse.statusCode < 200 || pushResponse.statusCode > 299) {\n            reject(new WebPushError(\n              'Received unexpected response code',\n              pushResponse.statusCode,\n              pushResponse.headers,\n              responseText,\n              requestDetails.endpoint\n            ));\n          } else {\n            resolve({\n              statusCode: pushResponse.statusCode,\n              body: responseText,\n              headers: pushResponse.headers\n            });\n          }\n        });\n      });\n\n      if (requestDetails.timeout) {\n        pushRequest.on('timeout', function() {\n          pushRequest.destroy(new Error('Socket timeout'));\n        });\n      }\n\n      pushRequest.on('error', function(e) {\n        reject(e);\n      });\n\n      if (requestDetails.body) {\n        pushRequest.write(requestDetails.body);\n      }\n\n      pushRequest.end();\n    });\n  };\n\nmodule.exports = WebPushLib;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvd2ViLXB1c2gvc3JjL3dlYi1wdXNoLWxpYi5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYixZQUFZLG1CQUFPLENBQUMsZ0JBQUs7QUFDekIsY0FBYyxtQkFBTyxDQUFDLG9CQUFPOztBQUU3QixxQkFBcUIsbUJBQU8sQ0FBQyxnRkFBcUI7QUFDbEQsb0JBQW9CLG1CQUFPLENBQUMsNEVBQW1CO0FBQy9DLHlCQUF5QixtQkFBTyxDQUFDLHNGQUF3QjtBQUN6RCx5QkFBeUIsbUJBQU8sQ0FBQyx3RkFBeUI7QUFDMUQsd0JBQXdCLG1CQUFPLENBQUMsMkZBQXlCOztBQUV6RDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLFFBQVE7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksUUFBUTtBQUNwQjtBQUNBO0FBQ0EsWUFBWSxRQUFRO0FBQ3BCLFlBQVksUUFBUTtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxrQkFBa0I7QUFDaEM7QUFDQSxjQUFjLGVBQWU7QUFDN0I7QUFDQSxjQUFjLFFBQVE7QUFDdEI7QUFDQTtBQUNBLGNBQWMsOEJBQThCO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsdUJBQXVCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhOztBQUViO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLG9EQUFvRDtBQUNwRDtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVksa0JBQWtCO0FBQzlCO0FBQ0EsWUFBWSxlQUFlO0FBQzNCO0FBQ0EsWUFBWSxRQUFRO0FBQ3BCO0FBQ0E7QUFDQSxZQUFZLCtCQUErQjtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxnQkFBZ0Isa0JBQWtCLEVBQUUsbUJBQU8sQ0FBQywrRUFBbUIsR0FBRztBQUNsRTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsU0FBUztBQUNULE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDs7QUFFQSIsInNvdXJjZXMiOlsiRDpcXGFwbGljYWNpb25lcy1pYVxcbmV4dC10YXNrXFxub2RlX21vZHVsZXNcXHdlYi1wdXNoXFxzcmNcXHdlYi1wdXNoLWxpYi5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbmNvbnN0IHVybCA9IHJlcXVpcmUoJ3VybCcpO1xuY29uc3QgaHR0cHMgPSByZXF1aXJlKCdodHRwcycpO1xuXG5jb25zdCBXZWJQdXNoRXJyb3IgPSByZXF1aXJlKCcuL3dlYi1wdXNoLWVycm9yLmpzJyk7XG5jb25zdCB2YXBpZEhlbHBlciA9IHJlcXVpcmUoJy4vdmFwaWQtaGVscGVyLmpzJyk7XG5jb25zdCBlbmNyeXB0aW9uSGVscGVyID0gcmVxdWlyZSgnLi9lbmNyeXB0aW9uLWhlbHBlci5qcycpO1xuY29uc3Qgd2ViUHVzaENvbnN0YW50cyA9IHJlcXVpcmUoJy4vd2ViLXB1c2gtY29uc3RhbnRzLmpzJyk7XG5jb25zdCB1cmxCYXNlNjRIZWxwZXIgPSByZXF1aXJlKCcuL3VybHNhZmUtYmFzZTY0LWhlbHBlcicpO1xuXG4vLyBEZWZhdWx0IFRUTCBpcyBmb3VyIHdlZWtzLlxuY29uc3QgREVGQVVMVF9UVEwgPSAyNDE5MjAwO1xuXG5sZXQgZ2NtQVBJS2V5ID0gJyc7XG5sZXQgdmFwaWREZXRhaWxzO1xuXG5mdW5jdGlvbiBXZWJQdXNoTGliKCkge1xuXG59XG5cbi8qKlxuICogV2hlbiBzZW5kaW5nIG1lc3NhZ2VzIHRvIGEgR0NNIGVuZHBvaW50IHlvdSBuZWVkIHRvIHNldCB0aGUgR0NNIEFQSSBrZXlcbiAqIGJ5IGVpdGhlciBjYWxsaW5nIHNldEdNQVBJS2V5KCkgb3IgcGFzc2luZyBpbiB0aGUgQVBJIGtleSBhcyBhbiBvcHRpb25cbiAqIHRvIHNlbmROb3RpZmljYXRpb24oKS5cbiAqIEBwYXJhbSAge3N0cmluZ30gYXBpS2V5IFRoZSBBUEkga2V5IHRvIHNlbmQgd2l0aCB0aGUgR0NNIHJlcXVlc3QuXG4gKi9cbldlYlB1c2hMaWIucHJvdG90eXBlLnNldEdDTUFQSUtleSA9IGZ1bmN0aW9uKGFwaUtleSkge1xuICBpZiAoYXBpS2V5ID09PSBudWxsKSB7XG4gICAgZ2NtQVBJS2V5ID0gbnVsbDtcbiAgICByZXR1cm47XG4gIH1cblxuICBpZiAodHlwZW9mIGFwaUtleSA9PT0gJ3VuZGVmaW5lZCdcbiAgfHwgdHlwZW9mIGFwaUtleSAhPT0gJ3N0cmluZydcbiAgfHwgYXBpS2V5Lmxlbmd0aCA9PT0gMCkge1xuICAgIHRocm93IG5ldyBFcnJvcignVGhlIEdDTSBBUEkgS2V5IHNob3VsZCBiZSBhIG5vbi1lbXB0eSBzdHJpbmcgb3IgbnVsbC4nKTtcbiAgfVxuXG4gIGdjbUFQSUtleSA9IGFwaUtleTtcbn07XG5cbi8qKlxuICogV2hlbiBtYWtpbmcgcmVxdWVzdHMgd2hlcmUgeW91IHdhbnQgdG8gZGVmaW5lIFZBUElEIGRldGFpbHMsIGNhbGwgdGhpc1xuICogbWV0aG9kIGJlZm9yZSBzZW5kTm90aWZpY2F0aW9uKCkgb3IgcGFzcyBpbiB0aGUgZGV0YWlscyBhbmQgb3B0aW9ucyB0b1xuICogc2VuZE5vdGlmaWNhdGlvbi5cbiAqIEBwYXJhbSAge3N0cmluZ30gc3ViamVjdCAgICBUaGlzIG11c3QgYmUgZWl0aGVyIGEgVVJMIG9yIGEgJ21haWx0bzonXG4gKiBhZGRyZXNzLiBGb3IgZXhhbXBsZTogJ2h0dHBzOi8vbXktc2l0ZS5jb20vY29udGFjdCcgb3JcbiAqICdtYWlsdG86IGNvbnRhY3RAbXktc2l0ZS5jb20nXG4gKiBAcGFyYW0gIHtzdHJpbmd9IHB1YmxpY0tleSAgVGhlIHB1YmxpYyBWQVBJRCBrZXksIGEgVVJMIHNhZmUsIGJhc2U2NCBlbmNvZGVkIHN0cmluZ1xuICogQHBhcmFtICB7c3RyaW5nfSBwcml2YXRlS2V5IFRoZSBwcml2YXRlIFZBUElEIGtleSwgYSBVUkwgc2FmZSwgYmFzZTY0IGVuY29kZWQgc3RyaW5nLlxuICovXG5XZWJQdXNoTGliLnByb3RvdHlwZS5zZXRWYXBpZERldGFpbHMgPSBmdW5jdGlvbihzdWJqZWN0LCBwdWJsaWNLZXksIHByaXZhdGVLZXkpIHtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSAmJiBhcmd1bWVudHNbMF0gPT09IG51bGwpIHtcbiAgICAgIHZhcGlkRGV0YWlscyA9IG51bGw7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFwaWRIZWxwZXIudmFsaWRhdGVTdWJqZWN0KHN1YmplY3QpO1xuICAgIHZhcGlkSGVscGVyLnZhbGlkYXRlUHVibGljS2V5KHB1YmxpY0tleSk7XG4gICAgdmFwaWRIZWxwZXIudmFsaWRhdGVQcml2YXRlS2V5KHByaXZhdGVLZXkpO1xuXG4gICAgdmFwaWREZXRhaWxzID0ge1xuICAgICAgc3ViamVjdDogc3ViamVjdCxcbiAgICAgIHB1YmxpY0tleTogcHVibGljS2V5LFxuICAgICAgcHJpdmF0ZUtleTogcHJpdmF0ZUtleVxuICAgIH07XG4gIH07XG5cbiAgLyoqXG4gICAqIFRvIGdldCB0aGUgZGV0YWlscyBvZiBhIHJlcXVlc3QgdG8gdHJpZ2dlciBhIHB1c2ggbWVzc2FnZSwgd2l0aG91dCBzZW5kaW5nXG4gICAqIGEgcHVzaCBub3RpZmljYXRpb24gY2FsbCB0aGlzIG1ldGhvZC5cbiAgICpcbiAgICogVGhpcyBtZXRob2Qgd2lsbCB0aHJvdyBhbiBlcnJvciBpZiB0aGVyZSBpcyBhbiBpc3N1ZSB3aXRoIHRoZSBpbnB1dC5cbiAgICogQHBhcmFtICB7UHVzaFN1YnNjcmlwdGlvbn0gc3Vic2NyaXB0aW9uIFRoZSBQdXNoU3Vic2NyaXB0aW9uIHlvdSB3aXNoIHRvXG4gICAqIHNlbmQgdGhlIG5vdGlmaWNhdGlvbiB0by5cbiAgICogQHBhcmFtICB7c3RyaW5nfEJ1ZmZlcn0gW3BheWxvYWRdICAgICAgIFRoZSBwYXlsb2FkIHlvdSB3aXNoIHRvIHNlbmQgdG8gdGhlXG4gICAqIHRoZSB1c2VyLlxuICAgKiBAcGFyYW0gIHtPYmplY3R9IFtvcHRpb25zXSAgICAgICAgICAgICAgT3B0aW9ucyBmb3IgdGhlIEdDTSBBUEkga2V5IGFuZFxuICAgKiB2YXBpZCBrZXlzIGNhbiBiZSBwYXNzZWQgaW4gaWYgdGhleSBhcmUgdW5pcXVlIGZvciBlYWNoIG5vdGlmaWNhdGlvbiB5b3VcbiAgICogd2lzaCB0byBzZW5kLlxuICAgKiBAcmV0dXJuIHtPYmplY3R9ICAgICAgICAgICAgICAgICAgICAgICBUaGlzIG1ldGhvZCByZXR1cm5zIGFuIE9iamVjdCB3aGljaFxuICAgKiBjb250YWlucyAnZW5kcG9pbnQnLCAnbWV0aG9kJywgJ2hlYWRlcnMnIGFuZCAncGF5bG9hZCcuXG4gICAqL1xuV2ViUHVzaExpYi5wcm90b3R5cGUuZ2VuZXJhdGVSZXF1ZXN0RGV0YWlscyA9IGZ1bmN0aW9uKHN1YnNjcmlwdGlvbiwgcGF5bG9hZCwgb3B0aW9ucykge1xuICAgIGlmICghc3Vic2NyaXB0aW9uIHx8ICFzdWJzY3JpcHRpb24uZW5kcG9pbnQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignWW91IG11c3QgcGFzcyBpbiBhIHN1YnNjcmlwdGlvbiB3aXRoIGF0IGxlYXN0ICdcbiAgICAgICsgJ2FuIGVuZHBvaW50LicpO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2Ygc3Vic2NyaXB0aW9uLmVuZHBvaW50ICE9PSAnc3RyaW5nJ1xuICAgIHx8IHN1YnNjcmlwdGlvbi5lbmRwb2ludC5sZW5ndGggPT09IDApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignVGhlIHN1YnNjcmlwdGlvbiBlbmRwb2ludCBtdXN0IGJlIGEgc3RyaW5nIHdpdGggJ1xuICAgICAgKyAnYSB2YWxpZCBVUkwuJyk7XG4gICAgfVxuXG4gICAgaWYgKHBheWxvYWQpIHtcbiAgICAgIC8vIFZhbGlkYXRlIHRoZSBzdWJzY3JpcHRpb24ga2V5c1xuICAgICAgaWYgKHR5cGVvZiBzdWJzY3JpcHRpb24gIT09ICdvYmplY3QnIHx8ICFzdWJzY3JpcHRpb24ua2V5c1xuICAgICAgfHwgIXN1YnNjcmlwdGlvbi5rZXlzLnAyNTZkaFxuICAgICAgfHwgIXN1YnNjcmlwdGlvbi5rZXlzLmF1dGgpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUbyBzZW5kIGEgbWVzc2FnZSB3aXRoIGEgcGF5bG9hZCwgdGhlICdcbiAgICAgICAgKyAnc3Vic2NyaXB0aW9uIG11c3QgaGF2ZSBcXCdhdXRoXFwnIGFuZCBcXCdwMjU2ZGhcXCcga2V5cy4nKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBsZXQgY3VycmVudEdDTUFQSUtleSA9IGdjbUFQSUtleTtcbiAgICBsZXQgY3VycmVudFZhcGlkRGV0YWlscyA9IHZhcGlkRGV0YWlscztcbiAgICBsZXQgdGltZVRvTGl2ZSA9IERFRkFVTFRfVFRMO1xuICAgIGxldCBleHRyYUhlYWRlcnMgPSB7fTtcbiAgICBsZXQgY29udGVudEVuY29kaW5nID0gd2ViUHVzaENvbnN0YW50cy5zdXBwb3J0ZWRDb250ZW50RW5jb2RpbmdzLkFFU18xMjhfR0NNO1xuICAgIGxldCB1cmdlbmN5ID0gd2ViUHVzaENvbnN0YW50cy5zdXBwb3J0ZWRVcmdlbmN5Lk5PUk1BTDtcbiAgICBsZXQgdG9waWM7XG4gICAgbGV0IHByb3h5O1xuICAgIGxldCBhZ2VudDtcbiAgICBsZXQgdGltZW91dDtcblxuICAgIGlmIChvcHRpb25zKSB7XG4gICAgICBjb25zdCB2YWxpZE9wdGlvbktleXMgPSBbXG4gICAgICAgICdoZWFkZXJzJyxcbiAgICAgICAgJ2djbUFQSUtleScsXG4gICAgICAgICd2YXBpZERldGFpbHMnLFxuICAgICAgICAnVFRMJyxcbiAgICAgICAgJ2NvbnRlbnRFbmNvZGluZycsXG4gICAgICAgICd1cmdlbmN5JyxcbiAgICAgICAgJ3RvcGljJyxcbiAgICAgICAgJ3Byb3h5JyxcbiAgICAgICAgJ2FnZW50JyxcbiAgICAgICAgJ3RpbWVvdXQnXG4gICAgICBdO1xuICAgICAgY29uc3Qgb3B0aW9uS2V5cyA9IE9iamVjdC5rZXlzKG9wdGlvbnMpO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBvcHRpb25LZXlzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgIGNvbnN0IG9wdGlvbktleSA9IG9wdGlvbktleXNbaV07XG4gICAgICAgIGlmICghdmFsaWRPcHRpb25LZXlzLmluY2x1ZGVzKG9wdGlvbktleSkpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1xcJycgKyBvcHRpb25LZXkgKyAnXFwnIGlzIGFuIGludmFsaWQgb3B0aW9uLiAnXG4gICAgICAgICAgKyAnVGhlIHZhbGlkIG9wdGlvbnMgYXJlIFtcXCcnICsgdmFsaWRPcHRpb25LZXlzLmpvaW4oJ1xcJywgXFwnJylcbiAgICAgICAgICArICdcXCddLicpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChvcHRpb25zLmhlYWRlcnMpIHtcbiAgICAgICAgZXh0cmFIZWFkZXJzID0gb3B0aW9ucy5oZWFkZXJzO1xuICAgICAgICBsZXQgZHVwbGljYXRlcyA9IE9iamVjdC5rZXlzKGV4dHJhSGVhZGVycylcbiAgICAgICAgICAgIC5maWx0ZXIoZnVuY3Rpb24gKGhlYWRlcikge1xuICAgICAgICAgICAgICByZXR1cm4gdHlwZW9mIG9wdGlvbnNbaGVhZGVyXSAhPT0gJ3VuZGVmaW5lZCc7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICBpZiAoZHVwbGljYXRlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdEdXBsaWNhdGVkIGhlYWRlcnMgZGVmaW5lZCBbJ1xuICAgICAgICAgICsgZHVwbGljYXRlcy5qb2luKCcsJykgKyAnXS4gUGxlYXNlIGVpdGhlciBkZWZpbmUgdGhlIGhlYWRlciBpbiB0aGUnXG4gICAgICAgICAgKyAndG9wIGxldmVsIG9wdGlvbnMgT1IgaW4gdGhlIFxcJ2hlYWRlcnNcXCcga2V5LicpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChvcHRpb25zLmdjbUFQSUtleSkge1xuICAgICAgICBjdXJyZW50R0NNQVBJS2V5ID0gb3B0aW9ucy5nY21BUElLZXk7XG4gICAgICB9XG5cbiAgICAgIC8vIEZhbHN5IHZhbHVlcyBhcmUgYWxsb3dlZCBoZXJlIHNvIG9uZSBjYW4gc2tpcCBWYXBpZCBgZWxzZSBpZmAgYmVsb3cgYW5kIHVzZSBGQ01cbiAgICAgIGlmIChvcHRpb25zLnZhcGlkRGV0YWlscyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGN1cnJlbnRWYXBpZERldGFpbHMgPSBvcHRpb25zLnZhcGlkRGV0YWlscztcbiAgICAgIH1cblxuICAgICAgaWYgKG9wdGlvbnMuVFRMICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGltZVRvTGl2ZSA9IE51bWJlcihvcHRpb25zLlRUTCk7XG4gICAgICAgIGlmICh0aW1lVG9MaXZlIDwgMCkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVFRMIHNob3VsZCBiZSBhIG51bWJlciBhbmQgc2hvdWxkIGJlIGF0IGxlYXN0IDAnKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAob3B0aW9ucy5jb250ZW50RW5jb2RpbmcpIHtcbiAgICAgICAgaWYgKChvcHRpb25zLmNvbnRlbnRFbmNvZGluZyA9PT0gd2ViUHVzaENvbnN0YW50cy5zdXBwb3J0ZWRDb250ZW50RW5jb2RpbmdzLkFFU18xMjhfR0NNXG4gICAgICAgICAgfHwgb3B0aW9ucy5jb250ZW50RW5jb2RpbmcgPT09IHdlYlB1c2hDb25zdGFudHMuc3VwcG9ydGVkQ29udGVudEVuY29kaW5ncy5BRVNfR0NNKSkge1xuICAgICAgICAgIGNvbnRlbnRFbmNvZGluZyA9IG9wdGlvbnMuY29udGVudEVuY29kaW5nO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVW5zdXBwb3J0ZWQgY29udGVudCBlbmNvZGluZyBzcGVjaWZpZWQuJyk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKG9wdGlvbnMudXJnZW5jeSkge1xuICAgICAgICBpZiAoKG9wdGlvbnMudXJnZW5jeSA9PT0gd2ViUHVzaENvbnN0YW50cy5zdXBwb3J0ZWRVcmdlbmN5LlZFUllfTE9XXG4gICAgICAgICAgfHwgb3B0aW9ucy51cmdlbmN5ID09PSB3ZWJQdXNoQ29uc3RhbnRzLnN1cHBvcnRlZFVyZ2VuY3kuTE9XXG4gICAgICAgICAgfHwgb3B0aW9ucy51cmdlbmN5ID09PSB3ZWJQdXNoQ29uc3RhbnRzLnN1cHBvcnRlZFVyZ2VuY3kuTk9STUFMXG4gICAgICAgICAgfHwgb3B0aW9ucy51cmdlbmN5ID09PSB3ZWJQdXNoQ29uc3RhbnRzLnN1cHBvcnRlZFVyZ2VuY3kuSElHSCkpIHtcbiAgICAgICAgICB1cmdlbmN5ID0gb3B0aW9ucy51cmdlbmN5O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVW5zdXBwb3J0ZWQgdXJnZW5jeSBzcGVjaWZpZWQuJyk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKG9wdGlvbnMudG9waWMpIHtcbiAgICAgICAgaWYgKCF1cmxCYXNlNjRIZWxwZXIudmFsaWRhdGUob3B0aW9ucy50b3BpYykpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vuc3VwcG9ydGVkIGNoYXJhY3RlcnMgc2V0IHVzZSB0aGUgVVJMIG9yIGZpbGVuYW1lLXNhZmUgQmFzZTY0IGNoYXJhY3RlcnMgc2V0Jyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9wdGlvbnMudG9waWMubGVuZ3RoID4gMzIpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3VzZSBtYXhpbXVtIG9mIDMyIGNoYXJhY3RlcnMgZnJvbSB0aGUgVVJMIG9yIGZpbGVuYW1lLXNhZmUgQmFzZTY0IGNoYXJhY3RlcnMgc2V0Jyk7XG4gICAgICAgIH1cbiAgICAgICAgdG9waWMgPSBvcHRpb25zLnRvcGljO1xuICAgICAgfVxuXG4gICAgICBpZiAob3B0aW9ucy5wcm94eSkge1xuICAgICAgICBpZiAodHlwZW9mIG9wdGlvbnMucHJveHkgPT09ICdzdHJpbmcnXG4gICAgICAgICAgfHwgdHlwZW9mIG9wdGlvbnMucHJveHkuaG9zdCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICBwcm94eSA9IG9wdGlvbnMucHJveHk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY29uc29sZS53YXJuKCdBdHRlbXB0IHRvIHVzZSBwcm94eSBvcHRpb24sIGJ1dCBpbnZhbGlkIHR5cGUgaXQgc2hvdWxkIGJlIGEgc3RyaW5nIG9yIHByb3h5IG9wdGlvbnMgb2JqZWN0LicpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChvcHRpb25zLmFnZW50KSB7XG4gICAgICAgIGlmIChvcHRpb25zLmFnZW50IGluc3RhbmNlb2YgaHR0cHMuQWdlbnQpIHtcbiAgICAgICAgICBpZiAocHJveHkpIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybignQWdlbnQgb3B0aW9uIHdpbGwgYmUgaWdub3JlZCBiZWNhdXNlIHByb3h5IG9wdGlvbiBpcyBkZWZpbmVkLicpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGFnZW50ID0gb3B0aW9ucy5hZ2VudDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb25zb2xlLndhcm4oJ1dyb25nIHR5cGUgZm9yIHRoZSBhZ2VudCBvcHRpb24sIGl0IHNob3VsZCBiZSBhbiBpbnN0YW5jZSBvZiBodHRwcy5BZ2VudC4nKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAodHlwZW9mIG9wdGlvbnMudGltZW91dCA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgdGltZW91dCA9IG9wdGlvbnMudGltZW91dDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIHRpbWVUb0xpdmUgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICB0aW1lVG9MaXZlID0gREVGQVVMVF9UVEw7XG4gICAgfVxuXG4gICAgY29uc3QgcmVxdWVzdERldGFpbHMgPSB7XG4gICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgVFRMOiB0aW1lVG9MaXZlXG4gICAgICB9XG4gICAgfTtcbiAgICBPYmplY3Qua2V5cyhleHRyYUhlYWRlcnMpLmZvckVhY2goZnVuY3Rpb24gKGhlYWRlcikge1xuICAgICAgcmVxdWVzdERldGFpbHMuaGVhZGVyc1toZWFkZXJdID0gZXh0cmFIZWFkZXJzW2hlYWRlcl07XG4gICAgfSk7XG4gICAgbGV0IHJlcXVlc3RQYXlsb2FkID0gbnVsbDtcblxuICAgIGlmIChwYXlsb2FkKSB7XG4gICAgICBjb25zdCBlbmNyeXB0ZWQgPSBlbmNyeXB0aW9uSGVscGVyXG4gICAgICAgIC5lbmNyeXB0KHN1YnNjcmlwdGlvbi5rZXlzLnAyNTZkaCwgc3Vic2NyaXB0aW9uLmtleXMuYXV0aCwgcGF5bG9hZCwgY29udGVudEVuY29kaW5nKTtcblxuICAgICAgcmVxdWVzdERldGFpbHMuaGVhZGVyc1snQ29udGVudC1MZW5ndGgnXSA9IGVuY3J5cHRlZC5jaXBoZXJUZXh0Lmxlbmd0aDtcbiAgICAgIHJlcXVlc3REZXRhaWxzLmhlYWRlcnNbJ0NvbnRlbnQtVHlwZSddID0gJ2FwcGxpY2F0aW9uL29jdGV0LXN0cmVhbSc7XG5cbiAgICAgIGlmIChjb250ZW50RW5jb2RpbmcgPT09IHdlYlB1c2hDb25zdGFudHMuc3VwcG9ydGVkQ29udGVudEVuY29kaW5ncy5BRVNfMTI4X0dDTSkge1xuICAgICAgICByZXF1ZXN0RGV0YWlscy5oZWFkZXJzWydDb250ZW50LUVuY29kaW5nJ10gPSB3ZWJQdXNoQ29uc3RhbnRzLnN1cHBvcnRlZENvbnRlbnRFbmNvZGluZ3MuQUVTXzEyOF9HQ007XG4gICAgICB9IGVsc2UgaWYgKGNvbnRlbnRFbmNvZGluZyA9PT0gd2ViUHVzaENvbnN0YW50cy5zdXBwb3J0ZWRDb250ZW50RW5jb2RpbmdzLkFFU19HQ00pIHtcbiAgICAgICAgcmVxdWVzdERldGFpbHMuaGVhZGVyc1snQ29udGVudC1FbmNvZGluZyddID0gd2ViUHVzaENvbnN0YW50cy5zdXBwb3J0ZWRDb250ZW50RW5jb2RpbmdzLkFFU19HQ007XG4gICAgICAgIHJlcXVlc3REZXRhaWxzLmhlYWRlcnMuRW5jcnlwdGlvbiA9ICdzYWx0PScgKyBlbmNyeXB0ZWQuc2FsdDtcbiAgICAgICAgcmVxdWVzdERldGFpbHMuaGVhZGVyc1snQ3J5cHRvLUtleSddID0gJ2RoPScgKyBlbmNyeXB0ZWQubG9jYWxQdWJsaWNLZXkudG9TdHJpbmcoJ2Jhc2U2NHVybCcpO1xuICAgICAgfVxuXG4gICAgICByZXF1ZXN0UGF5bG9hZCA9IGVuY3J5cHRlZC5jaXBoZXJUZXh0O1xuICAgIH0gZWxzZSB7XG4gICAgICByZXF1ZXN0RGV0YWlscy5oZWFkZXJzWydDb250ZW50LUxlbmd0aCddID0gMDtcbiAgICB9XG5cbiAgICBjb25zdCBpc0dDTSA9IHN1YnNjcmlwdGlvbi5lbmRwb2ludC5zdGFydHNXaXRoKCdodHRwczovL2FuZHJvaWQuZ29vZ2xlYXBpcy5jb20vZ2NtL3NlbmQnKTtcbiAgICBjb25zdCBpc0ZDTSA9IHN1YnNjcmlwdGlvbi5lbmRwb2ludC5zdGFydHNXaXRoKCdodHRwczovL2ZjbS5nb29nbGVhcGlzLmNvbS9mY20vc2VuZCcpO1xuICAgIC8vIFZBUElEIGlzbid0IHN1cHBvcnRlZCBieSBHQ00gaGVuY2UgdGhlIGlmLCBlbHNlIGlmLlxuICAgIGlmIChpc0dDTSkge1xuICAgICAgaWYgKCFjdXJyZW50R0NNQVBJS2V5KSB7XG4gICAgICAgIGNvbnNvbGUud2FybignQXR0ZW1wdCB0byBzZW5kIHB1c2ggbm90aWZpY2F0aW9uIHRvIEdDTSBlbmRwb2ludCwgJ1xuICAgICAgICArICdidXQgbm8gR0NNIGtleSBpcyBkZWZpbmVkLiBQbGVhc2UgdXNlIHNldEdDTUFwaUtleSgpIG9yIGFkZCAnXG4gICAgICAgICsgJ1xcJ2djbUFQSUtleVxcJyBhcyBhbiBvcHRpb24uJyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXF1ZXN0RGV0YWlscy5oZWFkZXJzLkF1dGhvcml6YXRpb24gPSAna2V5PScgKyBjdXJyZW50R0NNQVBJS2V5O1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoY3VycmVudFZhcGlkRGV0YWlscykge1xuICAgICAgY29uc3QgcGFyc2VkVXJsID0gdXJsLnBhcnNlKHN1YnNjcmlwdGlvbi5lbmRwb2ludCk7XG4gICAgICBjb25zdCBhdWRpZW5jZSA9IHBhcnNlZFVybC5wcm90b2NvbCArICcvLydcbiAgICAgICsgcGFyc2VkVXJsLmhvc3Q7XG5cbiAgICAgIGNvbnN0IHZhcGlkSGVhZGVycyA9IHZhcGlkSGVscGVyLmdldFZhcGlkSGVhZGVycyhcbiAgICAgICAgYXVkaWVuY2UsXG4gICAgICAgIGN1cnJlbnRWYXBpZERldGFpbHMuc3ViamVjdCxcbiAgICAgICAgY3VycmVudFZhcGlkRGV0YWlscy5wdWJsaWNLZXksXG4gICAgICAgIGN1cnJlbnRWYXBpZERldGFpbHMucHJpdmF0ZUtleSxcbiAgICAgICAgY29udGVudEVuY29kaW5nXG4gICAgICApO1xuXG4gICAgICByZXF1ZXN0RGV0YWlscy5oZWFkZXJzLkF1dGhvcml6YXRpb24gPSB2YXBpZEhlYWRlcnMuQXV0aG9yaXphdGlvbjtcblxuICAgICAgaWYgKGNvbnRlbnRFbmNvZGluZyA9PT0gd2ViUHVzaENvbnN0YW50cy5zdXBwb3J0ZWRDb250ZW50RW5jb2RpbmdzLkFFU19HQ00pIHtcbiAgICAgICAgaWYgKHJlcXVlc3REZXRhaWxzLmhlYWRlcnNbJ0NyeXB0by1LZXknXSkge1xuICAgICAgICAgIHJlcXVlc3REZXRhaWxzLmhlYWRlcnNbJ0NyeXB0by1LZXknXSArPSAnOydcbiAgICAgICAgICArIHZhcGlkSGVhZGVyc1snQ3J5cHRvLUtleSddO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJlcXVlc3REZXRhaWxzLmhlYWRlcnNbJ0NyeXB0by1LZXknXSA9IHZhcGlkSGVhZGVyc1snQ3J5cHRvLUtleSddO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChpc0ZDTSAmJiBjdXJyZW50R0NNQVBJS2V5KSB7XG4gICAgICByZXF1ZXN0RGV0YWlscy5oZWFkZXJzLkF1dGhvcml6YXRpb24gPSAna2V5PScgKyBjdXJyZW50R0NNQVBJS2V5O1xuICAgIH1cblxuICAgIHJlcXVlc3REZXRhaWxzLmhlYWRlcnMuVXJnZW5jeSA9IHVyZ2VuY3k7XG5cbiAgICBpZiAodG9waWMpIHtcbiAgICAgIHJlcXVlc3REZXRhaWxzLmhlYWRlcnMuVG9waWMgPSB0b3BpYztcbiAgICB9XG5cbiAgICByZXF1ZXN0RGV0YWlscy5ib2R5ID0gcmVxdWVzdFBheWxvYWQ7XG4gICAgcmVxdWVzdERldGFpbHMuZW5kcG9pbnQgPSBzdWJzY3JpcHRpb24uZW5kcG9pbnQ7XG5cbiAgICBpZiAocHJveHkpIHtcbiAgICAgIHJlcXVlc3REZXRhaWxzLnByb3h5ID0gcHJveHk7XG4gICAgfVxuXG4gICAgaWYgKGFnZW50KSB7XG4gICAgICByZXF1ZXN0RGV0YWlscy5hZ2VudCA9IGFnZW50O1xuICAgIH1cblxuICAgIGlmICh0aW1lb3V0KSB7XG4gICAgICByZXF1ZXN0RGV0YWlscy50aW1lb3V0ID0gdGltZW91dDtcbiAgICB9XG5cbiAgICByZXR1cm4gcmVxdWVzdERldGFpbHM7XG4gIH07XG5cbi8qKlxuICogVG8gc2VuZCBhIHB1c2ggbm90aWZpY2F0aW9uIGNhbGwgdGhpcyBtZXRob2Qgd2l0aCBhIHN1YnNjcmlwdGlvbiwgb3B0aW9uYWxcbiAqIHBheWxvYWQgYW5kIGFueSBvcHRpb25zLlxuICogQHBhcmFtICB7UHVzaFN1YnNjcmlwdGlvbn0gc3Vic2NyaXB0aW9uIFRoZSBQdXNoU3Vic2NyaXB0aW9uIHlvdSB3aXNoIHRvXG4gKiBzZW5kIHRoZSBub3RpZmljYXRpb24gdG8uXG4gKiBAcGFyYW0gIHtzdHJpbmd8QnVmZmVyfSBbcGF5bG9hZF0gICAgICAgVGhlIHBheWxvYWQgeW91IHdpc2ggdG8gc2VuZCB0byB0aGVcbiAqIHRoZSB1c2VyLlxuICogQHBhcmFtICB7T2JqZWN0fSBbb3B0aW9uc10gICAgICAgICAgICAgIE9wdGlvbnMgZm9yIHRoZSBHQ00gQVBJIGtleSBhbmRcbiAqIHZhcGlkIGtleXMgY2FuIGJlIHBhc3NlZCBpbiBpZiB0aGV5IGFyZSB1bmlxdWUgZm9yIGVhY2ggbm90aWZpY2F0aW9uIHlvdVxuICogd2lzaCB0byBzZW5kLlxuICogQHJldHVybiB7UHJvbWlzZX0gICAgICAgICAgICAgICAgICAgICAgIFRoaXMgbWV0aG9kIHJldHVybnMgYSBQcm9taXNlIHdoaWNoXG4gKiByZXNvbHZlcyBpZiB0aGUgc2VuZGluZyBvZiB0aGUgbm90aWZpY2F0aW9uIHdhcyBzdWNjZXNzZnVsLCBvdGhlcndpc2UgaXRcbiAqIHJlamVjdHMuXG4gKi9cbldlYlB1c2hMaWIucHJvdG90eXBlLnNlbmROb3RpZmljYXRpb24gPSBmdW5jdGlvbihzdWJzY3JpcHRpb24sIHBheWxvYWQsIG9wdGlvbnMpIHtcbiAgICBsZXQgcmVxdWVzdERldGFpbHM7XG4gICAgdHJ5IHtcbiAgICAgIHJlcXVlc3REZXRhaWxzID0gdGhpcy5nZW5lcmF0ZVJlcXVlc3REZXRhaWxzKHN1YnNjcmlwdGlvbiwgcGF5bG9hZCwgb3B0aW9ucyk7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoZXJyKTtcbiAgICB9XG5cbiAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICBjb25zdCBodHRwc09wdGlvbnMgPSB7fTtcbiAgICAgIGNvbnN0IHVybFBhcnRzID0gdXJsLnBhcnNlKHJlcXVlc3REZXRhaWxzLmVuZHBvaW50KTtcbiAgICAgIGh0dHBzT3B0aW9ucy5ob3N0bmFtZSA9IHVybFBhcnRzLmhvc3RuYW1lO1xuICAgICAgaHR0cHNPcHRpb25zLnBvcnQgPSB1cmxQYXJ0cy5wb3J0O1xuICAgICAgaHR0cHNPcHRpb25zLnBhdGggPSB1cmxQYXJ0cy5wYXRoO1xuXG4gICAgICBodHRwc09wdGlvbnMuaGVhZGVycyA9IHJlcXVlc3REZXRhaWxzLmhlYWRlcnM7XG4gICAgICBodHRwc09wdGlvbnMubWV0aG9kID0gcmVxdWVzdERldGFpbHMubWV0aG9kO1xuXG4gICAgICBpZiAocmVxdWVzdERldGFpbHMudGltZW91dCkge1xuICAgICAgICBodHRwc09wdGlvbnMudGltZW91dCA9IHJlcXVlc3REZXRhaWxzLnRpbWVvdXQ7XG4gICAgICB9XG5cbiAgICAgIGlmIChyZXF1ZXN0RGV0YWlscy5hZ2VudCkge1xuICAgICAgICBodHRwc09wdGlvbnMuYWdlbnQgPSByZXF1ZXN0RGV0YWlscy5hZ2VudDtcbiAgICAgIH1cblxuICAgICAgaWYgKHJlcXVlc3REZXRhaWxzLnByb3h5KSB7XG4gICAgICAgIGNvbnN0IHsgSHR0cHNQcm94eUFnZW50IH0gPSByZXF1aXJlKCdodHRwcy1wcm94eS1hZ2VudCcpOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGdsb2JhbC1yZXF1aXJlXG4gICAgICAgIGh0dHBzT3B0aW9ucy5hZ2VudCA9IG5ldyBIdHRwc1Byb3h5QWdlbnQocmVxdWVzdERldGFpbHMucHJveHkpO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBwdXNoUmVxdWVzdCA9IGh0dHBzLnJlcXVlc3QoaHR0cHNPcHRpb25zLCBmdW5jdGlvbihwdXNoUmVzcG9uc2UpIHtcbiAgICAgICAgbGV0IHJlc3BvbnNlVGV4dCA9ICcnO1xuXG4gICAgICAgIHB1c2hSZXNwb25zZS5vbignZGF0YScsIGZ1bmN0aW9uKGNodW5rKSB7XG4gICAgICAgICAgcmVzcG9uc2VUZXh0ICs9IGNodW5rO1xuICAgICAgICB9KTtcblxuICAgICAgICBwdXNoUmVzcG9uc2Uub24oJ2VuZCcsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgIGlmIChwdXNoUmVzcG9uc2Uuc3RhdHVzQ29kZSA8IDIwMCB8fCBwdXNoUmVzcG9uc2Uuc3RhdHVzQ29kZSA+IDI5OSkge1xuICAgICAgICAgICAgcmVqZWN0KG5ldyBXZWJQdXNoRXJyb3IoXG4gICAgICAgICAgICAgICdSZWNlaXZlZCB1bmV4cGVjdGVkIHJlc3BvbnNlIGNvZGUnLFxuICAgICAgICAgICAgICBwdXNoUmVzcG9uc2Uuc3RhdHVzQ29kZSxcbiAgICAgICAgICAgICAgcHVzaFJlc3BvbnNlLmhlYWRlcnMsXG4gICAgICAgICAgICAgIHJlc3BvbnNlVGV4dCxcbiAgICAgICAgICAgICAgcmVxdWVzdERldGFpbHMuZW5kcG9pbnRcbiAgICAgICAgICAgICkpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXNvbHZlKHtcbiAgICAgICAgICAgICAgc3RhdHVzQ29kZTogcHVzaFJlc3BvbnNlLnN0YXR1c0NvZGUsXG4gICAgICAgICAgICAgIGJvZHk6IHJlc3BvbnNlVGV4dCxcbiAgICAgICAgICAgICAgaGVhZGVyczogcHVzaFJlc3BvbnNlLmhlYWRlcnNcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9KTtcblxuICAgICAgaWYgKHJlcXVlc3REZXRhaWxzLnRpbWVvdXQpIHtcbiAgICAgICAgcHVzaFJlcXVlc3Qub24oJ3RpbWVvdXQnLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICBwdXNoUmVxdWVzdC5kZXN0cm95KG5ldyBFcnJvcignU29ja2V0IHRpbWVvdXQnKSk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICBwdXNoUmVxdWVzdC5vbignZXJyb3InLCBmdW5jdGlvbihlKSB7XG4gICAgICAgIHJlamVjdChlKTtcbiAgICAgIH0pO1xuXG4gICAgICBpZiAocmVxdWVzdERldGFpbHMuYm9keSkge1xuICAgICAgICBwdXNoUmVxdWVzdC53cml0ZShyZXF1ZXN0RGV0YWlscy5ib2R5KTtcbiAgICAgIH1cblxuICAgICAgcHVzaFJlcXVlc3QuZW5kKCk7XG4gICAgfSk7XG4gIH07XG5cbm1vZHVsZS5leHBvcnRzID0gV2ViUHVzaExpYjtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/web-push/src/web-push-lib.js\n");

/***/ })

};
;