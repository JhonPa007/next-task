"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/workspace/[id]/page",{

/***/ "(app-pages-browser)/./src/app/actions/analytics.ts":
/*!**************************************!*\
  !*** ./src/app/actions/analytics.ts ***!
  \**************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   calculateGoalHealth: () => (/* binding */ $$RSC_SERVER_ACTION_0)\n/* harmony export */ });\n/* harmony import */ var private_next_rsc_action_client_wrapper__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! private-next-rsc-action-client-wrapper */ \"(app-pages-browser)/./node_modules/next/dist/build/webpack/loaders/next-flight-loader/action-client-wrapper.js\");\n/* harmony import */ var private_next_rsc_action_client_wrapper__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(private_next_rsc_action_client_wrapper__WEBPACK_IMPORTED_MODULE_0__);\n/* __next_internal_action_entry_do_not_use__ {\"4012a5f9a2c975a1392cfac333c4881073d2861249\":\"calculateGoalHealth\"} */ \nconst $$RSC_SERVER_ACTION_0 = /*#__PURE__*/ (0,private_next_rsc_action_client_wrapper__WEBPACK_IMPORTED_MODULE_0__.createServerReference)(\"4012a5f9a2c975a1392cfac333c4881073d2861249\", private_next_rsc_action_client_wrapper__WEBPACK_IMPORTED_MODULE_0__.callServer, void 0, private_next_rsc_action_client_wrapper__WEBPACK_IMPORTED_MODULE_0__.findSourceMapURL, \"calculateGoalHealth\");\n\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9hcHAvYWN0aW9ucy9hbmFseXRpY3MudHMiLCJtYXBwaW5ncyI6Ijs7Ozs7OztNQWtDc0JBLHNDQUFBQSw2RkFBQUEsK0NBQUFBLDhFQUFBQSxVQUFBQSxvRkFBQUE7QUFBQUEiLCJzb3VyY2VzIjpbIkQ6XFxhcGxpY2FjaW9uZXMtaWFcXG5leHQtdGFza1xcc3JjXFxhcHBcXGFjdGlvbnNcXGFuYWx5dGljcy50cyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHNlcnZlcic7XHJcblxyXG5pbXBvcnQgeyBwcmlzbWEgfSBmcm9tICdAL2xpYi9wcmlzbWEnO1xyXG5pbXBvcnQgeyBnZXRDdXJyZW50VXNlciB9IGZyb20gJ0AvYXBwL2FjdGlvbnMvdXNlcic7XHJcbmltcG9ydCB7IEdvb2dsZUdlbmVyYXRpdmVBSSB9IGZyb20gJ0Bnb29nbGUvZ2VuZXJhdGl2ZS1haSc7XHJcblxyXG5leHBvcnQgdHlwZSBPS1JIZWFsdGggPSAnT05fVFJBQ0snIHwgJ0FUX1JJU0snIHwgJ09GRl9UUkFDSyc7XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIEhlYWx0aEluc2lnaHQge1xyXG4gICAgdHlwZTogJ1dBUk5JTkcnIHwgJ0RBTkdFUicgfCAnSU5GTycgfCAnU1VDQ0VTUyc7XHJcbiAgICBtZXNzYWdlOiBzdHJpbmc7XHJcbn1cclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgSGVhbHRoUmVwb3J0IHtcclxuICAgIGhlYWx0aDogT0tSSGVhbHRoO1xyXG4gICAgc2NvcmU6IG51bWJlcjsgLy8gMCBhIDEwMFxyXG4gICAgYWlTdW1tYXJ5Pzogc3RyaW5nOyAvLyBBbsOhbGlzaXMgZXNjcml0byBwb3IgR2VtaW5pXHJcbiAgICBpbnNpZ2h0czogSGVhbHRoSW5zaWdodFtdO1xyXG4gICAgbWV0cmljczoge1xyXG4gICAgICAgIHRvdGFsVGFza3M6IG51bWJlcjtcclxuICAgICAgICBjb21wbGV0ZWRUYXNrczogbnVtYmVyO1xyXG4gICAgICAgIG92ZXJkdWVUYXNrczogbnVtYmVyO1xyXG4gICAgICAgIHN0dWNrVGFza3M6IG51bWJlcjtcclxuICAgICAgICBjcml0aWNhbFRhc2tzOiBudW1iZXI7XHJcbiAgICAgICAgcmVjZW50Q2hlY2tJbnM6IG51bWJlcjtcclxuICAgICAgICBuZWdhdGl2ZU1vcmFsZUNvdW50OiBudW1iZXI7XHJcbiAgICAgICAgYmxvY2tlckNvdW50OiBudW1iZXI7XHJcbiAgICB9XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBDYWxjdWxhdGVzIHRoZSBQcmVkaWN0aXZlIEhlYWx0aCBvZiBhbiBlbnRpcmUgR29hbCAoT0tSKVxyXG4gKiBiYXNlZCBvbiBpdHMgS2V5IFJlc3VsdHMsIFByb2plY3RzLCBUYXNrcywgYW5kIENoZWNrLWlucy5cclxuICovXHJcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBjYWxjdWxhdGVHb2FsSGVhbHRoKGdvYWxJZDogc3RyaW5nKTogUHJvbWlzZTx7IHN1Y2Nlc3M6IGJvb2xlYW47IGRhdGE/OiBIZWFsdGhSZXBvcnQ7IGVycm9yPzogc3RyaW5nIH0+IHtcclxuICAgIHRyeSB7XHJcbiAgICAgICAgY29uc3QgdXNlciA9IGF3YWl0IGdldEN1cnJlbnRVc2VyKCk7XHJcbiAgICAgICAgaWYgKCF1c2VyKSByZXR1cm4geyBzdWNjZXNzOiBmYWxzZSwgZXJyb3I6ICdVbmF1dGhvcml6ZWQnIH07XHJcblxyXG4gICAgICAgIC8vIDEuIEZldGNoIHRoZSBHb2FsIHdpdGggQUxMIG5lc3RlZCByZWxhdGlvbnMgbmVlZGVkIGZvciBhbmFseXNpc1xyXG4gICAgICAgIGNvbnN0IGdvYWwgPSBhd2FpdCBwcmlzbWEuZ29hbC5maW5kVW5pcXVlKHtcclxuICAgICAgICAgICAgd2hlcmU6IHsgaWQ6IGdvYWxJZCB9LFxyXG4gICAgICAgICAgICBpbmNsdWRlOiB7XHJcbiAgICAgICAgICAgICAgICBrZXlSZXN1bHRzOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgaW5jbHVkZToge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBwcm9qZWN0czoge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5jbHVkZToge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRhc2tzOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluY2x1ZGU6IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRhc2s6IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbmNsdWRlOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNoZWNrSW5zOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcmRlckJ5OiB7IGNyZWF0ZWRBdDogJ2Rlc2MnIH0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0YWtlOiAzIC8vIE9ubHkgbG9vayBhdCByZWNlbnQgY2hlY2staW5zXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgaWYgKCFnb2FsKSByZXR1cm4geyBzdWNjZXNzOiBmYWxzZSwgZXJyb3I6ICdHb2FsIG5vdCBmb3VuZCcgfTtcclxuXHJcbiAgICAgICAgY29uc3QgaW5zaWdodHM6IEhlYWx0aEluc2lnaHRbXSA9IFtdO1xyXG4gICAgICAgIGNvbnN0IG1ldHJpY3MgPSB7XHJcbiAgICAgICAgICAgIHRvdGFsVGFza3M6IDAsXHJcbiAgICAgICAgICAgIGNvbXBsZXRlZFRhc2tzOiAwLFxyXG4gICAgICAgICAgICBvdmVyZHVlVGFza3M6IDAsXHJcbiAgICAgICAgICAgIHN0dWNrVGFza3M6IDAsXHJcbiAgICAgICAgICAgIGNyaXRpY2FsVGFza3M6IDAsXHJcbiAgICAgICAgICAgIHJlY2VudENoZWNrSW5zOiAwLFxyXG4gICAgICAgICAgICBuZWdhdGl2ZU1vcmFsZUNvdW50OiAwLFxyXG4gICAgICAgICAgICBibG9ja2VyQ291bnQ6IDAsXHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgY29uc3Qgbm93ID0gbmV3IERhdGUoKTtcclxuICAgICAgICBsZXQga3JQcm9ncmVzc0F2ZyA9IDA7XHJcbiAgICAgICAgbGV0IGtyQ291bnQgPSBnb2FsLmtleVJlc3VsdHMubGVuZ3RoO1xyXG5cclxuICAgICAgICAvLyAyLiBBZ2dyZWdhdGUgRGF0YVxyXG4gICAgICAgIGdvYWwua2V5UmVzdWx0cy5mb3JFYWNoKGtyID0+IHtcclxuICAgICAgICAgICAgY29uc3QgcHJvZ3Jlc3MgPSBrci50YXJnZXRWYWx1ZSA+IDAgPyAoa3IuY3VycmVudFZhbHVlIC8ga3IudGFyZ2V0VmFsdWUpICogMTAwIDogMDtcclxuICAgICAgICAgICAga3JQcm9ncmVzc0F2ZyArPSBwcm9ncmVzcztcclxuXHJcbiAgICAgICAgICAgIGtyLnByb2plY3RzLmZvckVhY2gocHJvamVjdFJlbCA9PiB7XHJcbiAgICAgICAgICAgICAgICBwcm9qZWN0UmVsLnRhc2tzLmZvckVhY2godGFza1JlbCA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdGFzayA9IHRhc2tSZWwudGFzaztcclxuICAgICAgICAgICAgICAgICAgICBtZXRyaWNzLnRvdGFsVGFza3MrKztcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRhc2suc3RhdHVzID09PSAnRE9ORScpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbWV0cmljcy5jb21wbGV0ZWRUYXNrcysrO1xyXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0YXNrLnN0YXR1cyA9PT0gJ1NUVUNLJykgbWV0cmljcy5zdHVja1Rhc2tzKys7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodGFzay5kdWVEYXRlICYmIG5ldyBEYXRlKHRhc2suZHVlRGF0ZSkgPCBub3cpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1ldHJpY3Mub3ZlcmR1ZVRhc2tzKys7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodGFzay5wcmlvcml0eSA9PT0gJ0hJR0gnIHx8IHRhc2sucHJpb3JpdHkgPT09ICdVUkdFTlQnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWV0cmljcy5jcml0aWNhbFRhc2tzKys7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHRhc2suY2hlY2tJbnMuZm9yRWFjaChjaSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG1ldHJpY3MucmVjZW50Q2hlY2tJbnMrKztcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNpLm1vcmFsZSA9PT0gJ0VTVFJFU0FETycpIG1ldHJpY3MubmVnYXRpdmVNb3JhbGVDb3VudCsrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY2kuYmxvY2tlcnMgJiYgY2kuYmxvY2tlcnMudHJpbSgpICE9PSAnJykgbWV0cmljcy5ibG9ja2VyQ291bnQrKztcclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAga3JQcm9ncmVzc0F2ZyA9IGtyQ291bnQgPiAwID8ga3JQcm9ncmVzc0F2ZyAvIGtyQ291bnQgOiAwO1xyXG5cclxuICAgICAgICAvLyAzLiBBbmFseXplIGFuZCBHZW5lcmF0ZSBJbnNpZ2h0c1xyXG4gICAgICAgIGxldCByaXNrU2NvcmUgPSAwOyAvLyBIaWdoZXIgaXMgd29yc2UuIDAtMTAwIHNjYWxlIGlkZWFsbHksIGJ1dCB3ZSdsbCBjYXAgaXQuXHJcblxyXG4gICAgICAgIC8vIFRpbWUtYmFzZWQgcmlzayAoT3ZlcmR1ZSB0YXNrcylcclxuICAgICAgICBpZiAobWV0cmljcy5vdmVyZHVlVGFza3MgPiAwKSB7XHJcbiAgICAgICAgICAgIHJpc2tTY29yZSArPSBNYXRoLm1pbigzMCwgbWV0cmljcy5vdmVyZHVlVGFza3MgKiA1KTtcclxuICAgICAgICAgICAgaW5zaWdodHMucHVzaCh7XHJcbiAgICAgICAgICAgICAgICB0eXBlOiAnV0FSTklORycsXHJcbiAgICAgICAgICAgICAgICBtZXNzYWdlOiBgSGF5ICR7bWV0cmljcy5vdmVyZHVlVGFza3N9IHRhcmVhKHMpIHZlbmNpZGEocykgYWZlY3RhbmRvIGVzdGUgb2JqZXRpdm8uYFxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIENyaXRpY2FsIFRpbWUtYmFzZWQgcmlza1xyXG4gICAgICAgIGlmIChtZXRyaWNzLmNyaXRpY2FsVGFza3MgPiAwKSB7XHJcbiAgICAgICAgICAgIHJpc2tTY29yZSArPSBNYXRoLm1pbig0MCwgbWV0cmljcy5jcml0aWNhbFRhc2tzICogMTUpO1xyXG4gICAgICAgICAgICBpbnNpZ2h0cy5wdXNoKHtcclxuICAgICAgICAgICAgICAgIHR5cGU6ICdEQU5HRVInLFxyXG4gICAgICAgICAgICAgICAgbWVzc2FnZTogYMKhQWxlcnRhISAke21ldHJpY3MuY3JpdGljYWxUYXNrc30gdGFyZWEocykgQ1LDjVRJQ0FTIGVzdMOhbiByZXRyYXNhZGFzLmBcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBFeGVjdXRpb24gcmlzayAoU3R1Y2sgdGFza3MpXHJcbiAgICAgICAgaWYgKG1ldHJpY3Muc3R1Y2tUYXNrcyA+IDApIHtcclxuICAgICAgICAgICAgcmlza1Njb3JlICs9IE1hdGgubWluKDI1LCBtZXRyaWNzLnN0dWNrVGFza3MgKiAxMCk7XHJcbiAgICAgICAgICAgIGluc2lnaHRzLnB1c2goe1xyXG4gICAgICAgICAgICAgICAgdHlwZTogJ1dBUk5JTkcnLFxyXG4gICAgICAgICAgICAgICAgbWVzc2FnZTogYEVsIGVxdWlwbyBoYSBtYXJjYWRvICR7bWV0cmljcy5zdHVja1Rhc2tzfSB0YXJlYShzKSBjb21vIGRldGVuaWRhcyAoU1RVQ0spLmBcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBNb3JhbGUgYW5kIEJsb2NrZXIgcmlzayAoZnJvbSByZWNlbnQgQ2hlY2staW5zKVxyXG4gICAgICAgIGlmIChtZXRyaWNzLm5lZ2F0aXZlTW9yYWxlQ291bnQgPiAwKSB7XHJcbiAgICAgICAgICAgIHJpc2tTY29yZSArPSBNYXRoLm1pbigyMCwgbWV0cmljcy5uZWdhdGl2ZU1vcmFsZUNvdW50ICogMTApO1xyXG4gICAgICAgICAgICBpbnNpZ2h0cy5wdXNoKHtcclxuICAgICAgICAgICAgICAgIHR5cGU6ICdJTkZPJyxcclxuICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGBTZSBkZXRlY3TDsyBhbHRhIHRlbnNpw7NuLiAke21ldHJpY3MubmVnYXRpdmVNb3JhbGVDb3VudH0gcmVwb3J0ZShzKSByZWNpZW50ZShzKSBpbmRpY2FuIGVzdGFkbyBkZSDDoW5pbW8gJ0VzdHJlc2FkbycuYFxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmIChtZXRyaWNzLmJsb2NrZXJDb3VudCA+IDApIHtcclxuICAgICAgICAgICAgcmlza1Njb3JlICs9IE1hdGgubWluKDIwLCBtZXRyaWNzLmJsb2NrZXJDb3VudCAqIDUpO1xyXG4gICAgICAgICAgICBpbnNpZ2h0cy5wdXNoKHtcclxuICAgICAgICAgICAgICAgIHR5cGU6ICdXQVJOSU5HJyxcclxuICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGBTZSBoYW4gcmVwb3J0YWRvIG9ic3TDoWN1bG9zIGV4cGzDrWNpdG9zIGVuICR7bWV0cmljcy5ibG9ja2VyQ291bnR9IGNoZWNrLWluKHMpIHJlY2llbnRlKHMpLmBcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBQcm9ncmVzcyByaXNrIChMb3cgY29tcGxldGlvbiBkZXNwaXRlIGhhdmluZyB0YXNrcylcclxuICAgICAgICBjb25zdCB0YXNrQ29tcGxldGlvblN0YXR1cyA9IG1ldHJpY3MudG90YWxUYXNrcyA+IDAgPyAobWV0cmljcy5jb21wbGV0ZWRUYXNrcyAvIG1ldHJpY3MudG90YWxUYXNrcykgKiAxMDAgOiAwO1xyXG4gICAgICAgIGlmIChtZXRyaWNzLnRvdGFsVGFza3MgPiAwICYmIHRhc2tDb21wbGV0aW9uU3RhdHVzIDwgMjAgJiYgcmlza1Njb3JlID4gMTApIHtcclxuICAgICAgICAgICAgaW5zaWdodHMucHVzaCh7XHJcbiAgICAgICAgICAgICAgICB0eXBlOiAnSU5GTycsXHJcbiAgICAgICAgICAgICAgICBtZXNzYWdlOiBgUHJvZ3Jlc28gZGUgdGFyZWFzIGJham8gKCR7TWF0aC5yb3VuZCh0YXNrQ29tcGxldGlvblN0YXR1cyl9JSksIGNvbnNpZGVyYSByZXZpc2FyIGxhIHZpYWJpbGlkYWQgZGUgbGFzIGZlY2hhcy5gXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gU3VidGx5IHByYWlzZSBpZiB0aGluZ3MgYXJlIGdvaW5nIGluY3JlZGlibHkgd2VsbFxyXG4gICAgICAgIGlmIChyaXNrU2NvcmUgPT09IDAgJiYgbWV0cmljcy5jb21wbGV0ZWRUYXNrcyA+IDApIHtcclxuICAgICAgICAgICAgaW5zaWdodHMucHVzaCh7XHJcbiAgICAgICAgICAgICAgICB0eXBlOiAnU1VDQ0VTUycsXHJcbiAgICAgICAgICAgICAgICBtZXNzYWdlOiBgwqFFeGNlbGVudGUgaW5lcmNpYSEgTGFzIHRhcmVhcyBmbHV5ZW4gc2luIGJsb3F1ZW9zIHkgZGVudHJvIGRlIGxhcyBmZWNoYXMgbMOtbWl0ZS5gXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gNC4gQ2FsY3VsYXRlIEZpbmFsIEhlYWx0aCBTdGF0dXNcclxuICAgICAgICBsZXQgaGVhbHRoVmFsdWU6IE9LUkhlYWx0aCA9ICdPTl9UUkFDSyc7XHJcbiAgICAgICAgLy8gQmFzZSBzY29yZSBzdGFydHMgYXQgMTAwIGFuZCBsb3NlcyBwb2ludHMgYmFzZWQgb24gcmlza1xyXG4gICAgICAgIGNvbnN0IGZpbmFsU2NvcmUgPSBNYXRoLm1heCgwLCAxMDAgLSByaXNrU2NvcmUpO1xyXG5cclxuICAgICAgICBpZiAoZmluYWxTY29yZSA8IDUwKSB7XHJcbiAgICAgICAgICAgIGhlYWx0aFZhbHVlID0gJ09GRl9UUkFDSyc7XHJcbiAgICAgICAgfSBlbHNlIGlmIChmaW5hbFNjb3JlIDwgODApIHtcclxuICAgICAgICAgICAgaGVhbHRoVmFsdWUgPSAnQVRfUklTSyc7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyA1LiBHZW5lcmFyIFJlc3VtZW4gY29uIElBIChHZW1pbmkpXHJcbiAgICAgICAgbGV0IGFpU3VtbWFyeSA9IFwiXCI7XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgY29uc3QgYXBpS2V5ID0gcHJvY2Vzcy5lbnYuR0VNSU5JX0FQSV9LRVk7XHJcbiAgICAgICAgICAgIGlmIChhcGlLZXkpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGdlbkFJID0gbmV3IEdvb2dsZUdlbmVyYXRpdmVBSShhcGlLZXkpO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgbW9kZWwgPSBnZW5BSS5nZXRHZW5lcmF0aXZlTW9kZWwoeyBtb2RlbDogXCJnZW1pbmktMi41LWZsYXNoXCIgfSk7XHJcblxyXG4gICAgICAgICAgICAgICAgY29uc3QgcHJvbXB0ID0gYFxyXG4gICAgICAgICAgICAgICAgICAgIEVyZXMgdW4gYW5hbGlzdGEgw6FnaWwgZGUgcHJveWVjdG9zLiBBbmFsaXphIGVsIHNpZ3VpZW50ZSByZXBvcnRlIG3DqXRyaWNvIGRlIHVuIG9iamV0aXZvIChPS1IpIGxsYW1hZG8gXCIke2dvYWwudGl0bGV9XCIgeSBlc2NyaWJlIHVuIHDDoXJyYWZvIGNvcnRvIChtw6F4aW1vIDMgb3JhY2lvbmVzKSBjb24gdW4gZGlhZ27Ds3N0aWNvIG1vdGl2YWRvciBwZXJvIG9iamV0aXZvIHBhcmEgZWwgZXF1aXBvLlxyXG4gICAgICAgICAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAgICAgICAgIE3DqXRyaWNhcyBhY3R1YWxlczpcclxuICAgICAgICAgICAgICAgICAgICAtIFNhbHVkIGNhbGN1bGFkYTogJHtoZWFsdGhWYWx1ZX0gKFNjb3JlOiAke2ZpbmFsU2NvcmV9LzEwMClcclxuICAgICAgICAgICAgICAgICAgICAtIFRhcmVhcyBjb21wbGV0YWRhczogJHttZXRyaWNzLmNvbXBsZXRlZFRhc2tzfSBkZSAke21ldHJpY3MudG90YWxUYXNrc31cclxuICAgICAgICAgICAgICAgICAgICAtIFRhcmVhcyB2ZW5jaWRhczogJHttZXRyaWNzLm92ZXJkdWVUYXNrc30gKCR7bWV0cmljcy5jcml0aWNhbFRhc2tzfSBjcsOtdGljYXMpXHJcbiAgICAgICAgICAgICAgICAgICAgLSBUYXJlYXMgZXN0YW5jYWRhczogJHttZXRyaWNzLnN0dWNrVGFza3N9XHJcbiAgICAgICAgICAgICAgICAgICAgLSBDaGVjay1pbnMgZXN0cmVzYWRvczogJHttZXRyaWNzLm5lZ2F0aXZlTW9yYWxlQ291bnR9XHJcbiAgICAgICAgICAgICAgICAgICAgLSBCbG9xdWVvcyByZXBvcnRhZG9zOiAke21ldHJpY3MuYmxvY2tlckNvdW50fVxyXG4gICAgICAgICAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAgICAgICAgIExhcyBhbm9tYWzDrWFzIGRldGVjdGFkYXMgcG9yIGVsIHNpc3RlbWEgZnVlcm9uOlxyXG4gICAgICAgICAgICAgICAgICAgICR7aW5zaWdodHMubWFwKGkgPT4gJy0gJyArIGkubWVzc2FnZSkuam9pbignXFxuJyl9XHJcbiAgICAgICAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgICAgICAgICAgRXNjcmliZSB0dSBhbsOhbGlzaXMgZGlyZWN0YW1lbnRlLCBzaW4gc2FsdWRvcyBuaSBpbnRyb2R1Y2Npb25lcyBnZW7DqXJpY2FzLlxyXG4gICAgICAgICAgICAgICAgYDtcclxuXHJcbiAgICAgICAgICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBtb2RlbC5nZW5lcmF0ZUNvbnRlbnQocHJvbXB0KTtcclxuICAgICAgICAgICAgICAgIGFpU3VtbWFyeSA9IHJlc3VsdC5yZXNwb25zZS50ZXh0KCk7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBhaVN1bW1hcnkgPSBcIk5vIHNlIGNvbmZpZ3Vyw7MgbGEgbGxhdmUgZGUgSUEgcGFyYSBnZW5lcmFyIGVsIHJlc3VtZW4gZGVzY3JpcHRpdm8uXCI7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9IGNhdGNoIChlcnIpIHtcclxuICAgICAgICAgICAgY29uc29sZS5lcnJvcihcIkFJIEdlbmVyYXRpb24gZmFpbGVkOlwiLCBlcnIpO1xyXG4gICAgICAgICAgICBhaVN1bW1hcnkgPSBcIkVsIGFuw6FsaXNpcyBhdmFuemFkbyBubyBlc3TDoSBkaXNwb25pYmxlIGVuIGVzdGUgbW9tZW50by5cIjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIHN1Y2Nlc3M6IHRydWUsXHJcbiAgICAgICAgICAgIGRhdGE6IHtcclxuICAgICAgICAgICAgICAgIGhlYWx0aDogaGVhbHRoVmFsdWUsXHJcbiAgICAgICAgICAgICAgICBzY29yZTogZmluYWxTY29yZSxcclxuICAgICAgICAgICAgICAgIGFpU3VtbWFyeSxcclxuICAgICAgICAgICAgICAgIGluc2lnaHRzLFxyXG4gICAgICAgICAgICAgICAgbWV0cmljc1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICB9IGNhdGNoIChlcnJvcjogYW55KSB7XHJcbiAgICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgY2FsY3VsYXRpbmcgT0tSIGhlYWx0aDonLCBlcnJvcik7XHJcbiAgICAgICAgcmV0dXJuIHsgc3VjY2VzczogZmFsc2UsIGVycm9yOiBlcnJvci5tZXNzYWdlIH07XHJcbiAgICB9XHJcbn1cclxuIl0sIm5hbWVzIjpbImNhbGN1bGF0ZUdvYWxIZWFsdGgiXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/app/actions/analytics.ts\n"));

/***/ })

});